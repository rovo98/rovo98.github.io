<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Requests库的7个主要方法</title>
    <url>/posts/c671c604/</url>
    <content><![CDATA[<h3 id="Requests库的7个主要方法"><a href="#Requests库的7个主要方法" class="headerlink" title="Requests库的7个主要方法"></a>Requests库的7个主要方法</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">requests.request()</td>
<td style="text-align:center">构造一个请求，支撑以下各方法的基础方法</td>
</tr>
<tr>
<td style="text-align:center">requests.get()</td>
<td style="text-align:center">获取HTML网页的主要方法，对应于HTTP的GET</td>
</tr>
<tr>
<td style="text-align:center">requests.head()</td>
<td style="text-align:center">获取HTML网页头信息的方法，对应于HTTP的HEAD</td>
</tr>
<tr>
<td style="text-align:center">requests.post()</td>
<td style="text-align:center">向HTML网页提交POST请求的方法，对应于HTTP的POST</td>
</tr>
<tr>
<td style="text-align:center">requests.put()</td>
<td style="text-align:center">向HTML网页提交PUT请求的方法，对应于HTTP的PUT</td>
</tr>
<tr>
<td style="text-align:center">requests.patch()</td>
<td style="text-align:center">向HTML网页提交局部修改请求，对应于HTTP的PATCH</td>
</tr>
<tr>
<td style="text-align:center">requests.delete()</td>
<td style="text-align:center">向HTML页面提交删除请求，对应HTTP的DELETE</td>
</tr>
</tbody>
</table>
</div>
<h4 id="requests库的主要方法-基础方法"><a href="#requests库的主要方法-基础方法" class="headerlink" title="requests库的主要方法(基础方法)"></a>requests库的主要方法(基础方法)</h4><p><code>requests.request(method, url, **kwargs)</code></p>
<ul>
<li><strong>method:</strong>请求方式，对应get/put/post等7种<ul>
<li><code>r = requests.request(&#39;GET&#39;,url, **kwargs)</code></li>
<li><code>r = requsts.request(&#39;HEAD&#39;,url, **kwargs)</code></li>
<li><code>r = requests.request(&#39;POST&#39;,url, **kwargs)</code></li>
<li><code>r = requests.request(&#39;PATCH&#39;,url, **kwargs)</code></li>
<li><code>r = requests.request(&#39;delete&#39;, url, **kwargs)</code></li>
<li><code>r = requests.request(&#39;OPTIONS&#39;,url, **kwargs)</code></li>
</ul>
</li>
</ul>
<ul>
<li><strong>url:</strong>拟获取页面的URL链接</li>
<li><code>**kwargs</code>: 控制访问的参数，共13个<ul>
<li>1)<code>params</code>:字典或字节序列，作为参数增加到URL中</li>
<li>2)<code>data</code>: 字典、字节序列或者文件对象，作为Request的内容</li>
<li>3)<code>json</code> : JSON格式数据，作为Request内容</li>
<li>4)<code>headers</code> : 字典，HTTP定制头</li>
<li>5)<code>cookies</code> : 字典或CookieJar，Request中的cookie</li>
<li>6)<code>auth</code> : 元组，支持HTTP认证功能</li>
<li>7)<code>files</code> : 字典类型，传输文件</li>
<li>8)<code>timeout</code> : 设定的超时时间，秒为单位</li>
<li>9)<code>proxies</code> : 字典类型，设定访问代理服务器，可以增加登录认证</li>
<li>10)<code>allow_redirects</code> : True/False, 默认为True,重定向开关</li>
<li>11)<code>stream</code> : True/False, 默认为True ,获取内容立即下载开关</li>
<li>12)<code>verify</code> : True/False , 默认为True ， 认证SSL证书开关</li>
<li>13) <code>cert</code> : 本地SSL证书路径<h4 id="requests-get-方法："><a href="#requests-get-方法：" class="headerlink" title="requests.get()方法："></a>requests.get()方法：</h4></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = requests.get(url)    <span class="comment">#构造一个向服务器请求资源的Request对象</span></span><br><span class="line"><span class="comment">#返回一个包含服务器资源的Response对象</span></span><br></pre></td></tr></table></figure>
<p>完整方法：<code>requests.get(url, params=None, **kwargs)</code></p>
<p><code>url</code>: 拟获取页面的url链接</p>
<p> <code>params</code>: url中的额外参数， 字典或字节流格式， 可选</p>
<p><code>**kwargs</code> : 12个控制访问的参数，与request()的一样</p>
<p>实际上是这样的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">url, params=<span class="literal">None</span>, **kwargs</span>):</span></span><br><span class="line">    <span class="comment">#Sends a GET request.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#:param url: URL for the new :class :&#x27;Request&#x27; object.</span></span><br><span class="line">    <span class="comment">#:param params: (optional) Dictionary ro bytes to be sent in the query</span></span><br><span class="line">    <span class="comment">#:return: :class :&#x27;Request &lt;Response&gt;&#x27; object</span></span><br><span class="line">    <span class="comment">#:rtype: requests.Response</span></span><br><span class="line">    </span><br><span class="line">    kwargs.setdefault(<span class="string">&#x27;allow redirect&#x27;</span>, <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> request(<span class="string">&#x27;get&#x27;</span>, url, params=params, **kwargs)</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">r = requests.get(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(r)</span><br><span class="line"><span class="built_in">type</span>(r)</span><br><span class="line">r.headers</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;输出：</span></span><br><span class="line"><span class="string">200</span></span><br><span class="line"><span class="string">&lt;class &#x27;requests.models.Response&#x27;&gt;</span></span><br><span class="line"><span class="string">&#123;&#x27;Transfer-Encoding&#x27;: &#x27;chunked&#x27;, &#x27;Pragma&#x27;: &#x27;no-cache&#x27;, &#x27;Connection&#x27;: &#x27;Keep-Alive&#x27;, &#x27;Last-Modified&#x27;: &#x27;Mon, 23 Jan 2017 13:27:52 GMT&#x27;, &#x27;Cache-Control&#x27;: &#x27;private, no-cache, no-store, proxy-revalidate, no-transform&#x27;, &#x27;Server&#x27;: &#x27;bfe/1.0.8.18&#x27;, &#x27;Set-Cookie&#x27;: &#x27;BDORZ=27315; max-age=86400; domain=.baidu.com; path=/&#x27;, &#x27;Content-Encoding&#x27;: &#x27;gzip&#x27;, &#x27;Date&#x27;: &#x27;Sat, 15 Jul 2017 13:27:01 GMT&#x27;, &#x27;Content-Type&#x27;: &#x27;text/html&#x27;&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="Response对象的属性"><a href="#Response对象的属性" class="headerlink" title="Response对象的属性"></a>Response对象的属性</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">r.status_code</td>
<td style="text-align:center">HTTP请求的返回状态，200表示连接成功，404表示失败</td>
</tr>
<tr>
<td style="text-align:center">r.text</td>
<td style="text-align:center">HTTP响应内容的字符串形式，即，url对应的页面内容</td>
</tr>
<tr>
<td style="text-align:center">r.encoding</td>
<td style="text-align:center">从HTTP header中猜测的响应内容编码方式</td>
</tr>
<tr>
<td style="text-align:center">r.apparent_encoding</td>
<td style="text-align:center">从内容中分析出的响应内容编码方式(备用编码凡是)</td>
</tr>
<tr>
<td style="text-align:center">r.content</td>
<td style="text-align:center">HTTP响应内容的二进制形式</td>
</tr>
</tbody>
</table>
</div>
<p>[注]：<code>r.encoding</code>: 如果<code>header</code>中不存在<code>charset</code>， 则认为编码为<code>ISO-8859-1</code></p>
<h4 id="Requests库的head-方法"><a href="#Requests库的head-方法" class="headerlink" title="Requests库的head()方法"></a>Requests库的head()方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = requests.head(<span class="string">&#x27;http://httpbin.org/get&#x27;</span>)</span><br><span class="line">r.headers</span><br><span class="line">r.text</span><br><span class="line"><span class="string">&quot;&quot;&quot;输出：</span></span><br><span class="line"><span class="string">&#123;&#x27;Access-Control-Allow-Credentials&#x27;: &#x27;true&#x27;, &#x27;X-Processed-Time&#x27;: &#x27;0.000805139541626&#x27;, &#x27;Via&#x27;: &#x27;1.1 vegur&#x27;, &#x27;Access-Control-Allow-Origin&#x27;: &#x27;*&#x27;, &#x27;X-Powered-By&#x27;: &#x27;Flask&#x27;, &#x27;Content-Length&#x27;: &#x27;267&#x27;, &#x27;Server&#x27;: &#x27;meinheld/0.6.1&#x27;, &#x27;Content-Type&#x27;: &#x27;application/json&#x27;, &#x27;Date&#x27;: &#x27;Sat, 15 Jul 2017 14:23:41 GMT&#x27;, &#x27;Connection&#x27;: &#x27;keep-alive&#x27;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27; -- r.text</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="Requests库的post-方法"><a href="#Requests库的post-方法" class="headerlink" title="Requests库的post()方法"></a>Requests库的post()方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = &#123;<span class="string">&#x27;key1&#x27;</span>:<span class="string">&#x27;value1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>:<span class="string">&#x27;value2&#x27;</span>&#125;</span><br><span class="line">r = requests.post(<span class="string">&#x27;http://httpbin.org/post&#x27;</span>, data = payload)</span><br><span class="line">r = requests.post(<span class="string">&#x27;http://httpbin.org/post&#x27;</span>, data = <span class="string">&#x27;ABC&#x27;</span>)</span><br><span class="line"><span class="comment">#向URL POST一个字典自动编码为form(表单)</span></span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br><span class="line"><span class="string">&quot;&quot;&quot;输出:</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;args&quot;: &#123;&#125;, </span></span><br><span class="line"><span class="string">  &quot;data&quot;: &quot;ABC&quot;,    --- &gt; 向URLPOST一个字符串，自动编码为data</span></span><br><span class="line"><span class="string">  &quot;files&quot;: &#123;&#125;, </span></span><br><span class="line"><span class="string">  &quot;form&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;key1&quot;: &quot;value1&quot;, </span></span><br><span class="line"><span class="string">    &quot;key2&quot;: &quot;value2&quot;</span></span><br><span class="line"><span class="string">  &#125;, </span></span><br><span class="line"><span class="string">  &quot;headers&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;Accept&quot;: &quot;*/*&quot;, </span></span><br><span class="line"><span class="string">    &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, </span></span><br><span class="line"><span class="string">    &quot;Connection&quot;: &quot;close&quot;, </span></span><br><span class="line"><span class="string">    &quot;Content-Length&quot;: &quot;23&quot;, </span></span><br><span class="line"><span class="string">    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, </span></span><br><span class="line"><span class="string">    &quot;Host&quot;: &quot;httpbin.org&quot;, </span></span><br><span class="line"><span class="string">    &quot;User-Agent&quot;: &quot;python-requests/2.18.1&quot;</span></span><br><span class="line"><span class="string">  &#125;, </span></span><br><span class="line"><span class="string">  &quot;json&quot;: null, </span></span><br><span class="line"><span class="string">  &quot;origin&quot;: &quot;120.85.181.141&quot;, </span></span><br><span class="line"><span class="string">  &quot;url&quot;: &quot;http://httpbin.org/post&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="Requests库的put-方法"><a href="#Requests库的put-方法" class="headerlink" title="Requests库的put()方法"></a>Requests库的put()方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = &#123;<span class="string">&#x27;key1&#x27;</span>:<span class="string">&#x27;value1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>:<span class="string">&#x27;value2&#x27;</span>&#125;</span><br><span class="line">r = requests.put(<span class="string">&#x27;http://httpbin.org/put&#x27;</span>, data = payload)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br><span class="line"><span class="comment">#此方法与post方法类似，只不过是替换了URL位置上资源的内容</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>Requests库</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式基本使用</title>
    <url>/posts/f85f3c07/</url>
    <content><![CDATA[<p>regular expression regex  RE</p>
<p>简介</p>
<p>正则表达式是用来<strong>简洁</strong>表达一组字符串的表达式。</p>
<blockquote>
<p>正则表达式——一行胜千言</p>
</blockquote>
<ul>
<li>通用的字符串表达框架</li>
<li>简洁表达一组字符串的表达式</li>
<li>针对字符串表达“简洁”和“特征”思想的工具</li>
<li>判断某一字符串的特征归属</li>
</ul>
<span id="more"></span>
<h3 id="正则表达式在文本处理中十分常用"><a href="#正则表达式在文本处理中十分常用" class="headerlink" title="正则表达式在文本处理中十分常用"></a>正则表达式在文本处理中十分常用</h3><ul>
<li>表达文本类型的特征(病毒、入侵等)</li>
<li>同时查找或替换一组字符串</li>
<li>匹配字符串的全部或部分</li>
<li><strong>正则表达式主要应用在字符串的匹配中</strong></li>
</ul>
<h3 id="正则表达式的使用"><a href="#正则表达式的使用" class="headerlink" title="正则表达式的使用"></a>正则表达式的使用</h3><ul>
<li>编译：将符合正则表达式语法的字符串转换成正则表达式特征。—— re.compile(regex)</li>
</ul>
<h3 id="正则表达式的语法"><a href="#正则表达式的语法" class="headerlink" title="正则表达式的语法"></a>正则表达式的语法</h3><h4 id="正则表达式常用的操作符"><a href="#正则表达式常用的操作符" class="headerlink" title="正则表达式常用的操作符"></a>正则表达式常用的操作符</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">表示任何单个字符</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">[ ]</td>
<td style="text-align:center">字符集，对单个字符给出取值范围</td>
<td style="text-align:center">[abc]表示a、b、c, [a-z]表示a到z单个字符</td>
</tr>
<tr>
<td style="text-align:center">[^ ]</td>
<td style="text-align:center">非字符集，对单个字符给出排除范围</td>
<td style="text-align:center">[^abc]表示非a或b或c的单个字符</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">前一个字符0次或无限次扩展</td>
<td style="text-align:center">abc*表示ab、abc、abcc、abcc等</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">前一个字符1次或无限次扩展</td>
<td style="text-align:center">abc+表示abc、abcc、abccc等</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:center">前一个字符0次或1次扩展</td>
<td style="text-align:center">abc?表示ab、abc</td>
</tr>
<tr>
<td style="text-align:center">&#124;</td>
<td style="text-align:center">左右表达式任意一个</td>
<td style="text-align:center">abc &#124; def表示abc、def</td>
</tr>
<tr>
<td style="text-align:center">{m}</td>
<td style="text-align:center">扩展前一个字符m次</td>
<td style="text-align:center">ab{2}c表示abbc</td>
</tr>
<tr>
<td style="text-align:center">{m,n}</td>
<td style="text-align:center">扩展前一个字符m至n次</td>
<td style="text-align:center">ab{1,2}c表示abc、abbc</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">匹配字符串开头</td>
<td style="text-align:center">^abc表示abc且在一个字符串的开头</td>
</tr>
<tr>
<td style="text-align:center">$</td>
<td style="text-align:center">匹配字符串结尾</td>
<td style="text-align:center">abc$表示abc且在一个字符串的结尾</td>
</tr>
<tr>
<td style="text-align:center">( )</td>
<td style="text-align:center">分组标记，内部只能使用 &#124; 操作符</td>
<td style="text-align:center">(abc)表示abc ，(abc&#124;def)表示abc、def</td>
</tr>
<tr>
<td style="text-align:center">\d</td>
<td style="text-align:center">数字，等价于[0-9]</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">\w</td>
<td style="text-align:center">单词字符，等价于[A-Za-z0-9]</td>
</tr>
</tbody>
</table>
</div>
<h4 id="经典正则表达式实例"><a href="#经典正则表达式实例" class="headerlink" title="经典正则表达式实例"></a>经典正则表达式实例</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><code>^[A-Za-z]+$</code></th>
<th style="text-align:center">由26个字母组成的字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>^[A-za-z0-9]+$</code></td>
<td style="text-align:center">由26个字母及数字组成的字符串</td>
</tr>
<tr>
<td style="text-align:center"><code>^-?\d+$</code></td>
<td style="text-align:center">整数形式的字符串</td>
</tr>
<tr>
<td style="text-align:center"><code>^[0-9]\*\[1-9][0-9]*$</code></td>
<td style="text-align:center">正整数形式的字符串</td>
</tr>
<tr>
<td style="text-align:center"><code>[1-9]\d&#123;5&#125;</code></td>
<td style="text-align:center">中国境内的邮政编码，6 位</td>
</tr>
<tr>
<td style="text-align:center"><code>[\u4e00-\u9fa5]</code></td>
<td style="text-align:center">匹配中文字符</td>
</tr>
<tr>
<td style="text-align:center">\d{3}-\d{8} &#124; \d{4}-\d{7}</td>
<td style="text-align:center">国内电话</td>
</tr>
</tbody>
</table>
</div>
<p>IP地址:</p>
<ul>
<li>不精确的写法：<ul>
<li><code>\d+.\d+.\d+.\d+</code>  —— 以四个点进行分隔作为特点</li>
<li><code>\d&#123;1,3&#125;.\d&#123;1,3&#125;.\d&#123;1,3&#125;.\d&#123;1,3&#125;</code></li>
</ul>
</li>
<li>精确写法：<br>0-99 : <code>[0-9]?\d</code>        100-199 : <code>1\d&#123;2&#125;</code><br>200-249 : <code>2[0-4]\d</code>   250-255 : <code>25[0-5]</code><br><code>(([0-9]?\d|1\d&#123;2&#125;|2[0-4]\d|25[0-5]).)&#123;3&#125;([0-9]?\d|1\d&#123;2&#125;|2[0-4]\d|25[0-5])</code></li>
</ul>
<h3 id="Re库的基本使用"><a href="#Re库的基本使用" class="headerlink" title="Re库的基本使用"></a>Re库的基本使用</h3><h4 id="Re库介绍"><a href="#Re库介绍" class="headerlink" title="Re库介绍"></a>Re库介绍</h4><p>Re库是Python的标准库，主要用于字符串匹配。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure>
<h4 id="正则表达式的表示类型"><a href="#正则表达式的表示类型" class="headerlink" title="正则表达式的表示类型"></a>正则表达式的表示类型</h4><ul>
<li>raw string 类型(原生字符串类型) —— 不包含转义字符<br>re 库采用raw string 类型表示正则表达式，表示为：r’text’</li>
<li>string类型， 更繁琐  —— 需要双重转义</li>
</ul>
<h4 id="Re库的主要功能函数"><a href="#Re库的主要功能函数" class="headerlink" title="Re库的主要功能函数"></a>Re库的主要功能函数</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>re.search()</code></td>
<td style="text-align:center">在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象</td>
</tr>
<tr>
<td style="text-align:center"><code>re.match()</code></td>
<td style="text-align:center">在一个字符串开始位置起匹配正则表达式，返回match对象</td>
</tr>
<tr>
<td style="text-align:center"><code>re.findall()</code></td>
<td style="text-align:center">搜索字符串，以列表类型返回全部能匹配的子串</td>
</tr>
<tr>
<td style="text-align:center"><code>re.spilt()</code></td>
<td style="text-align:center">将一个字符串按照正则表达式匹配结果进行分割，返回列表类型</td>
</tr>
<tr>
<td style="text-align:center"><code>re.fiinditer()</code></td>
<td style="text-align:center">搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match</td>
</tr>
<tr>
<td style="text-align:center"><code>re.sub()</code></td>
<td style="text-align:center">在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串</td>
</tr>
</tbody>
</table>
</div>
<h5 id="re-search-pattern-string-flags-0"><a href="#re-search-pattern-string-flags-0" class="headerlink" title="re.search(pattern, string,flags=0)"></a><code>re.search(pattern, string,flags=0)</code></h5><ul>
<li>在一个字符串中搜索匹配正则表达式的第一个位置，返回<code>match</code>对象<ul>
<li><code>pattern</code>:  正则表达式的字符串或者原生字符串 表示</li>
<li><code>string</code> : 待匹配字符串</li>
<li><code>flags</code> : 正则表达式使用时的控制标记</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">常用标记</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>re.I re.IGNORECASE</code></td>
<td style="text-align:center">忽略正则表达式的大小写，[A-Z]能够匹配小写字符</td>
</tr>
<tr>
<td style="text-align:center"><code>re.M RE.MULTILINE</code></td>
<td style="text-align:center">正则表达式中的^操作符能够将给定字符串的每行当作匹配开始</td>
</tr>
<tr>
<td style="text-align:center"><code>re.S   RE.DOTALL</code></td>
<td style="text-align:center">正则表达式中的.操作符能够匹配所有字符，默认匹配除换行符外的所有字符</td>
</tr>
</tbody>
</table>
</div>
<h5 id="re-match-partern-string-flags-0"><a href="#re-match-partern-string-flags-0" class="headerlink" title="re.match(partern, string, flags=0)"></a><code>re.match(partern, string, flags=0)</code></h5><ul>
<li>从一个字符串的开始位置起匹配正则表达式，返回<code>match</code>对象</li>
</ul>
<h5 id="re-findall-pattern-string-flags-0"><a href="#re-findall-pattern-string-flags-0" class="headerlink" title="re.findall(pattern, string , flags=0)"></a><code>re.findall(pattern, string , flags=0)</code></h5><ul>
<li>搜索字符串，以列表类型返回全部能匹配的子串。<ul>
<li><code>pattern</code> ： 正则表达式的字符串或原生字符串表示</li>
<li><code>string</code> ： 待匹配字符串</li>
<li><code>flags:</code> 正则表达式使用时的控制标记</li>
</ul>
</li>
</ul>
<h5 id="re-split-pattern-string-maxsplit-0-flags-0"><a href="#re-split-pattern-string-maxsplit-0-flags-0" class="headerlink" title="re.split(pattern, string, maxsplit=0, flags=0)"></a><code>re.split(pattern, string, maxsplit=0, flags=0)</code></h5><ul>
<li>将一个字符串按照正则表达式匹配结果进行分割，返回列表类型。<ul>
<li><code>maxsplit</code>: 最大分割数</li>
</ul>
</li>
</ul>
<h5 id="re-finditer-patern-string-flags-0"><a href="#re-finditer-patern-string-flags-0" class="headerlink" title="re.finditer(patern, string, flags=0)"></a><code>re.finditer(patern, string, flags=0)</code></h5><ul>
<li>搜索字符串，返回一个匹配结果的迭代类型，每一个迭代元素是<code>match</code>对象。</li>
</ul>
<h5 id="re-sub-pattern-repl-string-count-0-flags-0"><a href="#re-sub-pattern-repl-string-count-0-flags-0" class="headerlink" title="re.sub(pattern, repl, string, count=0, flags=0)"></a><code>re.sub(pattern, repl, string, count=0, flags=0)</code></h5><ul>
<li>在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串。<ul>
<li><code>repl</code>: 替换匹配字符串的字符串</li>
<li><code>count</code>： 替换的最大次数</li>
</ul>
</li>
</ul>
<h5 id="Re库的另一种等价用法"><a href="#Re库的另一种等价用法" class="headerlink" title="Re库的另一种等价用法"></a>Re库的另一种等价用法</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rst = re.search(<span class="string">r&#x27;[1-9]\d&#123;5&#125;&#x27;</span>, <span class="string">&#x27;BIT100081&#x27;</span>)</span><br><span class="line"><span class="comment">#函数式用法： 一次性操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#面向对象用法：编译后的多次操作</span></span><br><span class="line">pat = re.<span class="built_in">compile</span>(<span class="string">r&#x27;[1-9]\d&#123;5&#125;&#x27;</span>)</span><br><span class="line">rst = pat.search(<span class="string">&#x27;BIT100081&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h5 id="regex-re-compile-pattern-flags-0"><a href="#regex-re-compile-pattern-flags-0" class="headerlink" title="regex  = re.compile(pattern, flags=0)"></a><code>regex  = re.compile(pattern, flags=0)</code></h5><ul>
<li>将正则表达式的字符串形式编译成正则表达式对象</li>
</ul>
<h4 id="Re库的match对象"><a href="#Re库的match对象" class="headerlink" title="Re库的match对象"></a>Re库的match对象</h4><h5 id="Match对象的属性"><a href="#Match对象的属性" class="headerlink" title="Match对象的属性"></a>Match对象的属性</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>.string</code></td>
<td style="text-align:center">待匹配文本</td>
</tr>
<tr>
<td style="text-align:center"><code>.re</code></td>
<td style="text-align:center">匹配时使用的pattern对象()正则表达式</td>
</tr>
<tr>
<td style="text-align:center"><code>.pos</code></td>
<td style="text-align:center">正则表达式搜索文本的开始位置</td>
</tr>
<tr>
<td style="text-align:center"><code>.endpos</code></td>
<td style="text-align:center">正则表达式搜索文本的结束位置</td>
</tr>
</tbody>
</table>
</div>
<h5 id="Match对象的方法"><a href="#Match对象的方法" class="headerlink" title="Match对象的方法"></a>Match对象的方法</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>.group(0)</code></td>
<td style="text-align:center">获得匹配后的字符串</td>
</tr>
<tr>
<td style="text-align:center"><code>.start()</code></td>
<td style="text-align:center">匹配字符串在原始字符串的开始位置</td>
</tr>
<tr>
<td style="text-align:center"><code>.end()</code></td>
<td style="text-align:center">匹配字符串在原始字符串的结束位置</td>
</tr>
<tr>
<td style="text-align:center"><code>.span()</code></td>
<td style="text-align:center">返回<code>(.start(),.end())</code> — 元组类型</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Re库的贪婪匹配和最小匹配"><a href="#Re库的贪婪匹配和最小匹配" class="headerlink" title="Re库的贪婪匹配和最小匹配"></a>Re库的贪婪匹配和最小匹配</h4><ul>
<li>Re库默认采用贪婪匹配</li>
</ul>
<h5 id="最小匹配操作符"><a href="#最小匹配操作符" class="headerlink" title="最小匹配操作符"></a>最小匹配操作符</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">*?</td>
<td style="text-align:center">前一个字符0次或无限次扩展，最小匹配</td>
</tr>
<tr>
<td style="text-align:center">+?</td>
<td style="text-align:center">前一个字符1次或无限次扩展，最小匹配</td>
</tr>
<tr>
<td style="text-align:center">??</td>
<td style="text-align:center">前一个字符0次或1次扩展，最小匹配</td>
</tr>
<tr>
<td style="text-align:center">{m,n}?</td>
<td style="text-align:center">扩展前一个字符m至n次(含n)，最小匹配</td>
</tr>
</tbody>
</table>
</div>
<h3 id="高效的正则表达式技巧总结"><a href="#高效的正则表达式技巧总结" class="headerlink" title="高效的正则表达式技巧总结"></a>高效的正则表达式技巧总结</h3><h4 id="误匹配"><a href="#误匹配" class="headerlink" title="误匹配"></a>误匹配</h4><p> 指<strong>正则表达式</strong>所匹配的内容范围超过了所需要范围，有些文本命名不符合要求，但是被所写的正则表达式“击中”了。例如：如果使用<code>\d&#123;11&#125;</code>去匹配11位手机号，<code>\d&#123;11&#125;</code>不单单能匹配正确的手机号，它还会匹配98824839344这样明显不是手机号的<strong>字符串</strong>。我们把这样的匹配称为<strong>误匹配</strong>。</p>
<h4 id="漏匹配"><a href="#漏匹配" class="headerlink" title="漏匹配"></a>漏匹配</h4><p> 指正则表达式所匹配的内容所规定的范围太狭窄，有些文本确实是所需要的，但是所写的正则表达式没有将这种情况囊括在内。例如：使用\d{18}来匹配身份证号码，就会漏掉结尾是字母X的情况。<br>  写出一条<strong>正则表达式</strong>，既可能出现<strong>误匹配</strong>(条件写得太宽松，范围大于目标文本)，也可能出现<strong>漏匹配</strong>(只描述了目标文本中多种情况的部分)，还可能既有<strong>误匹配</strong>又有<strong>漏匹配</strong>。例如：使用<code>\w+\.com</code>来匹配<code>.com</code>结尾的域名，既会误匹配<code>abc\_.com</code>(合法域名不包含<code>\_</code>,<code>\w</code>包含了这种情况),又会漏掉<code>ab-c.com</code>这样的域名(合法域名可以包含中划线，<code>\w</code>不包含中划线).</p>
<h4 id="应对方法"><a href="#应对方法" class="headerlink" title="应对方法"></a>应对方法</h4><h5 id="掌握语法细节"><a href="#掌握语法细节" class="headerlink" title="掌握语法细节"></a>掌握语法细节</h5><p> 正则表达式在各种语言中，其语法大致相同，细节各有千秋。明确所使用语言的正则的语法的细节，是写出正确、高效<strong>正则表达式</strong>的基础。例如，perl中与<code>\w</code>等效的匹配范围是<code>[a-zA-Z0-9\_]</code>;perl正则表达式不支持肯定逆序视中使用可变的重复(variable repetition inside lookbehind,例如<code>( ?&lt;=.* )abc)</code>, 但是.Net语法是支持这一特性的；又如，JavaScript连逆序环视(lookbehind,如<code>(?&lt;=ab)c)</code>都不支持，而Perl和Python是支持的。&lt;&lt;精通正则表达式&gt;&gt;第三章&lt;&lt;正则表达式的特性和流派概览&gt;&gt;明确地列出了个大派系的正则表达式的异同。</p>
<h5 id="先粗后精，先减后加"><a href="#先粗后精，先减后加" class="headerlink" title="先粗后精，先减后加"></a>先粗后精，先减后加</h5><p> 使用正则表达式语法对于目标文本进行描述和界定，可以像画素描一样，先大致勾勒出框架，在逐步在局部实现细节。仍举刚才的手机例子：先界定<code>\d&#123;11&#125;</code>,总不会错；再细化为<code>1[358]\d&#123;9&#125;</code>,就向前迈了一大步。先消除 <strong>漏匹配</strong>(刚开始先尽可能多的匹配，做加法)，然后再一点点去除<strong>误匹配</strong>(做减法)。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>regex基础</tag>
      </tags>
  </entry>
  <entry>
    <title>理解Requests库的异常和HTTP协议</title>
    <url>/posts/4ae864e2/</url>
    <content><![CDATA[<p>简单理解Requests库中的异常和HTTP协议。</p>
<span id="more"></span>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">异常</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">requests.ConnectionError</td>
<td style="text-align:center">网络连接错误异常，如DNS查询失败、拒绝连接等</td>
</tr>
<tr>
<td style="text-align:center">requests.HTTPError</td>
<td style="text-align:center">HTTP错误异常</td>
</tr>
<tr>
<td style="text-align:center">requests.URLRequired</td>
<td style="text-align:center">URl缺失异常</td>
</tr>
<tr>
<td style="text-align:center">requests.TooManyRedirects</td>
<td style="text-align:center">超过最大重定向次数，产生重定向异常</td>
</tr>
<tr>
<td style="text-align:center">requests.ConnectTimeout</td>
<td style="text-align:center">连接远程服务器超时异常</td>
</tr>
<tr>
<td style="text-align:center">requests.Timeout</td>
<td style="text-align:center">请求URL超时，产生超时异常</td>
</tr>
</tbody>
</table>
</div>
<p>Response的异常：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">异常</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">r.raise_for_status()</td>
<td style="text-align:center">如果不是200， 产生异常requests.HTTPError</td>
</tr>
</tbody>
</table>
</div>
<p><strong>爬取网页的通用代码框架</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span>(<span class="params">url</span>) :</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url, timeout=<span class="number">30</span>)</span><br><span class="line">        r.raise_for_status() <span class="comment">#如果状态不是200， 引发requests.HTTPError异常</span></span><br><span class="line">        r.encoding = r.apparent_encoding <span class="comment">#将encoding 设置为&#x27;utf-8&#x27;，一般用于没有charset的header</span></span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;产生异常&#x27;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    url = <span class="string">&quot;http://www.baidu.com&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(getHTMLText(url))</span><br></pre></td></tr></table></figure>
<h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><p>HTTP, Hypertext Transfer Protocol, 超文本传输协议</p>
<p>HTTP是一个基于“请求与响应”模式的、无状态的应用层协议。</p>
<p>HTTP协议采用URL作为定位网络资源的标识。</p>
<p><strong>URL格式：</strong> <code>http://host[ :port ][ path ]</code></p>
<p>HTTP URL的理解：</p>
<p>URL 是通过HTTP协议存取资源的Internet路径，一个URL对应一个数据资源。</p>
<h4 id="HTTP协议对资源的操作"><a href="#HTTP协议对资源的操作" class="headerlink" title="HTTP协议对资源的操作"></a>HTTP协议对资源的操作</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">GET</td>
<td style="text-align:center">请求获取URL位置的资源</td>
</tr>
<tr>
<td style="text-align:center">HEAD</td>
<td style="text-align:center">请求获取URL位置资源的响应消息报告，即获取该资源的头部信息</td>
</tr>
<tr>
<td style="text-align:center">POST</td>
<td style="text-align:center">请求URL位置的资源后附加新的数据</td>
</tr>
<tr>
<td style="text-align:center">PUT</td>
<td style="text-align:center">请求向URL位置存储一个资源，覆盖原URL位置的资源</td>
</tr>
<tr>
<td style="text-align:center">PATCH</td>
<td style="text-align:center">请求局部更新URL位置的资源，即改变该处资源的部分内容</td>
</tr>
<tr>
<td style="text-align:center">DELETE</td>
<td style="text-align:center">请求删除URL位置存储的资源</td>
</tr>
</tbody>
</table>
</div>
<p><strong>理解PATCH和PUT的区别</strong>：</p>
<p>假设URL位置有一组数据<code>UserInfo</code>， 包括<code>UserID</code>、<code>UserName</code>等20个字段</p>
<p> 需求：用户修改了<code>UserName</code>，其他不变。</p>
<p>采用PATCH，仅向URL提交<code>UserName</code>的更新请求。</p>
<p>采用PUT，必须将所有20个字段一并提交URL，未提交字段被删除。<br>PATCH的好处：节省网络带宽</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>Requests库</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>爬取校内腾讯企业邮箱通信录</title>
    <url>/posts/e675b5d9/</url>
    <content><![CDATA[<p>简单使用python <code>request</code> + <code>re</code> 爬取校内邮箱通信录(腾讯企业邮箱)的用户信息数据。</p>
<span id="more"></span>
<h3 id="一、分析需要爬取的数据"><a href="#一、分析需要爬取的数据" class="headerlink" title="一、分析需要爬取的数据"></a>一、分析需要爬取的数据</h3><p>通过手动打开浏览器，正常访问网站，判断需要爬取的数据是静态还是动态数据，制定不同的爬取方案。</p>
<h4 id="1-静态-动态-数据类型判断"><a href="#1-静态-动态-数据类型判断" class="headerlink" title="1. 静态/动态 数据类型判断"></a>1. 静态/动态 数据类型判断</h4><p>登陆企业校内邮箱，可以看到需要获取的内容主要呈现在该页面:<br><br><img data-src="step_01.png" alt=""></p>
<p><code>F12</code>打开控制台，查看<code>Elements</code>，可以很容易发现，用户数据在目录节点没有展开的情况下，html文档中并不会包含我们需要的数据，当点击展开目录节点后，才能获取到数据。<br><br><img data-src="step_02.png" alt=""><br>因此，可以判断，我们需要爬取的数据是动态生成的，可以初步认为是通过<code>AJAX</code>异步请求来从服务器端获取数据的。</p>
<h4 id="2-数据定位"><a href="#2-数据定位" class="headerlink" title="2. 数据定位"></a>2. 数据定位</h4><p>我们已经知道了需要爬取的数据是动态生成的，这时，同样<code>F12</code>打开控制台，到<code>Network</code>栏目下，查找类型为<code>XHR</code>(AJAX的请求链接)的请求链接，并按数据文件大小从到小排序，再次刷新页面，点击通讯录栏目，展开到具体的用户项，依次点击<code>XHR</code>以确定需要的数据是通过哪个链接获取的：<br><br><img data-src="step_03.png" alt=""></p>
<p>可以看到，请求链接格式为:<code>https://exmail.qq.com/cgi-bin/laddr_biz?t=memtree&amp;limit=&#123;limit&#125;&amp;partyid=&#123;pid&#125;&amp;action=show_party&amp;sid=&#123;sid&#125;</code>,参数有 - <br /></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Argument</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">t</td>
<td style="text-align:center">取值不变,<code>memtree</code>，具体含义就不管了</td>
</tr>
<tr>
<td style="text-align:center">limit</td>
<td style="text-align:center">链接中取值:<code>500</code>,单次获取用户的最大数量，<br>我们可以自己修改，再次发起请求来验证</td>
</tr>
<tr>
<td style="text-align:center">partyid</td>
<td style="text-align:center">变化值，为所属组的id,例如：<br>学生 -&gt; 专业 -&gt; 院系<br>学生所属专业<code>partyid</code>就是的专业的<code>id</code>,etc.</td>
</tr>
<tr>
<td style="text-align:center">action</td>
<td style="text-align:center">在此链接中不变，取值:<code>show_party</code></td>
</tr>
<tr>
<td style="text-align:center">sid</td>
<td style="text-align:center">用户登陆后生成的<code>sid</code>值，访问过程中不变</td>
</tr>
</tbody>
</table>
</div>
<p><img data-src="step_04.png" alt=""></p>
<p>通过上面的分析，我们可以知道，要获取所有学生的信息，主要是在获取所有的专业的<code>id</code>后，依次作为上面链接的<code>partyid</code>来发起请求即可。</p>
<p>尝试在html <code>Elements</code>文档中搜索，能够搜到相应的数据，但它也是动态生成的 - </p>
<p><img data-src="step_05.png" alt=""></p>
<p>继续在<code>Network</code>中将过滤类型设置为<code>doc</code>同时按文件大小排序，查找包含<code>oPartyList</code>的文件 -</p>
<p><img data-src="step_06.png" alt=""></p>
<p>到此，我们所有的分析任务已经结束了，接下来只需要编写相应的爬虫程序即可。</p>
<h3 id="二、爬虫程序设计"><a href="#二、爬虫程序设计" class="headerlink" title="二、爬虫程序设计"></a>二、爬虫程序设计</h3><p>这里只是编写一个简单的爬虫程序，不使用IP代理，爬虫发起请求所需的<code>sid</code>通过用户自己登陆后手动获取，相应的<code>cookie</code>也是如此。</p>
<h4 id="1-获取所有专业的id"><a href="#1-获取所有专业的id" class="headerlink" title="1. 获取所有专业的id"></a>1. 获取所有专业的id</h4><p>上面分析提到的，要获取用户数据，主要是要先获取到用户所在的组id<code>partyid</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAllPID</span>():</span></span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取所有的专业id,作为用户的pid.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    sid = <span class="string">&#x27;xxx&#x27;</span>   <span class="comment"># 用户登陆后的sid</span></span><br><span class="line">    all_parties_url = <span class="string">&#x27;https://exmail.qq.com/cgi-bin/laddr_biz?action=show_party_list&amp;sid=&#123;sid&#125;&amp;t=contact&amp;view=biz&#x27;</span>.<span class="built_in">format</span>(sid=sid)</span><br><span class="line">    cookies = <span class="built_in">dict</span>(...) <span class="comment"># cookie参数和值</span></span><br><span class="line">    request = request.get(all_parties_url,cookies=cookies)</span><br><span class="line">    </span><br><span class="line">    regexp = <span class="string">r&#x27;&#123;id:&quot;(\S*?)&quot;, pid:&quot;(\S*?)&quot;, name:&quot;(\S*?)&quot;, order:&quot;(\S*?)&quot;&#125;&#x27;</span></span><br><span class="line">    results = re.findall(regexp,text)</span><br><span class="line">    all_parties_ids = []       <span class="comment"># 所有pid</span></span><br><span class="line">    all_parties_info = <span class="built_in">dict</span>() <span class="comment"># 所有组信息</span></span><br><span class="line">    root_party = <span class="literal">None</span>      <span class="comment"># 根通信组</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> results:</span><br><span class="line">    	all_parties_id.append(p[<span class="number">0</span>])</span><br><span class="line">        party = <span class="built_in">dict</span>(<span class="built_in">id</span>=item[<span class="number">0</span>], pid=item[<span class="number">1</span>], name=item[<span class="number">2</span>], order=item[<span class="number">3</span>])</span><br><span class="line">        all_parties_info[item[<span class="number">0</span>]] = party</span><br><span class="line">        <span class="keyword">if</span> p[<span class="number">1</span>] == <span class="number">0</span> <span class="keyword">or</span> p[<span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        	root_party = party</span><br></pre></td></tr></table></figure>
<h4 id="2-获取学生信息数据"><a href="#2-获取学生信息数据" class="headerlink" title="2. 获取学生信息数据"></a>2. 获取学生信息数据</h4><p>依次遍历<code>pid</code>列表，构造不同的<code>pid</code>不同的链接，来获取全部的通讯录内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAllUserInfo</span>():</span></span><br><span class="line">	...</span><br><span class="line">    获取所有通讯录用户信息</span><br><span class="line">    ...</span><br><span class="line">    all_user_info = []  <span class="comment"># 用于保存所有用户数据信息</span></span><br><span class="line">    <span class="comment"># 获取用户数据的链接</span></span><br><span class="line">    party_user_url = <span class="string">&#x27;https://exmail.qq.com/cgi-bin/laddr_biz?t=memtree&amp;limit=&#123;limit&#125;&#x27;</span>\</span><br><span class="line">    				<span class="string">&#x27;&amp;partyid=&#123;pid&#125;&amp;action=show_party&amp;sid=&#123;sid&#125;&#x27;</span></span><br><span class="line">    regexp = <span class="string">r&#x27;&#123;uin:&quot;(\S*?)&quot;, pid:&quot;(\S*?)&quot;, alias:&quot;(\S*?)&quot;, sex:&quot;(\S*?), pos:&quot;(\S*?)&quot;, tel:&quot;(\S*?)&quot;,&#x27;</span>\</span><br><span class="line">    		<span class="string">&#x27; birth:&quot;(\S*?)(\S*?)(\S*?)(\S*?)&quot;, slave_alias:&quot;(\S*?)(\S*?)(\S*?)&quot;, department:&quot;(\S*?)(\S*?)&quot;, mobile:&quot;(\S*?)&quot;&#125;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> pid <span class="keyword">in</span> all_parites_ids:</span><br><span class="line">        <span class="comment"># 依次构造不同pid的请求链接</span></span><br><span class="line">    	url = party_user_url.<span class="built_in">format</span>(limit=limit, pid=pid, sid=sid)</span><br><span class="line">        request = requests.get(url, cookies=cookies)</span><br><span class="line">        text = request.text</span><br><span class="line">        results = re.findall(regexp, text)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> results:</span><br><span class="line">        	user = <span class="built_in">dict</span>(uin=item[<span class="number">0</span>], pid=item[<span class="number">1</span>], name=item[<span class="number">2</span>], alias=item[<span class="number">3</span>], sex=item[<span class="number">4</span>],</span><br><span class="line">            		pos=item[<span class="number">5</span>], tel=item[<span class="number">6</span>],birth=item[<span class="number">7</span>], slave_alias=item[<span class="number">8</span>], department=item[<span class="number">9</span>],</span><br><span class="line">                   mobile=item[<span class="number">10</span>])</span><br><span class="line">         	all_user_info.append(user)</span><br></pre></td></tr></table></figure>
<p>完整的程序，请移步到<a href="https://github.com/rovo98/python-learning/blob/master/web-spiders/tx_email_spider/tx_email_spider.py">Github</a>查看.</p>
<h3 id="三、爬取结果"><a href="#三、爬取结果" class="headerlink" title="三、爬取结果"></a>三、爬取结果</h3><p><img data-src="step_07.png" alt=""></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>Spider demo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用ensp进行简单的路由器互连实验</title>
    <url>/posts/cc46ce96/</url>
    <content><![CDATA[<p><img data-src="/images/ensp_路由连接实验/route-structure.png" alt=""></p>
<p>使用ensp做华为AR1220路由进行简单的互连实验。</p>
<span id="more"></span>
<h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><ul>
<li>路由器设置</li>
<li>手动设置静态路由</li>
</ul>
<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul>
<li>华为路由器AR1220</li>
<li>主机</li>
<li>Serial设备连接串口线和Copper以太网和千兆以太网连接线</li>
</ul>
<p>备注：所有实验设备均由<strong>ensp</strong>模拟。</p>
<h4 id="路由连接实验设计"><a href="#路由连接实验设计" class="headerlink" title="路由连接实验设计"></a>路由连接实验设计</h4><p>整体设计结构如下：</p>
<ul>
<li>1.其中分为六个不同的局域网；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.11.0 网段 -&gt;</span><br><span class="line">    主机:   192.168.11.11</span><br><span class="line">            192.168.11.12</span><br><span class="line">    路由器AR6一个GigabitEthernet接口作为该网段的默认网关(192.168.11.1)</span><br><span class="line"></span><br><span class="line">192.168.12.0 网段 -&gt;</span><br><span class="line">    主机:   192.168.12.11</span><br><span class="line">            192.168.12.12</span><br><span class="line">    路由器AR4的一个GigabitEthernet接口作为该网段的默认网关(192.168.12.1)</span><br><span class="line"></span><br><span class="line">192.168.13.0 网段 -&gt;</span><br><span class="line">    主机:    192.168.13.11</span><br><span class="line">            192.168.13.12</span><br><span class="line">            192.168.13.13</span><br><span class="line">   路由器AR7的一个GigabitEthernet接口作为该网段的默认网关(192.168.13.1)</span><br><span class="line">   </span><br><span class="line">1.1.2.0 网段 -&gt; 路由器AR6和路由器AR7之间的接口</span><br><span class="line">1.1.1.0 网段 -&gt; 路由器AR6和AR4之间的接口</span><br><span class="line">1.1.3.0 网段 -&gt; 路由器AR6和AR7之间的接口</span><br></pre></td></tr></table></figure>
<ul>
<li>2.设备的连接：</li>
</ul>
<blockquote>
<p>除了路由器之间连接使用serial串口连接线外，其他均使用Copper连接线。</p>
</blockquote>
<h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><h4 id="配置各个局域网的ip及其网关"><a href="#配置各个局域网的ip及其网关" class="headerlink" title="配置各个局域网的ip及其网关"></a>配置各个局域网的ip及其网关</h4><ul>
<li>例如：<code>192.168.11.0</code>网段下的<code>192.168.11.11</code>主机：</li>
</ul>
<p><img data-src="pc1_setting.jpg" alt="PC1"></p>
<ul>
<li>配置 <code>192.168.11.1</code>作为<code>192.168.11.0</code>网段的网关：</li>
</ul>
<p><img data-src="gateway1.png" alt="设置网关"></p>
<p>所有主机经过配置后，他们应该可以ping通自己网段下的所有主机，如：<code>192.168.11.12</code> ping <code>192.168.11.11</code></p>
<p><img data-src="pingTest.jpg" alt="局域网ping测试"></p>
<p><strong>[需要注意的是]</strong>： 由于路由器互连时使用的是serial串口，所以路由器之间配置的是serial串口的ip。</p>
<p>例如：配置AR6的两个serial串口的接口ip为：<code>1.1.1.1</code>和<code>1.1.2.1</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] inter serial 2/0/1</span><br><span class="line">[Huawei-Servial2/0/1] ip address 1.1.1.1 255.255.255.0</span><br><span class="line">[Huawei-Servial2/0/1] quit</span><br><span class="line">[Huawei] inter serial 2/0/0</span><br><span class="line">[Huawei-Serial2/0/0] ip address 1.1.2.1 255.255.255.0</span><br></pre></td></tr></table></figure>
<h4 id="各个路由器的静态路由："><a href="#各个路由器的静态路由：" class="headerlink" title="各个路由器的静态路由："></a>各个路由器的静态路由：</h4><p>对于路由器AR6,我们希望所有<strong>目的网络</strong>为<code>192.168.12.0</code>的数据包都交付给AR4,即下一跳为<code>1.1.1.2</code>;所有目的网络为<code>192.168.13.0</code>的都交给AR7,下一跳为<code>1.1.2.2</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] ip route-static 192.168.12.0 255.255.255.0 1.1.1.2</span><br><span class="line">[Huawei] ip route-static 192.168.13.0 255.255.255.0 1.1.2.2</span><br></pre></td></tr></table></figure>
<p>对于路由器AR4，所有目的网络为<code>192.168.11.0</code>的数据包交给AR6，下一跳为：<code>1.1.1.1</code>，目的网络为<code>192.168.13.0</code>的数据包交给AR7，下一跳为：<code>1.1.3.1</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] ip route-static 192.168.11.0 255.255.255.0 1.1.1.1</span><br><span class="line">[Huawei] ip route-static 192.168.13.0 255.255.255.0 1.1.3.1</span><br></pre></td></tr></table></figure>
<p>对于路由器AR7， 所有目的网络为<code>192.168.11.0</code>的数据包都交给AR6，下一跳为：<code>1.1.2.1</code>，所有目的网络为<code>192.168.12.0</code>的数据包都交给AR4，下一跳为：<code>1.1.3.2</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] ip route-static 192.168.11.0 255.255.255.0 1.1.2.1</span><br><span class="line">[Huawei] ip route-static 192.168.12.0 255.255.255.0 1.1.3.2</span><br></pre></td></tr></table></figure>
<p>经过以上对各个路由器的静态路由的配置后，我们可以通过<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">display ip routing-table</span><br></pre></td></tr></table></figure><br>来查看各个路由器的路由表：</p>
<ul>
<li>AR6路由表：</li>
</ul>
<p><img data-src="route1_info.jpg" alt="AR6路由表"></p>
<ul>
<li>AR4路由表：</li>
</ul>
<p><img data-src="route2_info.jpg" alt="AR4路由表"></p>
<ul>
<li>AR7路由表：</li>
</ul>
<p><img data-src="route3_info.jpg" alt="AR7路由表"></p>
<h3 id="测试实验结果"><a href="#测试实验结果" class="headerlink" title="测试实验结果"></a>测试实验结果</h3><p>使用任意一个局域网下的主机ping不同局域网下的主机：</p>
<p><code>192.168.11.11</code> ping <code>192.168.13.12</code> 和 <code>192.168.12.12</code>:</p>
<p><img data-src="tracert1.jpg" alt="tracert测试1"></p>
<p><code>192.168.12.11</code> ping <code>192.168.11.12</code> 和 <code>192.168.13.13</code>:</p>
<p><img data-src="tracert2.jpg" alt="tracert测试2"></p>
<p><code>192.168.13.11</code> ping <code>192.168.11.11</code> 和 <code>192.168.12.11</code>：</p>
<p><img data-src="tracert3.jpg" alt="tracert测试3"></p>
<p>由以上测试可以看出简单的路由器连接实验成功。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>路由器</tag>
      </tags>
  </entry>
  <entry>
    <title>PPP 点对点通信验证</title>
    <url>/posts/28ff89ad/</url>
    <content><![CDATA[<p><img data-src="/images/ppp通信验证/structure.png" alt=""></p>
<p>使用Cisco Packet Tracer7 (思科网络模拟器)验证ppp点对点通信。</p>
<span id="more"></span>
<h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>使用<code>packet Tracer</code> 模拟两台路由器，进行点对点通信测试。</p>
<h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><h4 id="配置路由器"><a href="#配置路由器" class="headerlink" title="配置路由器"></a>配置路由器</h4><p>由于只需要验证点对点通信，对路由器的配置，相对比较简单，<br>路由器之间使用的是serial DCE 串口线相连。</p>
<p>配置Router1的<code>serial 2/0</code>串口为ip: <code>11.0.0.1</code> mask: <code>255.0.0.0</code>,并配置时钟频率为<code>64000</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router&gt; enable</span><br><span class="line">Router# configure terminal</span><br><span class="line">Router(config) # hostname RA</span><br><span class="line">RA (config) # interface serial 2/0</span><br><span class="line">RA (config) # no shutdown</span><br><span class="line">RA (config-if) # ip address 11.0.0.1 255.0.0.0</span><br><span class="line">RA (config-if) # clock rate 64000</span><br></pre></td></tr></table></figure>
<p>配置Router2的<code>serial 3/0</code> 串口为ip: <code>11.0.0.2</code> mask： <code>255.0.0.0</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router&gt; enable</span><br><span class="line">Router# configure terminal</span><br><span class="line">Router(config) # hostname RB</span><br><span class="line">RB (config) # interface serial 3/0</span><br><span class="line">RB (config) # no shutdown</span><br><span class="line">RB (config-if) # ip address 11.0.0.2 255.0.0.0</span><br></pre></td></tr></table></figure>
<ul>
<li>查看两个路由的串口状态：</li>
</ul>
<p><code>RA</code>:</p>
<p><img data-src="hdsl_rt1.png" alt="RA serial 2/0"></p>
<p><code>RB</code>:</p>
<p><img data-src="hdsl_rt2.png" alt="RB serial 3/0"></p>
<p>可以看到，路由器这里点对点通信默认使用的<code>HDLC</code>(High Level Data Link Control, 面向比特的同步协议)协议。</p>
<h4 id="HDLC情况下验证ping："><a href="#HDLC情况下验证ping：" class="headerlink" title="HDLC情况下验证ping："></a>HDLC情况下验证ping：</h4><p><code>11.0.0.1</code> ping <code>11.0.0.2</code>:</p>
<p><img data-src="hdlc_ping_rt1.png" alt="RA ping Test"></p>
<p><code>11.0.0.2</code> ping <code>11.0.0.1</code>:</p>
<p><img data-src="hdlc_ping_rt2.png" alt="RB ping Test"></p>
<p>ping 测试成功。</p>
<h4 id="配置RA-RB使用ppp协议，再做ping测试："><a href="#配置RA-RB使用ppp协议，再做ping测试：" class="headerlink" title="配置RA,RB使用ppp协议，再做ping测试："></a>配置RA,RB使用ppp协议，再做ping测试：</h4><ul>
<li>先配置<code>RA</code> 使用 <code>ppp</code>协议：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RA # configure terminal</span><br><span class="line">RA (config) # interface serial 2/0</span><br><span class="line">RA (config-if) # encapsulation ppp</span><br></pre></td></tr></table></figure>
<p><img data-src="RA_ppp_setting.png" alt="RA serial 2/0"></p>
<p>可以看到<code>RA</code>当前使用的是<code>ppp</code>写协议，<code>LCP</code>处于<code>Closed</code>,此时，路由器应当无法进行点对点通信。</p>
<p><img data-src="RA_ppp_fTest.png" alt="ping Test"></p>
<ul>
<li>配置<code>RB</code>使用<code>ppp</code>协议：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RB # configure terminal</span><br><span class="line">RB (config) # interface serial 3/0</span><br><span class="line">RB (config-if) # encapsulation ppp</span><br></pre></td></tr></table></figure>
<p><img data-src="RB_ppp_setting.png" alt="RB serial 3/0"></p>
<p>这时，可以看到<code>RB</code>也是使用了<code>ppp</code>协议，且<code>LCP</code>也处于<code>Open</code>状态，路由器之间可以进行通信。</p>
<p><img data-src="RB_ppp_sTest.png" alt="ping Test"></p>
<h4 id="给ppp协议添加authentication鉴别"><a href="#给ppp协议添加authentication鉴别" class="headerlink" title="给ppp协议添加authentication鉴别"></a>给ppp协议添加authentication鉴别</h4><ul>
<li>先配置<code>RA</code>，使其开启<code>ppp chap</code> (Challenge Handshake Authentication Protocol), 给<code>RB</code> 添加身份验证</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RA # config terminal</span><br><span class="line">RA (config) # username RB password password</span><br><span class="line">RA (config) # interface serial 2/0</span><br><span class="line">RA (config-if) # ppp authentication chap</span><br></pre></td></tr></table></figure>
<p><img data-src="RA_ppp_au.png" alt="RA serial 2/0"></p>
<p>此时，虽然<code>RA</code>和<code>RB</code>都是使用<code>ppp</code>协议，但是<code>RA</code>给<code>RB</code>添加了身份认证，而<code>RB</code>则没有，此时<code>LCP</code>处于<code>Closed</code>状态，它们之间无法进行通信。</p>
<ul>
<li>配置<code>RB</code>, 添加对<code>RA</code>的身份验证：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RB # config terminal</span><br><span class="line">RB (config) # username RA password password</span><br><span class="line">RB (config) # interface serial 2/0</span><br><span class="line">RB (config-if) # ppp authentication chap</span><br></pre></td></tr></table></figure>
<p><img data-src="RB_ppp_au.png" alt="RB serial 3/0"></p>
<p>可以看到此时，<code>LCP</code>已经打开，路由器之间可以进行点对点通信。</p>
<p><img data-src="RB_ping_final.png" alt="ping"></p>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p>通过该实验，简单地验证了<code>ppp</code>协议在点对点信道中的使用。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>ppp通信</tag>
      </tags>
  </entry>
  <entry>
    <title>编译自己的Vim8.1</title>
    <url>/posts/97c4fd12/</url>
    <content><![CDATA[<p>最近换了<code>Manjaro</code> linux系统，发现通过系统<code>pacman -S vim</code>安装的无图形版本<code>vim</code>不支持<code>clipboard</code>功能。</p>
<p><img data-src="/images/linux/vim-version-original.jpg" alt=""></p>
<p>本想看能不能通过某种方式，来扩展现有安装好的<code>vim</code>,但是通过<code>google</code>了解到：<br><blockquote class="blockquote-center">
<p>VIM is intended to be a portable editor that “just works” on all systems. By having the default version use the clipboard functionality, it will need to link against X11 libraries, and a separate version of VIM would need to be compiled for desktop versus server (no pre-installed X11/xorg) builds. This is why the vim and vim-gtk packages are provided.</p>
<p>VIM旨在成为一个可在所有系统上“正常工作”的便携式编辑器。通过使默认版本使用剪贴板功能，它将需要链接到X11库，并且需要针对桌面与服务器（没有预安装的X11 / xorg）构建编译单独版本的VIM。这就是提供vim和vim-gtk软件包的原因。</p>

</blockquote></p>
<span id="more"></span>
<p>虽然知道<code>gvim</code>带有支持<code>clipboard</code>的<code>vim</code>，但是我又不想装<code>gvim</code>。自己的系统又有<code>X11</code>库和 <code>Xorg</code>，所以决定自己编译一个<code>vim</code>.</p>
<div class="note warning"><p><strong>注意</strong>： 对于没有<code>X11</code>和<code>Xorg</code>的需要在编译前配置好，否则编译会出错.</p>
</div>
<h3 id="一、从github上获取vim的源码"><a href="#一、从github上获取vim的源码" class="headerlink" title="一、从github上获取vim的源码"></a>一、从github上获取vim的源码</h3><p>直接使用<code>git</code> clone <code>vim</code>仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/vim/vim.git vim_source</span><br></pre></td></tr></table></figure>
<h3 id="二、配置、编译并安装"><a href="#二、配置、编译并安装" class="headerlink" title="二、配置、编译并安装"></a>二、配置、编译并安装</h3><p>我的编译配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make clean</span><br><span class="line">./configure \</span><br><span class="line">    --enable-cscope \ </span><br><span class="line">    --enable-largefile \ </span><br><span class="line">    --enable-multibyte \ </span><br><span class="line">    --enable-mzschemeinterp \ </span><br><span class="line">    --enable-xim \ </span><br><span class="line">    --enable-tclinterp=dynamic \ </span><br><span class="line">    --enable-perlinterp=dynamic \ </span><br><span class="line">    --enable-python3interp=dynamic\ </span><br><span class="line">    --enable-pythoninterp=dynamic \ </span><br><span class="line">    --enable-rubyinterp=dynamic \ </span><br><span class="line">    --enable-luainterp=dynamic \</span><br><span class="line">    --enable-gui=no \</span><br><span class="line">    --enable-fontset \</span><br><span class="line">    --enable-terminal \</span><br><span class="line">    --with-features=huge \</span><br><span class="line">    --with-x \</span><br><span class="line">    --with-compiledby=&quot;rovo98&quot; \</span><br><span class="line">    --with-python-config-dir=/usr/lib/python2.7/config-$(uname-m)-linux-gnu</span><br><span class="line">    --with-python3-config-dir=/usr/lib/python3.7/config-$(uname -m)-linux-gnu</span><br></pre></td></tr></table></figure>
<p>编译并安装:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure>
<p><strong>编译配置的说明</strong>:</p>
<p>上面的参数中启用了对tcl、perl、python、ruby、lua的支持。同时为了使用系统的剪切板还启用了对X的支持， 安装位置默认是<code>/usr/local</code>下， 由<code>--perfix=PREFIX</code>参数指定。</p>
<p>更多详细可以使用<code>./configure --help</code>查看:</p>
<p><strong>删除编译产生的中间文件</strong> :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make clean &amp;&amp; make distclean</span><br></pre></td></tr></table></figure>
<p><strong>成果:</strong></p>
<p><img data-src="vim_installed.jpg" alt=""></p>
<p><strong>为<code>vim</code>创建一个桌面图标</strong>:</p>
<p><code>vim.desktop</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Name=Vim[compiled by rovo98]</span><br><span class="line">Version=8.1</span><br><span class="line">Exec=vim %f</span><br><span class="line">Comment=Vim is a highly configurable text editor for efficiently creating and changing any kind of text.</span><br><span class="line">Icon=/usr/share/vim/vim81/src/vim.ico</span><br><span class="line">Type=Application</span><br><span class="line">MimeType=text/plain;</span><br><span class="line">Terminal=true</span><br><span class="line">Encoding=UTF-8</span><br><span class="line">Categories=Utility;</span><br></pre></td></tr></table></figure>
<p>把<code>vim.desktop</code>放到<code>/usr/share/applications/</code>下就行了。</p>
<p>现在可以享受你自己编译的vim了。</p>
<div class="note primary"><p>参考链接: </p>
<ul>
<li><a href="https://vi.stackexchange.com/questions/13564/why-is-vim-for-debian-compiled-without-clipboard">https://vi.stackexchange.com/questions/13564/why-is-vim-for-debian-compiled-without-clipboard</a></li>
<li><a href="https://stackoverflow.com/questions/11416069/compile-vim-with-clipboard-and-xterm">https://stackoverflow.com/questions/11416069/compile-vim-with-clipboard-and-xterm</a></li>
</ul>
</div>
]]></content>
      <categories>
        <category>Linux</category>
        <category>softwares</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>GPG入门使用</title>
    <url>/posts/7ea77913/</url>
    <content><![CDATA[<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><blockquote>
<p>gpg  is the OpenPGP part of the GNU Privacy Guard (GnuPG). It is a tool to provide digital encryption and signing services using the OpenPGP standard.<br>gpg features: complete key management and all the bells and whistles you would expect from a full OpenPGP implementation.</p>
</blockquote>
<div class="note info"><p><code>GnuPG</code>(GPG) 是 基于<code>OpenPGP</code>(由 <a href="https://www.ietf.org/rfc/rfc4880.txt">RFC4880</a> 定义,也被称为<code>PGP</code>)的一个完整的和免费的实现.我们可以使用<code>GPG</code>来对我们的数据和通信进行加密（encrypt）和签名（sign）, 它具有通用的密钥管理系统，以及各种公钥目录的访问模块. 我们可以很容易地使用<code>GPG</code>提供的命令行工具(当前它还提供不同平台下的图形界面工具<em>frontends</em>,以及库文件<em>libraries</em>)与其他的应用进行结合.同时还对<code>S/MIME</code>和<code>SSH(Security Shell)</code>提供支持.</p>
</div>
<span id="more"></span>
<p>本文使用环境为 Linux 命令行，掌握命令行，Window （<code>Gpg4win</code>）等<a href="https://www.gnupg.org/download/index.html">其他客户端</a>也很容易掌握。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>GPG</code>有两种安装方式。可以<a href="https://www.gnupg.org/download/index.html">下载源码</a>, 自己编译安装:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>更方便的方式是直接安装编译好的二进制包:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Arch 环境</span><br><span class="line">sudo pacman -S gnupg</span><br><span class="line"></span><br><span class="line"># Debian / Ubuntu 环境</span><br><span class="line">sudo apt-get install gnupg</span><br><span class="line"></span><br><span class="line"># Fedora 环境</span><br><span class="line">yum install gnupg</span><br></pre></td></tr></table></figure>
<p>安装完成后，键入下面的命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpg --help</span><br></pre></td></tr></table></figure>
<p>如果屏幕显示 GPG 的帮助信息，就表示安装成功。<br><img data-src="gpg-help.jpg" alt=""></p>
<h3 id="密钥管理"><a href="#密钥管理" class="headerlink" title="密钥管理"></a>密钥管理</h3><p>在使用<code>GPG</code>进行加密和签名之前，我们应该清楚的知道，它还是一个优秀的密钥管理工具（key Manager）.</p>
<p>可以使用<code>gpg --list-keys</code>查看当前管理的所有密钥.</p>
<h4 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h4><p>使用<code>gpg --gen-key</code>或<code>gpg --full-gen-key</code>(设置完整的参数配置来生成密钥对)</p>
<p>以完整的生成密钥对为例,<code>gpg --full-gen-key</code></p>
<p>(1).选择加密的算法(默认<code>RSA</code>):<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpg (GnuPG) 2.2.11; Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line"></span><br><span class="line">Please select what kind of key you want:</span><br><span class="line">   (1) RSA and RSA (default)</span><br><span class="line">   (2) DSA and Elgamal</span><br><span class="line">   (3) DSA (sign only)</span><br><span class="line">   (4) RSA (sign only)</span><br><span class="line">Your selection? </span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>(2).选择密钥的大小(默认 2048 位):</p>
<div class="note warning"><p>密钥的位数越大，对于防范暴力破解攻击就越安全,但是对于各种用途，使用默认的大小已经足够了，因为绕过加密比试图破解代价反而更少一些。此外，随着密钥大小的增加，加密和解密将变慢，较大的密钥位数可能会影响签名的长度。</p>
</div>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RSA keys may be between 1024 and 4096 bits long.</span><br><span class="line">What keysize do you want? (2048) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(3). 配置密钥的失效时间(默认 0, 永不失效)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Please specify how long the key should be valid.</span><br><span class="line">         0 = key does not expire</span><br><span class="line">      &lt;n&gt;  = key expires in n days</span><br><span class="line">      &lt;n&gt;w = key expires in n weeks</span><br><span class="line">      &lt;n&gt;m = key expires in n months</span><br><span class="line">      &lt;n&gt;y = key expires in n years</span><br><span class="line">Key is valid for? (0) </span><br><span class="line">Key does not expire at all</span><br><span class="line">Is this correct? (y/N) y</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(4). 配置用户信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GnuPG needs to construct a user ID to identify your key.</span><br><span class="line"></span><br><span class="line">Real name: alice</span><br><span class="line">Email address: alice@gmail.com</span><br><span class="line">Comment: A Test case</span><br><span class="line">You selected this USER-ID:</span><br><span class="line">    &quot;alice (A Test case) &lt;alice@gmail.com&gt;&quot;</span><br><span class="line"></span><br><span class="line">Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? </span><br><span class="line"></span><br><span class="line"># 最后确认信息，若需要修改可进行更新，按O确认 </span><br></pre></td></tr></table></figure>
<p>(5). 最后输入加密密码，完成密钥对的生成</p>
<p><img data-src="gpg-passphrase.png" alt=""></p>
<p>查看当前的所有密钥对:</p>
<p><img data-src="gpg-list-keys.jpg" alt=""></p>
<h4 id="密钥的导出和导入"><a href="#密钥的导出和导入" class="headerlink" title="密钥的导出和导入"></a>密钥的导出和导入</h4><p>导入公钥/私钥:</p>
<p>公钥和私钥的导入都是使用一样的命令<code>gpg --import</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#导入公钥</span><br><span class="line">gpg --import rovo98.pub</span><br><span class="line"># 导入私钥</span><br><span class="line">gpg --import rovo98.pri</span><br></pre></td></tr></table></figure>
<p>导入公钥之后，应进行验证。<code>GnuPG</code>提供了功能强大的信任模型，不需要我们亲自验证导入的每一个公钥。但是一些公钥还是需要亲自进行验证的，下面简单了解一下如何对导入的公钥进行验证。</p>
<div class="note danger"><p>通过验证公钥的指纹，然后签名（Sign）公钥以将其证明为有效公钥来验证密钥。可以使用<code>--fingerprint</code>命令行选项快速查看公钥的指纹，但为了验证公钥，必须对其进行编辑。</p>
</div>
<p>编辑公钥示例:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gpg --edit-key blake@cyb.org</span><br><span class="line"></span><br><span class="line">pub  1024D/9E98BC16  created: 1999-06-04 expires: never      trust: -/q</span><br><span class="line">sub  1024g/5C8CBD41  created: 1999-06-04 expires: never     </span><br><span class="line">(1)  Blake (Executioner) &lt;blake@cyb.org&gt;</span><br><span class="line"></span><br><span class="line">Command&gt; fpr</span><br><span class="line">pub  1024D/9E98BC16 1999-06-04 Blake (Executioner) &lt;blake@cyb.org&gt;</span><br><span class="line">             Fingerprint: 268F 448F CCD7 AF34 183E  52D8 9BDE 1A08 9E98 BC16</span><br></pre></td></tr></table></figure>
<blockquote>
<p>公钥的指纹验证需要通过公钥的所有者进行验证。可以通过电话或任何其他方式亲自完成，只要能够和公钥的真正所有者进行联系就行。<br><strong>如果获得指纹与公钥所有者的指纹相同，才可以确定我们得到是正确的公钥副本</strong></p>
</blockquote>
<p>检查指纹之后，最后进行公钥的签名（Sign）完成验证。由于公钥签名是公钥加密中的一个弱点，因此在进行签名验证之前，必须确保指纹验证是正确的。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Command&gt;&gt; sign</span><br><span class="line">             </span><br><span class="line">pub  1024D/9E98BC16  created: 1999-06-04 expires: never      trust: -/q</span><br><span class="line">             Fingerprint: 268F 448F CCD7 AF34 183E  52D8 9BDE 1A08 9E98 BC16</span><br><span class="line"></span><br><span class="line">     Blake (Executioner) &lt;blake@cyb.org&gt;</span><br><span class="line"></span><br><span class="line">Are you really sure that you want to sign this key</span><br><span class="line">with your key: <span class="string">&quot;Alice (Judge) &lt;alice@cyb.org&gt;&quot;</span></span><br><span class="line"></span><br><span class="line">Really sign?</span><br></pre></td></tr></table></figure>
<blockquote>
<p>签名之后，可以检查公钥，以列出其上面的签名，并查看我们添加的签名。公钥上的每个用户 ID 都可以具有一个或多个自签名以及已经通过公钥验证的签名。</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Command&gt; check</span><br><span class="line">uid  Blake (Executioner) &lt;blake@cyb.org&gt;</span><br><span class="line">sig!       9E98BC16 1999-06-04   [self-signature]</span><br><span class="line">sig!       BB7576AC 1999-06-04   Alice (Judge) &lt;alice@cyb.org&gt;</span><br></pre></td></tr></table></figure>
<p><strong>导出公钥(Public key)</strong></p>
<p>要将公钥发送给对应的用户之前，我们需要将密钥对的公钥导出，在<code>GPG</code>中使用<code>gpg --export</code>命令导出</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gpg --output alice.gpg --<span class="built_in">export</span> alice@gmail.com</span><br></pre></td></tr></table></figure>
<p>默认导出的文件是以<strong>二进制格式</strong>保存的，非常不方便进行传输，因此<code>GPG</code>还提供了<code>--armor</code>参数来指定以<code>ASCII</code>码形式导出。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gpg --armor --output alice.gpg --<span class="built_in">export</span> alice@gmail.com</span><br></pre></td></tr></table></figure>
<p><img data-src="gpg-export-pub-key.jpg" alt=""></p>
<p><strong>导出私钥（Private key）</strong>:</p>
<p><code>GPG</code>还支持导出私钥，不过是对所有的私钥进行导出，同样可以二进制格式或<code>ASCII</code>格式导出.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gpg --export-secret-keys --armor</span><br></pre></td></tr></table></figure>
<h4 id="上传公钥"><a href="#上传公钥" class="headerlink" title="上传公钥"></a>上传公钥</h4><p>公钥服务器是网络上专门储存用户公钥的服务器。<code>send-keys</code>参数可以将公钥上传到服务器。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gpg --send-keys [用户ID] --keyserver [服务器域名]</span><br></pre></td></tr></table></figure>
<p>使用上面的命令，你的公钥就被传到了服务器，然后通过交换机制，所有的公钥服务器最终都会包含你的公钥。</p>
<p>由于公钥服务器没有检查机制，任何人都可以用你的名义上传公钥，所以没有办法保证服务器上的公钥的可靠性。通常，你可以在网站上公布一个公钥指纹，让其他人核对下载到的公钥是否为真。<code>fingerprint</code>参数生成公钥指纹。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gpg --fingerprint [用户ID]</span><br></pre></td></tr></table></figure>
<p>从公钥服务器上获取公钥:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gpg --receive-keys</span><br></pre></td></tr></table></figure>
<p>获取到的公钥需要进行验证,参考上面提到的导入公钥的验证方式。</p>
<h3 id="加密和解密文件"><a href="#加密和解密文件" class="headerlink" title="加密和解密文件"></a>加密和解密文件</h3><p>在加密和解密文件时，公钥和私钥各自具有特定的作用。</p>
<blockquote>
<p>公钥可以被认为是开放式保险箱。当通过公钥加密文件时，该文件被放入保险箱，安全关闭，并且组合锁经过多次旋转和组合。<br>相对应的私钥是可以重新打开保险箱并检索文件的组合(组合锁组合)。换句话说，之后持有私钥的人才能恢复和使用相关公钥加密文件。</p>
</blockquote>
<div class="note info"><p>因此加解密过程应该是这样的，假设你要给<code>alice</code>发送加密信息，使用<code>alice</code>的公钥对信息进行加密，则<code>alice</code>可以使用她的私钥对加密信息进行解密，而当她向你发送加密信息，加密信息时使用的应该是你的公钥。</p>
</div>
<p>加密例子: 使用<code>alice</code>的公钥对<code>sourceListforKali</code>进行加密</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gpg --output sourceListforKali.en --encrypt sourceListforKali --recipient alice@gmail.com</span><br></pre></td></tr></table></figure>
<p><code>--recipient</code>指定使用的公钥</p>
<p>解密:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gpg --output sourceListforKali.de --decrypt sourceListforKali.en</span><br></pre></td></tr></table></figure>
<p>输入之前创建该密钥对的密码就可以对文件进行解密。</p>
<p><img data-src="gpg-encrypt-decrypt.jpg" alt=""></p>
<div class="note warning"><p>我们还可以在不使用公钥的情况下，对文件进行加密，使用的是对称密码（symmetric chiper）。使用<code>--symmetric</code>参数即可</p>
<p>手动输入加密密码即可。</p>
</div>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gpg --output sourceListforKali.gpg --symmetric sourceListforKali</span><br></pre></td></tr></table></figure>
<h3 id="签名-signatures"><a href="#签名-signatures" class="headerlink" title="签名(signatures)"></a>签名(signatures)</h3><p>数字签名证明文档并为其加上时间戳。如果随后以任何方式修改了文档，则签名验证将失败。数字签名可以起到与手写签名相同的作用，并具有防篡改的额外好处。</p>
<p>例如：当你将文件签名并发布后，则接受到该文件的用户可以验证签名来查看文件是否被修改过。</p>
<h4 id="创建和验证签名"><a href="#创建和验证签名" class="headerlink" title="创建和验证签名"></a>创建和验证签名</h4><p>创建和验证签名使用公/私钥对的方式不同于加解密操作。使用签名者的私钥创建签名，使用相应的公钥验证签名。</p>
<p>使用数字签名的好处是一般情况下，签名人是确定的，除非签名者的私钥被泄露了。</p>
<p>使用<code>--sign</code>参数创建数字签名，例:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gpg --output doc.sig --sign doc</span><br><span class="line">You need a passphrase to unlock the private key <span class="keyword">for</span></span><br><span class="line">user: <span class="string">&quot;Alice (Judge) &lt;alice@cyb.org&gt;&quot;</span></span><br><span class="line">1024-bit DSA key, ID BB7576AC, created 1999-06-04</span><br><span class="line"></span><br><span class="line">Enter passphrase: </span><br></pre></td></tr></table></figure>
<p>签名的文件在签名之前会被进行压缩处理，并输出一个二进制格式的签名文件。根据给定的签名文件，可以检查签名或检查签名并恢复原始文件。</p>
<p>检查和验证签名使用<code>--verify</code>参数选项,验证签名并恢复原始文件使用<code>--decrypt</code>选项:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gpg --output doc --decrypt doc.sig</span><br><span class="line">gpg: Signature made Fri Jun  4 12:02:38 1999 CDT using DSA key ID BB7576AC</span><br><span class="line">gpg: Good signature from <span class="string">&quot;Alice (Judge) &lt;alice@cyb.org&gt;&quot;</span></span><br></pre></td></tr></table></figure>
<div class="note danger"><p>一般情况下，数字签名多数应用于对互联网上的帖子 <em>post</em> 以及 <em>email</em> 进行签名。这种情况下，我们一般不希望对需要签名的文件进行压缩处理，因此可以使用<code>--clearsign</code>选项，在不修改文件的情况下，将文件以<code>ASCII</code>的形式包装在签名文件中。</p>
</div>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gpg --clearsign doc</span><br><span class="line"></span><br><span class="line">You need a passphrase to unlock the secret key <span class="keyword">for</span></span><br><span class="line">user: <span class="string">&quot;Alice (Judge) &lt;alice@cyb.org&gt;&quot;</span></span><br><span class="line">1024-bit DSA key, ID BB7576AC, created 1999-06-04</span><br><span class="line"></span><br><span class="line">-----BEGIN PGP SIGNED MESSAGE-----</span><br><span class="line">Hash: SHA1</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line">-----BEGIN PGP SIGNATURE-----</span><br><span class="line">Version: GnuPG v0.9.7 (GNU/Linux)</span><br><span class="line">Comment: For info see http://www.gnupg.org</span><br><span class="line"></span><br><span class="line">iEYEARECAAYFAjdYCQoACgkQJ9S6ULt1dqz6IwCfQ7wP6i/i8HhbcOSKF4ELyQB1</span><br><span class="line">oCoAoOuqpRqEzr4kOkQqHRLE/b8/Rw2k</span><br><span class="line">=y6kj</span><br><span class="line">-----END PGP SIGNATURE-----</span><br></pre></td></tr></table></figure>
<div class="note primary"><p>分离的、独立的签名文件（<em>Detached signatures</em>）: 一个签名过的文件的用途一般是很少的。</p>
<p>其他用户必须从签名文件中恢复原始文档，即使使用未压缩处理的签名文件（Clearsigned），也必须编辑签名文档以恢复原始文档。</p>
<p>因此，<code>GPG</code>还提供用于对文档创建分离签名第三种签名方法，该签名是单独的文件。使用<code>--detach-sig</code>选项创建分离签名。</p>
</div>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gpg --output doc.sig --detach-sig doc</span><br><span class="line"></span><br><span class="line">You need a passphrase to unlock the secret key <span class="keyword">for</span></span><br><span class="line">user: <span class="string">&quot;Alice (Judge) &lt;alice@cyb.org&gt;&quot;</span></span><br><span class="line">1024-bit DSA key, ID BB7576AC, created 1999-06-04</span><br><span class="line"></span><br><span class="line">Enter passphrase: </span><br></pre></td></tr></table></figure>
<p>通过此方法创建的签名，在验证时就需要同时使用签名和对应原文件:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gpg --verify doc.sig doc</span><br><span class="line"></span><br><span class="line">gpg: Signature made Fri Jun  4 12:38:46 1999 CDT using DSA key ID BB7576AC</span><br><span class="line">gpg: Good signature from <span class="string">&quot;Alice (Judge) &lt;alice@cyb.org&gt;&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>以上就是<code>GnuPG</code>的简单入门使用，更多的可以详细阅读<code>GnuPG</code>提供的<a href="https://www.gnupg.org/documentation/index.html">用户手册和文档</a>.</p>
<p>例如: 我们可以在加密文件的同时对文件进行签名(使用三种签名方法的其中一种)</p>
<div class="note primary"><p>参考链接:</p>
<ul>
<li><a href="https://www.gnupg.org/gph/en/manual.html">https://www.gnupg.org/gph/en/manual.html</a></li>
<li><a href="https://futureboy.us/pgp.html">https://futureboy.us/pgp.html</a></li>
</ul>
</div>
]]></content>
      <categories>
        <category>Linux</category>
        <category>softwares</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Arch linux系列 安装 haroopad markdown 编辑器</title>
    <url>/posts/63e58ebb/</url>
    <content><![CDATA[<blockquote>
<p>Haroopad 是一个优秀的 Markdown 编辑器，是一个用于创建适宜 Web 的文档的处理器。使用 Haroopad 可以创作各种格式的文档，比如博客文章、幻灯片、演示文稿、报告和电子邮件等。Haroopad 在 Windows、Mac OS X 和 Linux 上均可用。它有 Debian/Ubuntu 的软件包，也有 Windows 和 Mac 的二进制文件。该应用程序使用 node-webkit、CodeMirror，marked，以及 Twitter 的 Bootstrap 。</p>
<p>Haroo 在韩语中的意思是“一天”。</p>
</blockquote>
<p>本文主要介绍通过压缩包<code>**.tar.gz</code>的方式安装 <code>Haroopad</code>.</p>
<span id="more"></span>
<h3 id="一、下载-Haroopad"><a href="#一、下载-Haroopad" class="headerlink" title="一、下载 Haroopad"></a>一、下载 Haroopad</h3><p>我们可以从官网直接下载我们需要的压缩包，官网地址: <a href="http://pad.haroopress.com/user.html">Haroopad官网地址</a></p>
<p><img data-src="haroopad_website.png" alt=""></p>
<p>这里我选择的是linux binary 64 位的压缩包。</p>
<h3 id="二、解压并安装Haroopad"><a href="#二、解压并安装Haroopad" class="headerlink" title="二、解压并安装Haroopad"></a>二、解压并安装Haroopad</h3><p>根据下载的压缩包格式进行解压： 例如 **.tar.gz格式</p>
<p>解压并放到<code>/opt/</code>目录下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar zxvf haroopad-v0.13.1.x64.tar.gz -C haroopad</span><br><span class="line">sudo cp -r haroopad /opt/</span><br><span class="line"></span><br><span class="line">tar zxvf data.tar.gz</span><br><span class="line">tar zxvf control.tar.gz</span><br></pre></td></tr></table></figure>
<p>把解压出来的 usr中的文件放到<code>/usr/</code>下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cp -r ./usr /</span><br><span class="line"><span class="comment"># 执行 postinst</span></span><br><span class="line">chmod 755 postinst</span><br><span class="line">sudo ./postinst</span><br></pre></td></tr></table></figure>
<p><img data-src="haroopad_install.png" alt=""></p>
<h3 id="三、修复桌面图标"><a href="#三、修复桌面图标" class="headerlink" title="三、修复桌面图标"></a>三、修复桌面图标</h3><p>为haroopad 换一个合适的桌面图标:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /usr/share/applications/Haroopad.desktop</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Name=haroopad</span><br><span class="line">Version=0.13.1</span><br><span class="line">Exec=haroopad</span><br><span class="line">Comment=The Next Document processor based on Markdown</span><br><span class="line">#Icon=haroopad</span><br><span class="line">Icon=/usr/share/icons/hicolor/128x128/apps/haroopad.png</span><br><span class="line">Type=Application</span><br><span class="line">Terminal=false</span><br><span class="line">StartupNotify=true</span><br><span class="line">Encoding=UTF-8</span><br><span class="line">Categories=Development;GTK;GNOME;</span><br></pre></td></tr></table></figure>
<h3 id="四、配置Haroopad"><a href="#四、配置Haroopad" class="headerlink" title="四、配置Haroopad"></a>四、配置Haroopad</h3><p>相关的Haroopad设置，可以打开 <code>偏好设置</code>进行配置:</p>
<p><img data-src="haroopad_settings.png" alt=""></p>
<p>到此，Haroopad 安装就完成了。</p>
<p>参考链接: <a href="https://www.jianshu.com/p/dba9acabf0a7">https://www.jianshu.com/p/dba9acabf0a7</a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>softwares</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Manjaro linux 安装与配置</title>
    <url>/posts/a1898ce2/</url>
    <content><![CDATA[<p><img data-src="/images/linux/manjaro-installed.jpg" alt=""></p>
<blockquote>
<p>Manjaro是一款基于Arch Linux、对用户友好、全球排名第一的Linux发行版。（排名数据源于<a href="http://distrowatch.com/">DistroWatch</a>，统计日期2018.08.22，时间段3个月。）<br>在Linux圈，Arch的确是一个异常强大的发行版。它有3个无与伦比的优势：</p>
<ol>
<li>滚动更新可以使软件保持最新；</li>
<li>AUR软件仓库有着世界上最齐全的Linux软件（<a href="https://www.lulinux.com/archives/2787">参考《一张列表展示ArchLinux系软件有多丰富——看哭百万Debian、RedHat系同学》</a>）；</li>
<li>丰富的wiki和活跃的社区让所有问题都可以快速得到满意的答案。</li>
</ol>
</blockquote>
<p>相比于<code>Arch linux</code>, 不得感叹, <a href="http://www.manjaro.cn/451">人生苦短,我用 <strong>Manjaro</strong>啊!</a></p>
<span id="more"></span>
<h3 id="一、Manjaro的安装"><a href="#一、Manjaro的安装" class="headerlink" title="一、Manjaro的安装"></a>一、Manjaro的安装</h3><h4 id="镜像下载"><a href="#镜像下载" class="headerlink" title="镜像下载"></a>镜像下载</h4><p>官方网站：<a href="https://manjaro.org/get-manjaro/">https://manjaro.org/get-manjaro/</a><br>选择自己喜欢的桌面环境就好，目前官方支持包括xfce、kde、gnome三种桌面环境。而在官方的社区版本中提供更多桌面环境的支持，比如国产的deepin桌面环境</p>
<p>但是官方服务器在海外，所以我们也可以选择国内开源镜像进行下载<br>清华大学开源镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/manjaro-cd/">https://mirrors.tuna.tsinghua.edu.cn/manjaro-cd/</a></p>
<blockquote>
<p>由于我基本都把上述的版本和一些社区版本安装过(出于各种原因&gt;_&lt;)，我建议是从官方网站下载最新的官方版本进行安装(好像清华大学源的镜像并不是最新的)，至于桌面环境的选择，看个人，我选择的是<code>KDE</code>(其实，桌面环境在安装之后也是可以换的)。</p>
</blockquote>
<h4 id="制作U盘启动盘"><a href="#制作U盘启动盘" class="headerlink" title="制作U盘启动盘"></a>制作U盘启动盘</h4><p>manjaro官方提供的<a href="https://manjaro.github.io/homepage/public/support/userguide/">Manjaro User Guide</a>手册里面介绍了使用 来制作镜像的方法许多方法，例如：</p>
<ul>
<li>Linux系统下，使用 <code>dd</code>命令来制作：<br><code>sudo dd if=manjaro-xfce-17.1-stable-x86_64.iso of=/dev/sdc
bs=4M</code>, <code>of</code>指定烧录U盘的挂载位置;</li>
<li>在windows系统下使用烧录软件<code>Rufus</code>来进行烧录:<br> <img data-src="Rufus.png" alt=""></li>
</ul>
<p><strong>[注意]</strong>： 烧录完成后，在进入<code>Live</code>系统前，需要对<code>BIOS</code>进行一些设置，关闭安全启动。之后即可顺利进入这个界面(至于BIOS vs UEFI的启动进入的<code>Live</code>系统的方式，详见手册。由于我安装的是多个系统，所以是<code>GPT+UEFI</code>引导):</p>
<p><img data-src="manjaro-boot-menu.png" alt=""></p>
<h4 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h4><p>进入启动菜单界面后，可以对一些基本的选项进行配置，如，时区，语言，键盘布局等。</p>
<p>具体的安装步骤请直接参考官网的<code>Manjaro User Guide.pdf</code>,这里主要说说安装系统时可能遇到的问题(我基本踩过的坑…)。</p>
<ol>
<li><strong>对于双显卡的电脑,特别是有Nvidia卡的</strong>: 在进入<code>live</code>系统之前,可以将<code>Driver</code>选项设置为<code>no-free</code>(让系统自动安装合适的闭源驱动),并在<code>boot</code>项那里按<code>E</code>编辑, 在<code>boot</code>那一行将<code>nouveau.modeset=1</code>设置为<code>nouveau.modeset=0</code>来禁用开源<code>nouveau</code>驱动,然后进入<code>Live</code>安装系统。<br><strong>但是,安装完系统后重启还有可能进不去桌面</strong>,可以尝试在<code>Grub</code>菜单启动界面按[E]编辑,找到<code>quiet</code>并在后面加入(注意空格):<blockquote>
<p><code>acpi_osi=! acpi_osi=&#39;Windows 2009&#39;</code><br>或者<br><code>acpi_osi=! acpi_osi=Linux acpi_osi=&#39;Windows 2015&#39; pcie_port_pm=off</code><br><strong>(很多硬件厂商的BIOS驱动都对Linux不友好(我的电脑就是这样的…)，无法顺利加载ACPI模块，而导致无法驱动独立显卡,acpi_osi=’Windows 2009’的意思是告诉ACPI模块，我是‘Windows 7’，别闹情绪了，赶紧工作吧。)</strong><br>接着按 F10 进入系统。<br><br>顺利进入系统后,将这些内核启动参数配置永久生效(修改grub的配置文件):<br><code>sudo vim /etc/default/grub</code><br>在<code>GRUB_CMDLINE_LINUX</code>中添加参数:<br><img data-src="manjaro-grub.png" alt=""><br>之后更新 <code>grub</code>文件:<br><code>sudo update-grub</code><br>或<br><code>sudo grub-mkconfig -o /boot/grub/grub.cfg</code><br><img data-src="update-grub.png" alt=""><br>参考链接: </p>
<ol>
<li><a href="https://forum.manjaro.org/t/a-start-job-is-running-for-livemedia-mhwd-script/3395/15">https://forum.manjaro.org/t/a-start-job-is-running-for-livemedia-mhwd-script/3395/15</a></li>
<li><a href="https://wiki.archlinux.org/index.php/Kernel_parameters">https://wiki.archlinux.org/index.php/Kernel_parameters</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/admin-guide/kernel-parameters.txt">https://www.kernel.org/doc/Documentation/admin-guide/kernel-parameters.txt</a></li>
</ol>
</blockquote>
</li>
<li>启动时出现的<code>ACPI ERROR</code>问题，很多都说是内核版本的原因，有尝试过添加内核启动参数<code>acpi=off</code>，启动正常进入系统，但键盘无法使用，所以这个提示<code>ACPI</code>错误的问题，由于不影响使用，可以不管(强迫症的可以再看看)<blockquote>
<p><img data-src="boot-acpi-error.png" alt=""><br>参考链接: <a href="https://forum.manjaro.org/t/acpi-error-during-boot/35125">https://forum.manjaro.org/t/acpi-error-during-boot/35125</a></p>
</blockquote>
</li>
<li>屏幕亮度无法调节或异常的问题： <code>Arch Wiki</code>已经给出很详细的解决方法:<br>链接: <a href="https://wiki.archlinux.org/index.php/backlight">https://wiki.archlinux.org/index.php/backlight</a><br>例如：开机亮度设置: <code>vim /etc/rc.local</code>:<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh -e</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># rc.local</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This script is executed at the end of the each multiuser runlevel.</span></span><br><span class="line"><span class="comment"># Make sure that the script will &quot;exit 0&quot; on successs or any other value on error</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># In order to enable or disable this script just change the execution bits.</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># By default this script does nothing.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 127 &gt;&gt; /sys/class/backlight/intel_backlight/brightness</span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<div class="note primary"><p>对于安装<code>Manjaro</code>系统出现的问题，大多数都可以在官方的论坛<a href="https://forum.manjaro.org/">Manjaro Forum</a>以及<a href="https://wiki.manjaro.org/index.php?title=Main_Page">Manjaro Wiki</a>，还有<code>Arch Linux</code>的<a href="https://wiki.manjaro.org">Arch Wiki</a>以及上找到解决方法。</p>
</div>
<h3 id="二、Manjaro-配置"><a href="#二、Manjaro-配置" class="headerlink" title="二、Manjaro 配置"></a>二、Manjaro 配置</h3><p>简单说一下一些安装系统之后的一些常规配置。</p>
<h4 id="配置更新源并更新系统"><a href="#配置更新源并更新系统" class="headerlink" title="配置更新源并更新系统"></a>配置更新源并更新系统</h4><ol>
<li><p>配置中国的mirrors：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">sudo pacman-mirrors -i -c China -m rank</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>/etc/pacman.conf</code>中添加<code>archlinuxcn</code>源:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[archlinuxcn]</span><br><span class="line">SigLevel= TrustedOnly</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装<code>archlinuxcn-keyring</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pacman -S archlinuxcn-keyring</span><br></pre></td></tr></table></figure>
</li>
<li><p>同步并更新系统；</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">sudo pacman -Syyu</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="安装配置中文输入法"><a href="#安装配置中文输入法" class="headerlink" title="安装配置中文输入法"></a>安装配置中文输入法</h4><ol>
<li><p>安装中文输入法和<code>fcitx</code>管理工具:</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">sudo pacman -S fcitx-sougoupinyin <span class="comment"># 输入法看个人</span></span><br><span class="line">sudo pacman -S fcitx-im</span><br><span class="line">sudo pacman -S fcitx-configtool</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决中文输入法无法切换问题: 添加文件<code>~/.xprofile</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export GTK_MODULE=fcitx</span><br><span class="line">export QT_IM_MODULE=fcitx</span><br><span class="line">export XMODIFIERS=&quot;@im=fcitx&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>重启即可。</p>
<h4 id="配置Intel-和-Nvidia-双显卡切换"><a href="#配置Intel-和-Nvidia-双显卡切换" class="headerlink" title="配置Intel 和 Nvidia 双显卡切换"></a>配置Intel 和 Nvidia 双显卡切换</h4><p>Manjaro 提供了强大的硬件检测模块<code>mhwd</code>，可以很方便的安装各种驱动，要实现Intel 和 Nvidia 双显卡切换，我们需要安装video-hybrid-intel-nvidia-bumblebee <code>nvidia</code>闭源驱动和intel驱动的混合版<code>bumblebee</code>。对于之前安装系统是在<code>Live</code>启动菜单选择<code>Driver=no-free</code>的可以看看这个驱动是否已经安装：<br>系统设置中的硬件设置:<br><img data-src="manjaro-graphic-cards.png" alt=""><br>或<br><br><img data-src="manjaro-mhwd-installed-pci.png" alt=""></p>
<p>对于未安装的，这里提供一个最为简单的方式，<strong>直接在硬件设置中，右键安装即可，这样可以省去自己去添加用户组和开机启动，以及切换状态初始化</strong></p>
<div class="note warning"><p><strong>[注意：]</strong> 下面的这些依赖必须安装，否则会出现独立显卡无法正常工作的问题(fps跟集成显卡差不多)：</p>
</div>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">sudo pacman -S virtualgl lib32-virtualgl</span><br></pre></td></tr></table></figure>
<p>对于独立显卡的使用，可以使用<code>bbswitch</code>来进行切换开关，然后使用<code>optirun</code>来运行程序:</p>
<blockquote>
<ol>
<li>首先查看显卡的状态: <code>lspci | grep -i nvidia</code>(rev ff 表示关闭状态)<br><img data-src="nvidia-off.png" alt=""></li>
<li>打开独立显卡，并进行测试，对比集成显卡的fps：<ul>
<li>集成显卡 FPS:<br><img data-src="intel-fps.png" alt=""></li>
<li>打开独立显卡<code>sudo tee /proc/acpi/bbswitch &lt;&lt;&lt; &quot;ON&quot;</code>,测试FPS:<br><img data-src="nvidia-fps.png" alt=""></li>
</ul>
</li>
<li>独立显卡设置 nvidia-settings 需要用<code>optirun nvidia-setting -c :8</code>才能打开:<br><img data-src="nvidia-settings.png" alt=""></li>
</ol>
</blockquote>
<h4 id="使用-zsh-和-oh-my-zsh-配置终端"><a href="#使用-zsh-和-oh-my-zsh-配置终端" class="headerlink" title="使用 zsh 和 oh-my-zsh 配置终端"></a>使用 zsh 和 oh-my-zsh 配置终端</h4><p><code>zsh</code> shell(theme: rjkirch_mod)：</p>
<p><img data-src="my-zsh.png" alt=""></p>
<p>基本配置过程：</p>
<ul>
<li>查看系统安装了多少shell <code>cat /etc/shells</code></li>
<li>查看当前shell : <code>echo $SHELL</code></li>
<li>使用 <code>chsh</code>切换默认<code>shell</code>.</li>
</ul>
<p>配置 zsh，直接使用<strong>oh-my-zsh</strong>来进行配置: <a href="https://github.com/robbyrussell/oh-my-zsh">Oh-my-zsh</a>.<br>zsh 主题可以自行按个人喜好配置，当然也可以随机(每次打开终端都随机选择一个主题).</p>
<p>插件推荐: (插件配置太多的话，会使shell启动速度变慢，适当就好)</p>
<p><img data-src="zsh-plugins.png" alt=""></p>
<ul>
<li><a href="https://github.com/wting/autojump">Autojump</a></li>
<li><a href="https://github.com/zsh-users/zsh-syntax-highlighting">zsh-syntax-highlighting</a></li>
<li><a href="https://github.com/zsh-users/zsh-autosuggestions">zsh-autosuggestions</a></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Manjaro</code>的安装和基本配置就到此结束。最后，简单说一下我安装此系统的缘由。在安装<code>manjaro</code>之前，我使用的是<code>win10 LTSB 2016</code>，之前接触过的的Linux发行版是<code>CentOS</code>, <code>Unbuntu</code>以及 <code>kali</code>， 前两者我不怎么想要，本来想直接换成<code>kali</code>，但是考虑到<code>kali</code>一般是作为一个工具来使用，并不适合我平时开发和日常使用，就再次寻找适合的Linux发行版，最后看上了<code>Arch Linux</code>，但是又因为<code>Arch</code>上手难度较高，退而求其次，选择了<code>Manjaro</code>。当然啦，<code>Win10</code>肯定是要保留的，<code>Kali</code>也是要的。</p>
<p>于是乎，在原先的<code>GPT+UEFI</code>引导方式的基础之上，我重新分配了我的磁盘，将原有的<code>Win10</code>系统盘缩小，把它当备用系统，<code>Manjaro</code>作为主要系统使用，而<code>Kali</code>只作为工具使用，其他的磁盘分区作为数据存放的分区，各个系统共用。</p>
<p><img data-src="win-manjaro-kali.jpg" alt=""></p>
<p><img data-src="disk-structure.png" alt=""></p>
<div class="note danger"><p>说明: 对于上面给出的分区方案仅供参考，<strong>例如: 对于<code>Linux</code>的<code>swap</code>分区(用于虚拟内存的置换)来说，由于系统启动时会对<code>swap</code>进行初始化，因此多个系统可以使用一个<code>swap</code>分区即可。只要配置<code>UUID</code>没错就行了，毕竟多系统主机每次也只能启动一个系统。。。</strong></p>
<p>上面的分区旨在演示，基于<code>GPT</code> (<em>GUID Partion Table</em> 分区表(可以分128主要分区，而<code>MBR</code>(<em>Master Boot Record</em>)分区表只能是4个主要分区, 请自行了解两者的区别) 使用<code>UEFI</code>(<em>Unified Extensible Firmware Interface</em>)如何为安装多系统做准备。</p>
</div>
<p>然后使用 <code>REfind</code>来管理和引导系统:</p>
<p><img data-src="refind-menu.jpg" alt=""></p>
<div class="note primary"><p>对于Refind有兴趣的可以直接<code>google</code>或<code>baidu</code>了解一下，选择一个现有的主题然后自己稍微进行配置一下，就可以了。<br>参考:</p>
<ul>
<li><a href="http://www.rodsbooks.com/refind/">http://www.rodsbooks.com/refind/</a></li>
<li><a href="https://wiki.archlinux.org/index.php/REFInd_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87">Arch Wiki 上关于refind的内容</a>)</li>
</ul>
</div>
<h4 id="各个系统桌面"><a href="#各个系统桌面" class="headerlink" title="各个系统桌面"></a>各个系统桌面</h4><ul>
<li>Win10 LTSB</li>
</ul>
<p><img data-src="win10.jpg" alt=""></p>
<ul>
<li>Manjaro(DE: KDE)</li>
</ul>
<p><img data-src="manjaro-desktop.jpg" alt=""></p>
<ul>
<li>Kali</li>
</ul>
<p><img data-src="kali.jpg" alt=""></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>manjaro</tag>
      </tags>
  </entry>
  <entry>
    <title>fcitx5-rime 小鹤音形隐藏打字候选窗</title>
    <url>/posts/a0c2ec7f/</url>
    <content><![CDATA[<p> 对于使用小鹤音形的用户来说，除使用通配符、查看部件、小字这几种常用情况外，打字时的候选窗通常是没有必要的。对于 Android 和 Windows 系统，小鹤音形官网提供了他们的输入法软件，使用户在隐藏打字候选窗的情况下，当用户使用通配符或查看部件及字根时，候选窗则会自动显示出来。<br>  对于其他平台(Linux或Mac)的小鹤音形用户，一般是借助 rime 来实现小鹤音形的挂接，此时要隐藏候选窗便要 rime 及其相应的输入法框架提供支持。本文将以 <strong>fcitx5-rime</strong> 为例介绍如何快速地隐藏和开启打字候选窗。<br>  <span id="more"></span></p>
<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>  之前在「<a href="/posts/2f1de6fa/">fcitx5-rime 挂接小鹤音形</a> 」文中便有对fcitx5-rime 小鹤音形的使用进行过介绍，文末当时说了「不太好配置隐藏候选窗」，这倒是真的。在使用 fcitx5 之前，我用的是 fcitx(fcitx4)，我也不太记得 fcitx4-configtool 能否对打字候选窗进行配置了，唯一能确定的是，候选窗主题色是能配置的。在我使用小鹤音形一段时间后，特别是把 Windows 及 Android 系统下小鹤音形输入法配置成隐藏打字候选窗后，我便开始了把我笔记本 Manjaro 里的 rime 小鹤音形也隐藏候选窗的想法。然后在网上搜索了相关关键字后，发现有人居然是通过将候选窗背景等配色调透明来实现的，经过一番思索后，且不说方案在 Linux 下 fcitx5-rime 中能否可行，我觉得它并不适合我。即便不好做到如同小鹤音形官网提供的输入法那般，但也最好要做到能快速进行候选窗开关切换，因此便有了本文的方法🤔。</p>
<h2 id="2、fcitx5-隐藏候选窗实现思路"><a href="#2、fcitx5-隐藏候选窗实现思路" class="headerlink" title="2、fcitx5 隐藏候选窗实现思路"></a>2、fcitx5 隐藏候选窗实现思路</h2><p>  从 <code>fcitx5-configtool</code> 中，我们是可以配置插件的(Configure addons)，不难发现，UI 下的 <strong>Classic User Interface</strong> 便用于配置程序的用户界面的，如更改主题色等，当然也直接选择将该插件关闭或打开，从而实现输入法候选窗的开关。<br>  因此，我先是在 <code>fcitx5-configtool</code> 启用和禁用 <strong>Classic User Interface</strong> ，然后观察 fcitx5 的配置文件(位于 <code>./config/fcitx5</code>)变化情况，发现当禁用 <strong>Classic User Interface</strong> 插件时，<code>./config/fcitx5/config</code> 配置文件中增加了以下配置：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Behavior/DisabledAddons]</span><br><span class="line">0=classicui</span><br></pre></td></tr></table></figure><br>  那么该插件的名称便是 <code>classicui</code>，再根据 <code>fcitx5 --help</code>:<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Usage: fcitx5 [Option]</span><br><span class="line">  --disable &lt;addon names&gt;       A comma separated list of addons to be disabled.</span><br><span class="line">                                &quot;all&quot; can be used to disable all addons.</span><br><span class="line">  --enable &lt;addon names&gt;        A comma separated list of addons to be enabled.</span><br><span class="line">                                &quot;all&quot; can be used to enable all addons.</span><br><span class="line">                                This value will override the value in the flag --disable.</span><br><span class="line">  --verbose &lt;logging rule&gt;      Set the logging rule for displaying message.</span><br><span class="line">                                Syntax: category1=level1,category2=level2, ...</span><br><span class="line">                                E.g. default=4,key_trace=5</span><br><span class="line">                                Levels are numbers ranging from 0 to 5.</span><br><span class="line">                                        0 - NoLog</span><br><span class="line">                                        1 - Fatal</span><br><span class="line">                                        2 - Error</span><br><span class="line">                                        3 - Warn</span><br><span class="line">                                        4 - Info (default)</span><br><span class="line">                                        5 - Debug</span><br><span class="line">                                Some built-in categories are:</span><br><span class="line">                                        default - miscellaneous category used by fcitx own library.</span><br><span class="line">                                        key_trace - print the key event received by fcitx.</span><br><span class="line">                                        &quot;*&quot; may be used to represent all logging category.</span><br><span class="line">  -u, --ui &lt;addon name&gt;         Set the UI addon to be used.</span><br><span class="line">  -d                            Run as a daemon.</span><br><span class="line">  -D                            Do not run as a daemon (default).</span><br><span class="line">  -s &lt;seconds&gt;                  Number of seconds to wait before start.</span><br><span class="line">  -k, --keep                    Keep running even the main display is disconnected.</span><br><span class="line">  -r, --replace                 Replace the existing instance.</span><br><span class="line">  -v, --version                 Show version and quit.</span><br><span class="line">  -h, --help                    Show this help message and quit.</span><br></pre></td></tr></table></figure></p>
<p>因此，我们可以借助一个文本配置文件记录当前打字候选窗禁用状态(0未禁用/1已禁用)，结合 <code>fcitx5 --enable/--disable classicui -r</code> 来快速地启用或禁用打字候选窗。</p>
<h2 id="3、最后"><a href="#3、最后" class="headerlink" title="3、最后"></a>3、最后</h2><p>  基于以上思路，我简单地写了一个脚本，可至 「<a href="https://github.com/rovo98/fcitx5-classicui-switcher">fcitx5-classicui-switcher</a> 」进行安装及使用，更多定制化功能也可自行修改。采用我的实现方案，效果大致如下：<br><img data-src="fcitx5-hidden-typing-windows-demo.gif" alt=""></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title>fcitx5-rime 挂接小鹤音形</title>
    <url>/posts/2f1de6fa/</url>
    <content><![CDATA[<p>近几天，在看 Github explore 时意外看到了 <a href="https://github.com/hosxy/Fcitx5-Material-Color">fcitx5-material-color</a>，提供了更好看的主题色，并支持单行候选窗显示，于是决定将用了近一年的 fcitx 换成 fcitx5。<br><img data-src="/images/linux/fcitx5-material-colors.png" alt=""></p>
<p>顺便简单介绍一下我在 manjaro 上使用已近 2 年多的输入方案 - 小鹤音形。</p>
<span id="more"></span>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Fcitx 是一个可扩展的输入法框架，目前支持 Linux 及 Unix-like 的系统发行版。而 <a href="https://rime.im/">Rime</a> 中州韵是一个跨平台的输入法引擎，用户可自定义并设计输入方案。<br>fcitx-rime 则是为 Fcitx 提供了 rime 的支持，本人目前在 linux 平台下常用的是 fcitx-rime， 而在 windows 环境下，则使用「小狼豪」。</p>
<p><a href="https://github.com/fcitx/fcitx5">Fcitx5</a> 是 Fcitx 的新一代，相较于旧版 Fcitx4，有了不少性能提升，并提供了许多额外的功能支持。打字体验更流畅且界面更好看了。</p>
<h3 id="fcitx5-安装"><a href="#fcitx5-安装" class="headerlink" title="fcitx5 安装"></a>fcitx5 安装</h3><p>由于我使用的是 Manjaro linux，因此，以下安装介绍以 archlinux 的安装方式为例，其他应该也是类似。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo pacman -S fcitx5</span><br></pre></td></tr></table></figure>
<h3 id="使用-fcitx5-rime-挂接小鹤音形"><a href="#使用-fcitx5-rime-挂接小鹤音形" class="headerlink" title="使用 fcitx5-rime 挂接小鹤音形"></a>使用 fcitx5-rime 挂接小鹤音形</h3><p>首先，小鹤音形是在小鹤双拼的基础上，再引入了双形的规则，使得打字更精准化。更多关于小鹤音形的内容详见其官网介绍 - <a href="https://www.flypy.com/xing.html">双形</a>。</p>
<p>💬<strong>关于我选择学习和使用小鹤音形的契机：</strong></p>
<p>相信很多人刚接触中文打字时，自然而然地会选择使用全拼，在掌握基本的打字手法后，配合智能输入法的使用，便能很快上手，熟练一段时间后，得益于智能输入法的智能词库，有的人很快就拥有了较快的打字速度。</p>
<p>但对我来说，使用全拼打字有以下两大问题（痛点）：</p>
<ol>
<li><strong>击键次数过多，且容易出错</strong>；击键次数越多越容易出错，e.g. 声母+韵母最多可有 6 个字母；</li>
<li><strong>必然出现重码</strong>，遇到偏僻词可能需要从候选窗中翻非常久，还可能找不到。</li>
</ol>
<p>于是乎，经一番检索后，我发现了双拼输入方案，它们可以很好的解决问题第一个问题，其实很多智能输入法也早已有了切换双拼输入方案的配置，也存在着比较多的双拼方案可供选择和使用，如自然码、搜狗、微软、小鹤双拼等。但我们很快可以意识到使用双拼不能解决第二个问题。</p>
<p>我选择小鹤双拼方案的主要原因是为了后续能进一步使用双形，即在掌握小鹤双拼后，过渡去学习双形。而且小鹤音形的小字根规则还算简单，花个几分钟看一下规则，后续在练习和实践中慢慢掌握即可，如官网推荐的 500 单字练习等，另外也有相应的微信小程序可以让我们学习双形。熟练之后，打字时则完全可下意识快速地打出想要的字词。</p>
<h4 id="挂接文件"><a href="#挂接文件" class="headerlink" title="挂接文件"></a>挂接文件</h4><p>从小鹤音形官网上提供的网盘<a href="http://flypy.ys168.com/">下载</a>，在小鹤音形挂接第三方平台目录下，选择相应平台的挂接文件, e.g linux 平台可下载「小鹤音形”鼠须管”for macOS.zip」。 </p>
<p>压缩包下载完成后，进行解压，其中包含的文件清单如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── MAC鼠须管小鹤音形挂接说明.txt</span><br><span class="line">└── rime</span><br><span class="line">    ├── build</span><br><span class="line">    │   ├── flypydz.prism.bin</span><br><span class="line">    │   ├── flypydz.reverse.bin</span><br><span class="line">    │   ├── flypydz.table.bin</span><br><span class="line">    │   ├── flypyplus.prism.bin</span><br><span class="line">    │   ├── flypyplus.reverse.bin</span><br><span class="line">    │   ├── flypyplus.table.bin</span><br><span class="line">    │   ├── flypy.prism.bin</span><br><span class="line">    │   ├── flypy.reverse.bin</span><br><span class="line">    │   └── flypy.table.bin</span><br><span class="line">    ├── default.custom.yaml</span><br><span class="line">    ├── default.yaml</span><br><span class="line">    ├── flypyplus.schema.yaml</span><br><span class="line">    ├── flypy.schema.yaml</span><br><span class="line">    ├── flypy_sys.txt</span><br><span class="line">    ├── flypy_top.txt</span><br><span class="line">    ├── flypy_user.txt</span><br><span class="line">    ├── rime.lua</span><br><span class="line">    ├── squirrel.custom.yaml</span><br><span class="line">    └── squirrel.yaml</span><br></pre></td></tr></table></figure>
<p>使用这些官方提供的挂接文件，我们可很简单地参照<code>MAC鼠须管小鹤音形挂接说明.txt</code> 的部署说明，将 rime 目录中的所有文件复制到 <code>/usr/share/rime-data</code> 目录下，便能完成了 rime 挂接小鹤音形。</p>
<h3 id="配置-fcitx5"><a href="#配置-fcitx5" class="headerlink" title="配置 fcitx5"></a>配置 fcitx5</h3><p>完成小鹤音形挂接文件部署后，对 fcitx5 服务进行重启，然后打开配置，添加 rime 输入法。</p>
<p><img data-src="fcit5-add-rime-input-method.png" alt=""></p>
<p>完成配置后，便开始愉快地使用小鹤音形了😊。</p>
<h3 id="fcitx5-主题设置"><a href="#fcitx5-主题设置" class="headerlink" title="fcitx5 主题设置"></a>fcitx5 主题设置</h3><p>默认情况下，我们只能使用 fcitx5 内建主题，为使用其他主题配色，我们可从 github 等进行搜索，找寻 fcitx5 主题，并按照安装指引进行相应主题配置。例如，本文开头提到的 fcitx5-material-color 主题就挺不错的🙂。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>不知不觉我使用小鹤音形已经较长一段时间了，如今打字时已不早像最初刚接触音形规则时，打一些不熟悉的字可能需要短暂的停顿来思索要打的字该怎么打。在上手小鹤音形一段时间后，手指习惯打音形的节奏后，打字体验便得到了质的飞跃，现在反而不习惯使用全拼了，在没有音形方案时，也会退而求其次选择小鹤双拼方案。使用小鹤双拼方案至少还能解决我遇到的第一个中文输入问题——击键次数过多，容易出错。</p>
<p>下面的几个 gif 图主要展示了使用小鹤音形打字的基本情况:</p>
<p><img data-src="xhyx-input-method.gif" alt=""></p>
<p><img data-src="fcitx5-typing-testing-demo.gif" alt=""></p>
<p>在 windows 系统下，我会选择安装小鹤音形官方提供的输入法软件，能够完全隐藏打字时的候选窗，实现真正的盲打😁。<br>使用 fcitx5-rime 不太好配置隐藏打字的候选窗。另外，在手机系统我同样使用小鹤音形官方提供的安卓输入法应用。</p>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ol>
<li><a href="https://www.flypy.com/">https://www.flypy.com/</a></li>
<li><a href="https://github.com/hosxy/Fcitx5-Material-Color">https://github.com/hosxy/Fcitx5-Material-Color</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次linux系统迁移过程</title>
    <url>/posts/3babee60/</url>
    <content><![CDATA[<p>就在最近，终于为自己的电脑加装了固态。在装完固态之后，首先面临的问题就是如何将原先安装在机械硬盘上的<code>linux</code>系统迁移到固态上。还要考虑后续配置的问题。</p>
<p>本文主要讲述在迁移<code>Linux</code>系统到新的固态硬盘上所遇到的问题以及找到的相应的解决方法。</p>
<p>这里先给出系统迁移以及相关配置完成之后的机械硬盘和固态硬盘的简单测速对比:</p>
<p><img data-src="/images/linux/hdparam.jpg" alt=""></p>
<span id="more"></span>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><div class="note info"><p>拆开电脑，直接加装固态,顺便清清灰尘，换一下硅脂(ps: 这不知道是我第几次拆电脑了…,表示以后再也不买GPU风扇了，这已经是第二次失败的购买经历了(<code>除非得到与原来匹配的风扇一致的风扇，不然我是不再换了</code>).</p>
</div>
<p>清尘换硅脂:</p>
<p><img data-src="install_ssd01.jpg" alt="install-ssd-01"><br>加装固态和散热板:</p>
<p><img data-src="install_ssd02.jpg" alt="install-ssd-01"></p>
<div class="note primary"><p>关于固态如何购买挑选，需要很好的了解自己电脑能够支持的固态类型和市场所提供的固态类型，并综合各种因素才能做出最好的选择。这里我推荐几篇个人觉得不错的文章:</p>
<ul>
<li><a href="https://www.laptopmag.com/articles/laptop-ssd-guide">https://www.laptopmag.com/articles/laptop-ssd-guide</a></li>
<li><a href="https://www.tomshardware.com/reviews/ssd-buying-guide,5602.html">https://www.tomshardware.com/reviews/ssd-buying-guide,5602.html</a></li>
<li><a href="https://www.velocitymicro.com/blog/nvme-vs-m-2-vs-sata-whats-the-difference/">https://www.velocitymicro.com/blog/nvme-vs-m-2-vs-sata-whats-the-difference/</a></li>
<li><a href="https://blog.csdn.net/u010109732/article/details/79032845">https://blog.csdn.net/u010109732/article/details/79032845</a></li>
<li><a href="https://www.zhihu.com/question/48972075">https://www.zhihu.com/question/48972075</a></li>
<li><a href="https://www.pc841.com/article/20180914-92342_all.html">https://www.pc841.com/article/20180914-92342_all.html</a></li>
<li><a href="https://www.techadvisor.co.uk/test-centre/storage/best-ssd-2018-3235200/">https://www.techadvisor.co.uk/test-centre/storage/best-ssd-2018-3235200/</a></li>
</ul>
<p>以上推荐文章仅作为参考。</p>
</div>
<h3 id="迁移系统"><a href="#迁移系统" class="headerlink" title="迁移系统"></a>迁移系统</h3><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>进入原先的<code>linux</code>系统，对已经安装上的固态硬盘进行分区。因为我之前在没有固态之前，在机械硬盘上就已经安装了三个系统(<code>win10</code>, <code>manjaro</code>, <code>kali</code>),因此在分区时，我是考虑只把两个<code>linux</code>迁移到固态上，毕竟<code>win10</code>现在已经基本不使用了，并将机械硬盘上的<code>EFI</code>分区也迁移到固态上。分区这里，可以按照自己的需求对固态硬盘进行分区。</p>
<p>分区工具的选择，随意，哪个顺手用哪个，例如:<code>gparted</code>, <code>fdisk</code>, <code>parted</code>,还有各种桌面自带的分区工具。我是使用的是<code>fdisk</code>:<br>例如:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo fdisk /dev/nvme0n1</span><br></pre></td></tr></table></figure></p>
<p><img data-src="fdisk_parted.png" alt="diskparted"></p>
<p>这里我已经分好区了的，具体的操作在<code>fdisk</code>中进行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Generic</span><br><span class="line">   d   delete a partition</span><br><span class="line">   F   list free unpartitioned space</span><br><span class="line">   l   list known partition types</span><br><span class="line">   n   add a new partition</span><br><span class="line">   p   print the partition table</span><br><span class="line">   t   change a partition type</span><br><span class="line">   v   verify the partition table</span><br><span class="line">   i   print information about a partition</span><br><span class="line"></span><br><span class="line">  Misc</span><br><span class="line">   m   print this menu</span><br><span class="line">   x   extra functionality (experts only)</span><br><span class="line"></span><br><span class="line">  Script</span><br><span class="line">   I   load disk layout from sfdisk script file</span><br><span class="line">   O   dump disk layout to sfdisk script file</span><br><span class="line"></span><br><span class="line">  Save &amp; Exit</span><br><span class="line">   w   write table to disk and exit</span><br><span class="line">   q   quit without saving changes</span><br><span class="line"></span><br><span class="line">  Create a new label</span><br><span class="line">   g   create a new empty GPT partition table</span><br><span class="line">   G   create a new empty SGI (IRIX) partition table</span><br><span class="line">   o   create a new empty DOS partition table</span><br><span class="line">   s   create a new empty Sun partition table</span><br></pre></td></tr></table></figure>
<p>例如创建<code>EFI</code>分区:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Command (m for help): n</span><br><span class="line">Partition number (2-128, default 2): 2 # 创建一个分区作为EFI分区</span><br><span class="line">First sector (xxxxx-xxxxxxxxxxx, default xxxxx): </span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G,T,P&#125; (34-2047, default xxxxxxx): +200M</span><br><span class="line">Created a new partition 2 of type &#x27;Linux filesystem&#x27; and of size 200 Mb.</span><br><span class="line">Command (m for help): t  # 修改EFI分区的分区类型为EFI系统分区</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># 最后保存设置</span><br><span class="line">Command (m for help): w</span><br></pre></td></tr></table></figure>
<div class="note danger"><p>请注意先查看所执行的分区操作是不是你想要的再进行最后的保存设置</p>
</div>
<p>其他的分区创建类似<code>EFI</code>的创建，<code>swap</code>分区需要指定为<code>Linux swap</code>分区，作为<code>linux</code>数据分区的分区在创建时默认就是<code>linux filesystem</code>类型了，不需要更改，之后对创建的分区进行格式化:将<code>EFI</code>格式化为<code>fat32</code>，将<code>linux</code>数据分区格式化<code>ext4</code>； 先通过<code>sudo fdisk -l</code>或<code>lsblk</code>查看已经创建分区对应的设备名,例如:<br><code>sudo fdisk -l</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Disk /dev/nvme0n1: 238.5 GiB, 256060514304 bytes, 500118192 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: gpt</span><br><span class="line">Disk identifier: 6D071E80-FF82-420B-A2D8-7A0BC4759F06</span><br><span class="line"></span><br><span class="line">Device             Start       End   Sectors  Size Type</span><br><span class="line">/dev/nvme0n1p1        34    262177    262144  128M Microsoft reserved</span><br><span class="line">/dev/nvme0n1p2    264192    673791    409600  200M EFI System</span><br><span class="line">/dev/nvme0n1p3    673792   9062399   8388608    4G Linux swap</span><br><span class="line">/dev/nvme0n1p4   9062400 428492799 419430400  200G Linux filesystem</span><br><span class="line">/dev/nvme0n1p5 428492800 500117503  71624704 34.2G Linux filesystem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/sda: 931.5 GiB, 1000204886016 bytes, 1953525168 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 4096 bytes</span><br><span class="line">I/O size (minimum/optimal): 4096 bytes / 4096 bytes</span><br><span class="line">Disklabel type: gpt</span><br><span class="line">Disk identifier: D5CB68A7-96DA-4C61-84E2-61C98489BFF1</span><br><span class="line"></span><br><span class="line">Device          Start        End   Sectors   Size Type</span><br><span class="line">/dev/sda1          64  125829183 125829120    60G Microsoft basic data</span><br><span class="line">/dev/sda2   125829184  880802416 754973233   360G Microsoft basic data</span><br><span class="line">/dev/sda3   880803904 1596575151 715771248 341.3G Microsoft basic data</span><br><span class="line">/dev/sda4  1596575744 1953521663 356945920 170.2G Microsoft basic data</span><br></pre></td></tr></table></figure>
<p><code>lsblk</code> 查看分好的磁盘分区:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda           8:0    0 931.5G  0 disk </span><br><span class="line">├─sda1        8:1    0    60G  0 part /run/media/rovo98/System</span><br><span class="line">├─sda2        8:2    0   360G  0 part /run/media/rovo98/Mshinoda</span><br><span class="line">├─sda3        8:3    0 341.3G  0 part /run/media/rovo98/Chester bennington</span><br><span class="line">└─sda4        8:4    0 170.2G  0 part /run/media/rovo98/LSR</span><br><span class="line">sr0          11:0    1  1024M  0 rom  </span><br><span class="line">nvme0n1     259:0    0 238.5G  0 disk </span><br><span class="line">├─nvme0n1p1 259:1    0   128M  0 part </span><br><span class="line">├─nvme0n1p2 259:2    0   200M  0 part /boot/efi</span><br><span class="line">├─nvme0n1p3 259:3    0     4G  0 part [SWAP]</span><br><span class="line">├─nvme0n1p4 259:4    0   200G  0 part /</span><br><span class="line">└─nvme0n1p5 259:5    0  34.2G  0 part /run/media/rovo98/a002d542-c8c4-4c98-85af-8a4446dbaa1b</span><br></pre></td></tr></table></figure>
<p>对特定的分区进行格式化,例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 对于linux数据分区</span><br><span class="line">mkfs.ext4 /dev/nvme0n1p4</span><br><span class="line">mkfs.ext4 /dev/nvme0n1p5</span><br><span class="line"># EFI分区</span><br><span class="line">mkfs.fat /dev/nvme0n1p2</span><br></pre></td></tr></table></figure>
<div class="note danger"><p><strong>注意</strong>: 执行每条格式化命令前，必须确认指定的分区是否是你想要格式化的分区</p>
</div>
<p>做好这些准备之后，就可以进行系统的迁移了</p>
<h4 id="系统迁移操作"><a href="#系统迁移操作" class="headerlink" title="系统迁移操作"></a>系统迁移操作</h4><p>对于<code>Linux</code>系统，我们只需要知道<strong>Linux一切皆文件</strong>就行了。因此对于系统的迁移就变得简单了，可以使用<code>dd</code>,打包压缩然后解压缩，有关系统备份和恢复可以参看<code>Arch wiki</code>给出的:<a href="https://wiki.archlinux.org/index.php/System_backup">https://wiki.archlinux.org/index.php/System_backup</a>.这里我是使用的是<code>tar</code>结合<code>pigz</code>(<a href="http://www.ywnds.com/?p=10332">什么是pigz?</a>)解压缩工具进行备份和恢复:</p>
<p>备份(打包压缩)<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo tar --use-compress-program=pigz -cvpf /run/media/rovo98/Chester\ bennington/LP/GHOST/manjaro_backup_2018.10.7.tgz --exclude=/proc --exclude=/sys --exclude=/mnt --exclude=/run/media --exclude=/lost+found /</span><br></pre></td></tr></table></figure><br>恢复到目标硬盘分区上(解包解压缩):<br>先目标分区挂载到<code>/mnt</code>下，如:<code>/mnt/manjaro</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount /dev/nvme0n1p4 /mnt/manjaro</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo tar --use-compress-program=pigz -xvpf /run/media/rovo98/Chester\ bennington/LP/GHOST/manjaro_backup_2018.10.7.tgz -C /mnt/manjaro</span><br></pre></td></tr></table></figure>
<p>完成后需要手动创建，上面打包压缩是排除的文件夹:<code>/proc</code>, <code>/sys</code>, <code>/mnt</code>, <code>/run</code>, <code>/lost+found</code>.</p>
<div class="note primary"><p>详细备份和恢复过程可以参考查看:<a href="https://www.jianshu.com/p/b03a51c682a5">Arch上的备份还原</a></p>
</div>
<h4 id="修复Grub、fstab文件以及refind引导管理"><a href="#修复Grub、fstab文件以及refind引导管理" class="headerlink" title="修复Grub、fstab文件以及refind引导管理"></a>修复Grub、fstab文件以及refind引导管理</h4><p>首先将<code>/proc</code>,<code>/run</code>,<code>/dev</code>,<code>/sys</code>重新挂载，让目标分区上的系统也拥有这些内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount /proc /mnt/manjaro/proc</span><br><span class="line">mount /sys /mnt/manjaro/sys</span><br><span class="line">mount /run /mnt/manjaro/run</span><br><span class="line">mount /dev /mnt/manjaro/dev</span><br></pre></td></tr></table></figure>
<div class="note warning"><p>这些目录必须重新挂载，不然，当<code>chroot</code>切换进入目标系统之后，将无法获取一些系统信息，如：设备, 磁盘分区信息等. </p>
</div>
<p><img data-src="mount-bind.png" alt=""></p>
<p>在<code>chroot</code>到目标系统之前，需要挂载<code>EFI</code>分区到<code>/mnt/manjaro/boot/efi</code>（refind管理文件默认位置）下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount /dev/nvme0n1p2 /mnt/manjaro/boot/efi</span><br></pre></td></tr></table></figure>
<p><img data-src="efi_root.png" alt=""></p>
<p><code>chroot</code>到目标系统中，进行之后的操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chroot /mnt/manjaro</span><br></pre></td></tr></table></figure>
<h4 id="更新fstab文件"><a href="#更新fstab文件" class="headerlink" title="更新fstab文件"></a>更新fstab文件</h4><p>获取相应分区的<code>UUID</code>，以更新<code>fstab</code>文件和<code>/etc/default/grub</code>文件:<br><code>blkid</code>:</p>
<p><img data-src="blkid.png" alt=""></p>
<p>或</p>
<p><code>ls -l /dev/disk/by-uuid</code>:</p>
<p><img data-src="byuuid.png" alt=""></p>
<p>更新<code>fstab</code>文件:</p>
<p><img data-src="updated-fstab.png" alt=""></p>
<div class="note primary"><p>主要修改挂载项以及对应的<code>UUID</code>，有关<code>fstab</code>文件的详细内容可以参考<a href="https://wiki.archlinux.org/index.php/Fstab">https://wiki.archlinux.org/index.php/Fstab</a></p>
</div>
<h4 id="修复Grub"><a href="#修复Grub" class="headerlink" title="修复Grub"></a>修复Grub</h4><ol>
<li>重新生成Grub<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader=Manjaro --recheck</span><br></pre></td></tr></table></figure></li>
<li>更新Grub配置文件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo update-grub</span><br><span class="line">或</span><br><span class="line">sudo grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure>
</li>
</ol>
<div class="note warning"><p><strong>注意</strong>：如果此过程中出现以下提示信息:</p>
<p><code>EFI variables are not supported on this system.</code></p>
<p>需要先安装<code>efibootmgr</code>, <code>dosfstools</code>以及<code>grub</code>包，然后重新尝试重新生成<code>Grub</code>并更新其配置文件.</p>
</div>
<p>若仍出现该信息，则先退出<code>chroot</code>环境，并加载<code>efivarfs</code>模块:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo modprobe efivarfs</span><br></pre></td></tr></table></figure>
<p>然后再进入<code>chroot</code>环境，执行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -t efivarfs efivarfs /sys/firmware/efi/efivars</span><br></pre></td></tr></table></figure>
<p>再重新生成<code>Grub</code>并更新<code>Grub</code>配置文件就好了。</p>
<div class="note primary"><p>参考链接:<a href="https://wiki.manjaro.org/index.php/Restore_the_GRUB_Bootloader">https://wiki.manjaro.org/index.php/Restore_the_GRUB_Bootloader</a></p>
</div>
<h4 id="重新配置refind"><a href="#重新配置refind" class="headerlink" title="重新配置refind"></a>重新配置refind</h4><p>对之前的<code>refind</code>配置文件进行备份，保留主题文件<code>themes</code>及<code>refind.conf</code>就好了，其余的文件在执行<code>refind-install</code>时会自动生成.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 已经生成过了的,打印信息如下</span><br><span class="line">ShimSource is none</span><br><span class="line">Installing rEFInd on Linux....</span><br><span class="line">ESP was found at /boot/efi using vfat</span><br><span class="line">Found rEFInd installation in /boot/efi/EFI/refind; upgrading it.</span><br><span class="line">Installing driver for ext4 (ext4_x64.efi)</span><br><span class="line">Copied rEFInd binary files</span><br><span class="line"></span><br><span class="line">Notice: Backed up existing icons directory as icons-backup.</span><br><span class="line">Existing refind.conf file found; copying sample file as refind.conf-sample</span><br><span class="line">to avoid overwriting your customizations.</span><br><span class="line"></span><br><span class="line">Keeping existing NVRAM entry</span><br><span class="line">rEFInd is set as the default boot manager.</span><br><span class="line">Existing //boot/refind_linux.conf found; not overwriting.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img data-src="refind.png" alt=""></p>
<p>可以使用<code>efibootmgr</code>管理启动项，例如:<br><code>efibootmgr</code>查看当前所有的启动项，<code>efibootmgr -Bb xxxx</code>来删除不要的启动项，详细使用可以<code>man efibootmgr</code>来查看。</p>
<p><img data-src="efibootmgr.png" alt=""></p>
<p>其中的<code>windows</code>系统启动项通过<code>PE</code>用<code>UEFI</code>引导修复生成即可(需要注意的是老旧的PE识别不了<code>nvme</code>固态)。</p>
<p>以上就是迁移Linux系统的完整过程了</p>
<h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><p>在做完上面的所有操作，并将之前机械硬盘上的<code>EFI</code>分区等等(除<code>Win10</code>系统之外)都删除之后，重新启动进入固态盘上的系统，在<code>Grub</code>引导过程出现<code>UUID=***************</code>找不到的信息，经过查看之后发现，在<code>Grub</code>引导时居然没有挂载我那块<code>nvme</code>固态。</p>
<p>通过了解发现<code>Grub2.2</code>版本并不支持<code>nvme</code>的固态，可以使用安装<code>bootloader</code>来进行引导。PS: 但我<code>Manjaro</code>安装的<code>Grub</code>是<code>2.3</code>版本的，理论上是支持的。</p>
<div class="note primary"><p>参考链接: <a href="https://bbs.archlinux.org/viewtopic.php?id=209653">https://bbs.archlinux.org/viewtopic.php?id=209653</a></p>
</div>
<p>通过一番查找之后，终于找到了解决方法:</p>
<ol>
<li>添加加载模块 <code>sudo vim /etc/mkinitcpio.conf</code><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="deletion">- MODULES = &quot;&quot;</span></span><br><span class="line"><span class="addition">+ MODULES=&quot;nvme&quot;</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li>更新<code>mkinitcpio</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#参数说明，详细可以通过man查看</span><br><span class="line">-p, --preset preset</span><br><span class="line">Build initramfs image(s) according to specified preset. This may be a file in /etc/mkinitcpio.d (without the .preset extension) or a full, absolute path to a file. This option may be specified multiple times to process multiple presets.</span><br></pre></td></tr></table></figure></li>
<li>更新Grub<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo update-grub</span><br><span class="line">或</span><br><span class="line">sudo grub-mkocnfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>再次重启之后，便可以成功进入系统了。</p>
<div class="note primary"><p>参考链接:<a href="http://blog.51cto.com/shenfly231/1918426">http://blog.51cto.com/shenfly231/1918426</a>, 若要安装<code>bootloader</code>也可以参考该链接。</p>
</div>
<h3 id="SSD优化"><a href="#SSD优化" class="headerlink" title="SSD优化"></a>SSD优化</h3><h4 id="开启Trim功能"><a href="#开启Trim功能" class="headerlink" title="开启Trim功能"></a>开启Trim功能</h4><p>关于什么是<code>TRIM</code>?：</p>
<blockquote>
<p>SSD TRIM is an Advanced Technology Attachment (ATA) command that enables an operating system to inform a NAND flash solid-state drive (SSD) which data blocks it can erase because they are no longer in use. The use of TRIM can improve the performance of writing data to SSDs and contribute to longer SSD life.</p>
</blockquote>
<div class="note primary"><p>了解可以参考: <a href="https://searchstorage.techtarget.com/definition/TRIM">https://searchstorage.techtarget.com/definition/TRIM</a>，以及<code>Arch wiki</code>上的:<br /><a href="https://wiki.archlinux.org/index.php/Solid_state_drive#TRIM">https://wiki.archlinux.org/index.php/Solid_state_drive#TRIM</a></p>
</div>
<blockquote>
<p>Most SSDs support the <strong>ATA_TRIM command</strong> for <strong>sustained long-term performance and wear-leveling</strong>. A techspot article shows performance benchmark examples of before and after filling an SSD with data.</p>
<p>As of Linux kernel version 3.8 onwards, support for TRIM was continually added for the different filesystems. See the following table for an indicative overview:</p>
</blockquote>
<p><img data-src="trim-supported.png" alt=""></p>
<p>在使用<code>Trim</code>功能之前需要查看固态硬盘是否支持，否则可能造成数据丢失:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsblk --discard</span><br></pre></td></tr></table></figure>
<p><img data-src="lsblk-discard.png" alt=""></p>
<p><code>DISC-GRAN</code>和<code>DISC-MAX</code>不为<code>0</code>则表示支持，详细查看上面的<code>Arch Wiki</code>给出的文章。</p>
<p>关于使用的<code>Trim</code>方式，Nvme 协议固态是不推荐使用的<code>Continuous TRIM</code>方式的。(详见<a href="https://wiki.archlinux.org/index.php/Solid_state_drive/NVMe#Discards">Arch Wiki</a>)</p>
<p>所以使用的定期执行<code>fstrim</code>的方式，即添加一个定时任务或服务让其自动执行，如每周执行一次trim操作。 参考<a href="https://wiki.archlinux.org/index.php/Solid_state_drive#Periodic_TRIM">Periodic TRIM</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> fstrim.service</span><br><span class="line"></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> fstrim.timer</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><figcaption><span>fstrim.service</span></figcaption><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Discard unused blocks on filesystems from /etc/fstab</span><br><span class="line">Documentation=man:fstrim(8)</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line">ExecStart=/sbin/fstrim -Av</span><br></pre></td></tr></table></figure>
<p>启用<code>fstrim.timer</code>服务则会自动每周做一次<code>trim</code>.</p>
<figure class="highlight plaintext"><figcaption><span>fstrim.timer</span></figcaption><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Discard unused blocks once a week</span><br><span class="line">Documentation=man:fstrim</span><br><span class="line"></span><br><span class="line">[Timer]</span><br><span class="line">OnCalendar=weekly</span><br><span class="line">AccuracySec=1h</span><br><span class="line">Persistent=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=timers.target</span><br></pre></td></tr></table></figure>
<h4 id="IO调度器选择"><a href="#IO调度器选择" class="headerlink" title="IO调度器选择"></a>IO调度器选择</h4><p>一般来说，IO调度算法是为低速硬盘准备的，对于固态，最好是不使用任何IO调度器，或使用对硬盘干预程度最低的调度算法。</p>
<ol>
<li>查看当前固态的IO调度器:<br><img data-src="io-schedulers.png" alt=""><br>可以看到我当前固态没有使用任何调度器，而机械硬盘使用的是<code>bfq-sq</code>.</li>
<li>修改IO调度器(临时的):<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo noop &gt; /sys/block/sda/queue/scheduler</span><br></pre></td></tr></table></figure></li>
<li>要永久生效则需要添加编写开机自启动脚本<br>详见参考链接.</li>
</ol>
<div class="note primary"><p>更多信息以及详细的内容可以参考下面给出的参考链接.<br>参考链接:</p>
<ul>
<li><a href="https://wiki.archlinux.org/index.php/Improving_performance#Storage_devices">https://wiki.archlinux.org/index.php/Improving_performance#Storage_devices</a></li>
<li><a href="https://blog.codeship.com/linux-io-scheduler-tuning/">https://blog.codeship.com/linux-io-scheduler-tuning/</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-lo-io-scheduler-optimize-performance/index.html">https://www.ibm.com/developerworks/cn/linux/l-lo-io-scheduler-optimize-performance/index.html</a></li>
</ul>
</div>
<h4 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h4><div class="note primary"><p>更多有关<code>Linux VM</code>性能调优的可以参考:<br><a href="https://lonesysadmin.net/tag/linux-vm-performance-tuning/">https://lonesysadmin.net/tag/linux-vm-performance-tuning/</a></p>
</div>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ssd</tag>
      </tags>
  </entry>
  <entry>
    <title>A Compact Encoding for Efficient Character-level Deep Text Classification</title>
    <url>/posts/ea5d9796/</url>
    <content><![CDATA[<blockquote>
<p>文献翻译：高效的紧凑编码字符级深层文本分类<br>authors: Wemerson Marinho, Luis Martı́, Nayat Sanchez-Pi<br>原文: <a href="https://ieeexplore.ieee.org/document/8489139">A Compact Encoding for Efficient Character-level Deep Text Classification</a></p>
</blockquote>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>本文提出了一种新的文本到张量的表示方式，它依靠信息压缩技术为最常用的字符分配较短的编码。这种表示方式与语言无关，不需要进行预训练并能够产生没有信息损失的编码。它提供了对文本形态的充分描述，例如，它能够用来表示前缀，后缀和变形相似的向量，甚至能够表示训练集中没有的单词。通常，由于它紧凑而稀疏，因此非常适合使用张量处理库来加快训练时间。作为本文的一部分，我们证明了当与卷积神经网络（CNN）结合用于字符级别的文本分类时，该技术特别有效。我们将 CNN 的两个变体与本文的编码方式结合使用。实验结果表明，它极大地减少了要优化的参数数量，从而仅在 one-hot 编码表示所花费的时间的一小部分中就产生了具有竞争力的分类精度，从而应用于商业硬件中来训练模型。</p>
<p>Index Terms — text classification, character level convolutional neural networks, encoding of words</p>
<span id="more"></span>
<h2 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1. INTRODUCTION"></a>1. INTRODUCTION</h2><p>文档分类是自然语言处理中要解决的主要任务之一<sup><a href="#fn_1" id="reffn_1">1</a></sup>。它意味着将文档（或任何文本片段）与依赖其内容的类别或标签相关联。数字形式的文本（尤其是通过 Internet）的可用性不断提高，要求开发统计和人工智能以使该过程自动化。垃圾邮件检测器，情感分析，新闻归档等许多方面都需要高质量的文本分类器。</p>
<p>文档分类的方法覆盖范围很广（参见<sup><a href="#fn_1" id="reffn_1">1</a></sup>-<sup><a href="#fn_4" id="reffn_4">4</a></sup>）。它们的重要部分依赖于将词作为文本的原子元素来处理的表示形式。因此，这些方法通过统计词的出现来进行分析<sup><a href="#fn_5" id="reffn_5">5</a></sup>。但是，属于一种语言的单词和结构的可变性阻碍了该方法的可行性。因此，这些模型在特定领域和应用中具有出色的性能，在这些领域和词汇中，词汇被限制为或可以限制为相对少量的单词，可能是由专家来进行挑选的。此外，这种建模对于一种语言而言是特定的，对于另一种语言将需要重新开始类似的过程<sup><a href="#fn_5" id="reffn_5">5</a></sup>。</p>
<p>近年来，随着深度学习方法的出现，我们经历了机器学习的一场革命<sup><a href="#fn_6" id="reffn_6">6</a></sup>。CNN 的发展<sup><a href="#fn_7" id="reffn_7">7</a></sup>与并行计算库（例如 Theano<sup><a href="#fn_8" id="reffn_8">8</a></sup>，Tensorflow<sup><a href="#fn_9" id="reffn_9">9</a></sup>, Keras<sup><a href="#fn_10" id="reffn_10">10</a></sup>等）的普及相结合，简化了图形处理单元上的通用计算（GPGPU）<sup><a href="#fn_11" id="reffn_11">11</a></sup>已成功解决图像分类问题<sup><a href="#fn_12" id="reffn_12">12</a></sup>，迅速成为该领域的最新技术。</p>
<p>可以预见，深度学习和 CNN 在图像分类领域的成功促使人们将深度学习原理扩展到文档分类领域。一些现有的方法已经更新，但明显的大多数方法仍基于单词的符号化机器统计推理。词袋（BoW）<sup><a href="#fn_13" id="reffn_13">13</a></sup>和 Word2vec<sup><a href="#fn_14" id="reffn_14">14</a></sup> 是一些最受欢迎的策略。</p>
<p>可以说，在文档领域中复制图像分类的成功面临的主要挑战是将文本表示为数字张量的困难。为了解决这个问题，<sup><a href="#fn_5" id="reffn_5">5</a></sup>提出了一种开创性的方法，将字符视为文本的原子元素。特别是，他们将文本表示为 one-hot 编码字符序列。这种编码提供了一种强大的，独立于语言的文本表示形式的矩阵，然后将其用作不同 CNN 的输入。他们的实验结果表明，这种方法能够实现并在某些情况下改善复杂文本分类问题的最新技术水平。最近，参考文献<sup><a href="#fn_15" id="reffn_15">15</a></sup>通过将 CNN 与长短期记忆网络 （LSTM）结合起来改善了那些结果<sup><a href="#fn_16" id="reffn_16">16</a></sup>。尽管如此，该方法的庞大计算需求阻碍了该方法的效果，因为在相对复杂的问题中，其训练可能需要花费几天的时间。</p>
<p>字符级别的表示形式可能比单词级别的表示形式更强大。另一方面，它们在计算上更昂贵，因为在字符级别检测语法和语义关系更昂贵<sup><a href="#fn_17" id="reffn_17">17</a></sup>。一种可能的解决方案是合并字符级别信息的单词表示。</p>
<p>在本文中，我们提出了一种有效的单词字符级别编码以表示文本，它主要受 Tagged Huffman<sup><a href="#fn_18" id="reffn_18">18</a></sup> 信息压缩技术启发。该编码考虑了文本中的字符出现频率，以便将较短的编码分配给最常用的字符。这种新颖的文本编码通过减少其在时间和内存方面的训练要求，使<sup><a href="#fn_5" id="reffn_5">5</a></sup>提出的想法在计算上更加容易实现。</p>
<p>本文所提出的编码使得可以以较稀疏的形式表示文本的较大部分，而不会丢失任何信息，同时保留了对任何单词（甚至是训练数据集中不存在的单词）进行编码的能力。为了研究这种编码的影响，我们将其与两种 CNN 架构相结合。通过进行的实验研究表明，即使我们采用了较简单的硬件配置，我们也可以在较短的训练时间内实现达到与现有技术类似的性能，或者在某些情况下要比现有技术要好。</p>
<p>我们的主要贡献表明了，这种新颖的字符级别文本编码产生了精简的输入矩阵，从而大大了训练时间，同时在准确性方面可与原来的方法<sup><a href="#fn_5" id="reffn_5">5</a></sup>相比产生可比或更好的结果。这为更复杂的应用，使用具有较低计算能力的设备以及探索可以与输入表示方式结合的其他方法打开了大门。</p>
<p>本文的其余部分的结构如下。在下一节中，我们将讨论本文所需的理论基础。然后，我们还分析了字符级别文本压缩的替代方案，这些替代方案在提出我们的方法时已经考虑了。之后，在第三部分中，我们将介绍将要参与实验的编码过程和神经网络结构。随后，在第四节中，我们复制了<sup><a href="#fn_5" id="reffn_5">5</a></sup>中的实验，以便在可比较的条件下将我们的方法与他们的方法进行对比。最后，在第五节中，我们提供了一些最后的结论性意见并概述了我们未来的工作方向。</p>
<h2 id="2-PRELIMINARIES"><a href="#2-PRELIMINARIES" class="headerlink" title="2. PRELIMINARIES"></a>2. PRELIMINARIES</h2><p>随着许多库<sup><a href="#fn_8" id="reffn_8">8</a></sup>,<sup><a href="#fn_10" id="reffn_10">10</a></sup>,<sup><a href="#fn_19" id="reffn_19">19</a></sup>，技术和硬件的发展，在图像分类<sup><a href="#fn_12" id="reffn_12">12</a></sup>中使用卷积神经网络（CNN）<sup><a href="#fn_7" id="reffn_7">7</a></sup>的成功蓬勃发展。通过使用这些工具以获得更好的结果和更强大的算法的可能性证明了使用 CNN 进行文本分类任务的合理性，从而促使了在多个应用程序中使用相同的方法。</p>
<p>有两种使用 CNN 来处理文本信息的常用方法：(i) 词袋（BoW）<sup><a href="#fn_13" id="reffn_13">13</a></sup>和 (ii) Word2vec<sup><a href="#fn_14" id="reffn_14">14</a></sup>方法。</p>
<p>在 BoW 机器某些变体的情况下，为了表示大小为 $N$ 的词汇表中的每个单词，将数字 $1$ 放置在该单词在 $1\times N$向量中的对应位置，所有其他位置保留为数字 $0$。由于自然语言通常具有很大的词汇量，因此必须使用词汇表的有限子集，以使其能够根据内存需求执行必要的计算。所选的词汇的子集必须代表文本。因此，在实际问题中，对此问题需要投入了大量的精力。特别是，通常需要聘请应用程序领域专家或使用某种单词频率统计或相关性度量标准，其中最常见和最稀有的单词都被排除在外。</p>
<p>在 word2vec 方法中，每个单词都是通过固定大小的度量嵌入来投影的，表示它在与感兴趣的文本相同的语言的大文本语料库中共现。可以使用预训练的矩阵或使用新单词重新调整表示形式。两种策略的主要问题是它不允许表示不在训练数据集中的单词。错字，拼写错误，字母和用复杂结构的语言（变形，变位等）书写的文本被完全忽略。</p>
<p>将字符确立为文本形成的基本单位可提供一个更好的机会，使它能够很好地应对拼写错误问题，接受新词以及其他文本形式，如等式和化学式，缩写和特质，例如互联网上的图释，方言，表情等。假设单词是基本单元，那么这种表示方式将会丧失许多本来具备的能力，尤其是在模型假设文本生成者使用正式语言的情况下。</p>
<p>参考文献<sup><a href="#fn_5" id="reffn_5">5</a></sup>在这方面提出了重要的创新。它们将文本表示为字符级别序列，而不是单词。因此，它们能够将符号的词汇量减少到字母表的大小（文献中是 69），从而允许使用 one-hot 编码<sup><a href="#fn_20" id="reffn_20">20</a></sup>。在该文献中，他们将文本表示为大小为 $1014\times 69$的矩阵，其中每一行对应于文本序列和列中存在或不存在给定字符的位置。因此，在给定序列中带有 $1$ 的行表示在该文本位置中存在相应的字符。有了这种表示形式，他们将它应用于 CNN 并获得了与其他技术可竞争的结果，并且在某些情况下提高了现有技术的结果。但是，主要缺点是计算量大，在某些情况下每个训练 epoch 需要几天的时间。</p>
<p>他们获得结果表明，语言以及文本可以像其他信号一样被视为一系列信号<sup><a href="#fn_5" id="reffn_5">5</a></sup>。但是，训练时间和要计算的矩阵的尺寸仍然是有效使用该方法的障碍。这就是为什么更好的文本编码可能是朝着实质性改善此问题的正确道路。</p>
<h2 id="3-COMPRESSED-ENCODING-FOR-CNN-BASED-TEXT-CLASSIFICATION"><a href="#3-COMPRESSED-ENCODING-FOR-CNN-BASED-TEXT-CLASSIFICATION" class="headerlink" title="3. COMPRESSED ENCODING FOR CNN-BASED TEXT CLASSIFICATION"></a>3. COMPRESSED ENCODING FOR CNN-BASED TEXT CLASSIFICATION</h2><p>在寻找一种方法来减少训练时间，同时又保留了字符级别卷积对文本进行分类的灵活性和强大功能时，我们找到了一种更好地对文本进行编码的方法。我们的方法具有极高的准确性，可以大幅度地减少训练一 epoch 所需的时间，从数小时减少到数分钟，从数天减少到数小时。</p>
<p>为了获得更好的性能，起初，我们虽然对每个字符使用形式的编码，并使用<sup><a href="#fn_5" id="reffn_5">5</a></sup>相同的方法，但是我们意识到对每个单词使用可变长编码可能会更有效。为此，我们需要一种对每个字符进行编码的方法，生成用于表示每个单词的不同的级联编码，并且具有相同前缀的单词彼此相近，尤其该编码能很好地应对单词变体。</p>
<h3 id="A-Compressed-Representation"><a href="#A-Compressed-Representation" class="headerlink" title="A. Compressed Representation"></a>A. Compressed Representation</h3><p>尽管 Huffman<sup><a href="#fn_2" id="reffn_2">2</a></sup>编码产生的编码可能最短，但是一旦我们将编码后的字符连接起来形成一个单词，它就无法生成一个唯一的表示。我们研究了<sup><a href="#fn_22" id="reffn_22">22</a></sup>的编码方式，并找到了有前途的替代方案。</p>
<p>我们的方法基于 tagged Huffman<sup><a href="#fn_18" id="reffn_18">18</a></sup> 编码方案，其中一对 “0” 数字是信号，而数字“1”是开始和结束编码的标签，唯一的区别是我们的方法是一种较短的版本，以减少输入矩阵的大小，因而选择仅对妹子字符使用一个数字“0”而不是两个，并以相同的方法用数字“1”标记每个字符编码的开始和结束。</p>
<p>与<sup><a href="#fn_18" id="reffn_18">18</a></sup>中的方法一样，我们采用的编码具有以下优点<sup><a href="#fn_22" id="reffn_22">22</a></sup>:</p>
<ul>
<li>1) 没有字符编码是另一个的前缀，也就是说，匹配是一对一唯一对应的。</li>
<li>2) 允许直接搜索，即在编码文档中搜索单词，只需要对单词进行编码，然后使用传统的方法将编码后的字符在文档中进行匹配搜索。</li>
<li>3) 这种编码方法是一种压缩技术，因此它还允许使用二进制永久保存已编码后的文本文档，从而需要较少的存储空间。</li>
</ul>
<p>这些优势变得比较有吸引力，尤其是如果目标是提取有关存储库文件的知识，以便对相同文件在不同维度上执行各种分类，则这些优势尤其具有吸引力。</p>
<p>这种编码相对于使用单词作为文本的原子表示的其他策略的可能优势是，当网络像我们人类一样通过一些前缀来猜测单词的含义的时候，可以更好地响应训练数据中未见过的单词。这在那些拥有大量变体的语言，如葡萄牙语，西班牙语，意大利语，法语，俄语，阿拉伯语和土耳其语等将尤其有用。</p>
<p>该编码过程不限于任何大小的词汇表，唯一的问题是较低词频的字符会产生相对较长的编码，因此形成较大的矩阵表示。</p>
<h3 id="B-Encoding-Procedure"><a href="#B-Encoding-Procedure" class="headerlink" title="B. Encoding Procedure"></a>B. Encoding Procedure</h3><p>在我们所有的实验中，我们使用以下编码方式对单词进行编码：</p>
<ul>
<li><strong>获取每个字符的频率</strong>：读取文本数据库并计算每个字符的频率，生成一个按出现频率排序的列表。然后我们创建一个仅包含字符相对位置的排行。对于给定的语言，此排行非常稳定，因为仅使用排行的顺序。这意味着，如果所有文档都在相同的习惯用法中，则可以用具有该语言频率排行的字符的列表来替换此过程。</li>
<li><strong>创建从字符到压缩编码的映射</strong>:为了对每个字符进行编码，我们将数字“0“的数量的表示字符的位置排行，并以两个”1“作为编码的开始和结束。Table 1是一些字符编码的例子。</li>
</ul>
<p><img data-src="table-1.png" alt=""></p>
<p>要对每个单词进行编码，我们只需要将编码的字符连接起来即可。例如，Table II 提供了一些纯文本单词及其对应编码示例。</p>
<p><img data-src="table-2.png" alt=""></p>
<p>给定一个文档，我们认为它们由单词组成，即由空格字符划分的任何一组字符。这意味着”单词“可以是数学方程式，网址，LATEX代码，计算机编程指令等。在 Table II 中，我们可以看到具有相同初始坐标的向量中具有相同前缀的单词。同样可以表示像这样的俚语，$tl$:too long，$dr$: did not read 和$u2$: you too，像$e^a$这样的数学表达式也是可以的。</p>
<p>在代表文档的$number\quad of\quad words\times code\times size$的矩阵中，每一行代表一个相应编码后的单词，第一列是嵌入编码的第一个字符。未占用的列将填充”0“，较大的编码表示受选择限制。空行用”0”填充，较大的文档仅表示所选的最大单词数，忽略剩余的所有单词。例如，Figure 1 以 $8\times 65$表示了一个文档。</p>
<p><img data-src="figure-1.png" alt=""></p>
<p>在 Figure 1 的示例中，我们使用 $8\times 65$的矩阵（520 个元素）对文本进行了一定程度松弛表示。在最少的情况下，我们将需要 $6\times 64$（448 个元素）。相反，<sup><a href="#fn_5" id="reffn_5">5</a></sup>方法将至少使用 $32\times 69$（2208）个元素来表示相同的句子。</p>
<p>在我们的实验中，使用 256 维度足以代表来自所研究数据库之一的单词的 99.5%。在本文研究的所有数据库中，我们选择 128 作为代表文档的单词限制，以 $128\times 256$的矩阵来表示每个文本。</p>
<p><img data-src="table-3.png" alt=""></p>
<p>1) 卷积网络模型：之前说过，此项工作是由<sup><a href="#fn_5" id="reffn_5">5</a></sup>发起的。在他们的原始方法中，他们使用拥有 69 个元素的词汇表的 one-hot 编码来对每个字符进行编码，使用字母，数字和标点符号作为非空格字符。模型由 9 层，6 个卷积层和 3 个全连接层组成。Table III 展示了它们的结构。</p>
<p>他们使用了随机梯度下降（SGD），其中最小批量大小为 128，动量（momentum）为0.9，且初始步长为 0.01，每隔 3 epoch 减少 10 次。因此，他们需要至少训练 30 个 epoch 才能获得结果。</p>
<h3 id="C-Neural-Network-Architectures"><a href="#C-Neural-Network-Architectures" class="headerlink" title="C. Neural Network Architectures"></a>C. Neural Network Architectures</h3><p>为了验证本文编码方式的有效性，我们执行了 3 个实验，使用 3 个模型，CNN1，CNN2 和 LSTM：</p>
<p><img data-src="figure-2.png" alt=""></p>
<h3 id="D-CNN1-topology"><a href="#D-CNN1-topology" class="headerlink" title="D. CNN1 topology"></a>D. CNN1 topology</h3><p>首先，该网络结构通常使用 word2vec <sup><a href="#fn_14" id="reffn_14">14</a></sup> 创建的嵌入对文本进行分类，唯一的区别是我们将输入大小减少到 256，而不是 300 个特征。我们将此结构命名为 CNN1。它是基于卷积的拼接的浅层学习方法，受<sup><a href="#fn_23" id="reffn_23">23</a></sup>启发，他们在某些数据集上取得现有技术结果。</p>
<p>我们使用该模型训练 5 个 epoch。神经网络结构见 Figure 2a。</p>
<h3 id="E-CNN2-topology"><a href="#E-CNN2-topology" class="headerlink" title="E. CNN2 topology"></a>E. CNN2 topology</h3><p>在 CNN1 取得积极成果的情况下，我们决定研究其他可能的结构。根据<sup><a href="#fn_24" id="reffn_24">24</a></sup>中的建议选择参数，我们创建了另一个浅而宽的卷积网络结构，对 ag 新闻数据集上进行训练。该网络结构由以下组成：</p>
<ul>
<li>卷积宽度过滤器（kernel_size）：接近最佳单个最佳区域大小的区域组合优于使用远离最佳单个区域大小的多个区域大小的组合<sup><a href="#fn_24" id="reffn_24">24</a></sup>。我们将宽度从 1 扫描到 7，比较精度性能。在这些评估中，宽度为 1 的卷积是最好的选择。</li>
<li>Pooling size: 对于句子分类任务，max pooling 始终比其他的策略表现更好<sup><a href="#fn_24" id="reffn_24">24</a></sup>。</li>
</ul>
<p>CNN2 的网络结构见 Figure 2b。</p>
<h3 id="F-LSTM-topology"><a href="#F-LSTM-topology" class="headerlink" title="F. LSTM topology"></a>F. LSTM topology</h3><p>为了说明应用本文编码的可能性，我们使用 LSTM<sup><a href="#fn_16" id="reffn_16">16</a></sup>进行了实验，类似于<sup><a href="#fn_25" id="reffn_25">25</a></sup>所述的 LSTM 模型，不同之处在于：我们使用本文的表示方式，而不是使用 word2vec 嵌入<sup><a href="#fn_14" id="reffn_14">14</a></sup>。该结构非常简单，输入层为 $128\times 256$，其次是 LSTM 层为 300，Dropou 层的丢弃率为 $0.10$<sup><a href="#fn_26" id="reffn_26">26</a></sup>, 一个具有 128 个单元的全连接层以及一个 softmax 层。</p>
<p>我们使用该模型训练 5 个 epoch。通常，该网络结构比 CNN1 慢两倍。LSTM 模型的结构见 Figure 2c。</p>
<h2 id="4-EXPERIMENT-STUDY"><a href="#4-EXPERIMENT-STUDY" class="headerlink" title="4. EXPERIMENT STUDY"></a>4. EXPERIMENT STUDY</h2><p>本文工作的一个重要部分是将本文的字符级别编码方案与上下文中的其他最新方法进行对比。所使用的数据库与<sup><a href="#fn_5" id="reffn_5">5</a></sup>中引用的相同，此外有另外的相关详细描述<sup><a href="#fn_1" id="reffn_1">1</a></sup>。对这些数据集详细分析超出了本文的研究范围，相反，我们将仅对数据的主要特点进行总结：</p>
<ul>
<li><strong>AG’ news</strong>: 对来自 2000 多个新闻来源的新闻进行了分类。四个类别（世界，体育，商业，科学技术）。数据集包含平均分布的 120k 个训练样本和 7.6k 个测试样本<sup><a href="#fn_5" id="reffn_5">5</a></sup>。</li>
<li><strong>Sogou’ news</strong>: 按中文分类的新闻文章。<sup><a href="#fn_5" id="reffn_5">5</a></sup>应用 pypinyin 库结合 jieba 分词来产生拼音，即汉语的罗马音表示。主要包含物种类别（体育，金融，娱乐，汽车和技术）。该数据集包含平均分布的 450k 个训练样本和 60k 个测试样本。</li>
<li><strong>DBpedia</strong>: DBpedia 众包社区中提供的 Wikipedia 文章的标题和摘要<sup><a href="#fn_27" id="reffn_27">27</a></sup>，其中包含 DBpedia 2014 的十四个非重叠类别。数据集包含平均分布的 560k 个训练样本和 70k 个测试样本。</li>
<li><strong>Yelp full</strong>: 2015 年 Yelp 数据集挑战赛中的情感分析。五个类别代表用户给出的星数。数据集包含平均分布的 560k 个训练样本和 38k 个测试样本。</li>
<li><strong>Yelp polarity</strong>: 2015 年 Yelp 数据集挑战赛中的情感分析。原始数据被转换为极性问题。1 星和 2 星的评分表示为不良，而 4 星和 5 星的评分表示为良好。数据集包含平均分布的 560k 个训练样本和 50k 个测试样本。</li>
<li><strong>Yahoo! answers</strong>: Yahoo! 上的问题和答案。包含十个类别（社会与文化，科学与数学，健康，教育，计算机与互联网，体育，商业与交融，娱乐与音乐，家庭与人际关系，政治与政府）。每个样本均包含问题标题，问题内容和最佳答案。该数据集包含平均分布的 1,400k 个训练样本和 60k 个测试样本。</li>
<li><strong>Amazon full</strong>: 来自 Amazon 的 SNAP 项目的情感分析评论数据集<sup><a href="#fn_28" id="reffn_28">28</a></sup>。用五个类别表示用户给出的星数。数据集包含 3,000k 个训练样本和 650k 个测试样本<sup><a href="#fn_5" id="reffn_5">5</a></sup>。 </li>
<li><p><strong>Amazon polarity</strong>: 同样来自 Amazn 的 SNAP 项目的情感分析评论数据集<sup><a href="#fn_28" id="reffn_28">28</a></sup>。原始数据被转换成极性问题，星数为 1和2的表示差，星数为 4 和 5的表示为良好。数据集中包含平均分布的 3,600k 个训练样本和 400k 个测试样本。<sup><a href="#fn_5" id="reffn_5">5</a></sup></p>
<p>  基线比较模型与<sup><a href="#fn_5" id="reffn_5">5</a></sup>相同，其中有大量描述，我们只是复制了他们的结果，唯一不同的是，他们使用损失误差作为基准，为了更好地理解，我们将其转换为准确性。在<sup><a href="#fn_5" id="reffn_5">5</a></sup>中对有详细的描述。在本文中，我们仅总结主要信息：</p>
</li>
<li><p><strong>Bag of Words(BoW) and its term-frequency inverse-document-frequency (BoW TFIDF)</strong>: 对于每个数据集，他们从训练子集中选择了 50,000 个最频繁的单词。对于普通的 BoW，使用每个单词的计数作为特征，对于 TFIDF, 他们使用计数作为词频<sup><a href="#fn_5" id="reffn_5">5</a></sup>。</p>
</li>
<li><strong>Bag-of-ngrams (Ngrams) and its TFIDF (Ngrams TFIDF)</strong>: 通过从每个数据集的训练子集中选择 500,000 个最常见的 n-gram (最多 5-gram) 来构建 n-grams 模型。特征值的计算方式与 BoW 模型相同<sup><a href="#fn_5" id="reffn_5">5</a></sup>。</li>
<li><strong>Bag-of-means on word embedding</strong>: 该模型对每个数据集的训练子集使用 word2vec<sup><a href="#fn_14" id="reffn_14">14</a></sup>上的 k 均值，然后将这些学习到的均值用作聚类词的代表。考虑在训练子集中出现超过 5 次的所有单词。嵌入的维数为 300。特征的计算方式与 BoW 模型的计算方式相同。均值数为 5000<sup><a href="#fn_5" id="reffn_5">5</a></sup>。</li>
<li><strong>Long-Short Term Memory (LSTM)</strong>: LSTM<sup><a href="#fn_16" id="reffn_16">16</a></sup>模型是基于单词的，大小为 300 的预训练 word2vec<sup><a href="#fn_14" id="reffn_14">14</a></sup> 嵌入。通过对所有 LSTM 的输出取均值来形成模型的特征向量，然后使用多项式逻辑回归。输出尺寸为 512<sup><a href="#fn_5" id="reffn_5">5</a></sup>。</li>
</ul>
<p>对于所有的实验，我们使用 Table IV 中列出的环境和参数配置。除了使用小写字母的编码过程外，我们不使用任何预处理策略。没有采用数据增强技术。</p>
<p><img data-src="table-4.png" alt=""></p>
<p>Table V 显示了所有结果，并与传统模型和方法<sup><a href="#fn_5" id="reffn_5">5</a></sup>进行了比较。</p>
<p><img data-src="figure-3.png" alt=""></p>
<p>由于表格数据显示不够直观，因此我们决定采用图形表示结果。特别是，从先前的结果中，我们选择了<sup><a href="#fn_5" id="reffn_5">5</a></sup>的大型和小型结构以及 CNN1，CNN2 以及 LSTM。然后将这些精度按比例缩放到每个数据集的范围 $[0,1]$ 之间，即 0 表示最差，1 表示最佳性能。在所有模型中，包含传统模型，其结果图 Figure 3 所示。在 Table VI 上，我们根据<sup><a href="#fn_5" id="reffn_5">5</a></sup> 可获得的结果进行了运行时间上的比较。</p>
<p>本文的主要研究目的是评估使用我们编码方法的可能性，该方法考虑了使用字符作为基本单元的单词构造。我们的主要贡献在于，这种方法可以减少编码矩阵的维数，从而大大缩短模型训练的时间，并降低所需的计算能力要求。某些文本数据集具有词频方法（即 BoW 和 word2vec）无法解决的特点，例如变体和新词汇。<sup><a href="#fn_5" id="reffn_5">5</a></sup>在这方面是伟大的创新，但是其训练仍然是阻碍有效使用该技术的关键因素。因此，我们提出了一种更好地表示方式。</p>
<p><img data-src="table-5.png" alt=""><br><img data-src="table-6.png" alt=""></p>
<p>为了做比较，我们使用 CNN1 进行训练，模型输出 4 个类别，需要优化 1,837,188 个参数。作为比较，在<sup><a href="#fn_5" id="reffn_5">5</a></sup>建议的结构中，它需要优化的参数数量为 11,337,988。 </p>
<p>由于我们关注的问题之一是使我们的方案在商业硬件上尽可能适用，因此我们将研究重点放在了硬件配置上。分析大多矩阵编码文本的主要瓶颈是需要大量使用 RAM。我们的方法生成 $128\times 256$大小的矩阵，小于 $1014\times 69$<sup><a href="#fn_5" id="reffn_5">5</a></sup>。尽管如此，其中很大一部分很快就占用了“常规”个人计算机上的可用 RAM。在我们使用的计算机上，有 16G 的可用空间，这在现代个人计算机中并不罕见。因此，在这种优化算法的实现中，使用生成器控制生成并发送到 GPU 的矩阵的数量非常重要。如果你的计算机只有 8GB 或更少的 RAM，则有必要减少批处理的大小。</p>
<p>结果与<sup><a href="#fn_5" id="reffn_5">5</a></sup>的方法和传统技术相比非常有竞争力。我们甚至可以看到，按照<sup><a href="#fn_24" id="reffn_24">24</a></sup>的建议，我们可以在 AG 新闻数据集上获得出色的性能表现。快速算法的优点之一是，如果数据集没有那么大，则可以扫描特征宽度以找到优化精度的解决方案。另一个优点是可以实现 k-折验证，以便更好地了解特定数据集在现实生活中的表现。</p>
<p>另一个有趣的点是，与使用<sup><a href="#fn_5" id="reffn_5">5</a></sup>提出的使用 word2vec<sup><a href="#fn_14" id="reffn_14">14</a></sup>进行嵌入方法相比，将 LSTM 层与本文的编码方法一起使用，我们能获得相似甚至更好的结果。我们的方法具有其自身的性质，当 word2vec 使用预训练的向量来表示大文本主体上的单词共现时，它说明了文本的形态学方面。即使在 RNN 中也能考虑字符信息，我们证明了这种表示方式并不限于 CNN 或神经网络领域。</p>
<p>尽管 LSTM 模型训练比 CNN1 和 CNN2 模型慢，但其性能始终优于它们。这表明单词之间的时间依赖性很重要，因此，考虑到此信息，其他结构可能会产生更好的结果，这是应该探索的方向。除此以外，通过我们的编码方式实现的降维效果使其他几种结构和方法也可以在合理的时间内得到验证。</p>
<p>我们相信我们的算法实现可以更快。例如，当使用 GPU Gefore 1080Ti 和 CNN1 模型时，10,000 个阵列的每个超级批处理的权重都能够在 30 秒之内更新。GPU 仅需要 6 秒钟，而对于所有矩阵进行编码到将其交付到 GPU 则花费了另外 24 秒钟。在这方面，使用多线程策略可能会有所帮助。</p>
<h2 id="5-FINAL-REMARKS"><a href="#5-FINAL-REMARKS" class="headerlink" title="5. FINAL REMARKS"></a>5. FINAL REMARKS</h2><p>在本文中，我们提出了一种有效的字符级编码方案，基于 Tagged Huffman<sup><a href="#fn_18" id="reffn_18">18</a></sup> 信息压缩方法，来对文本进行编码，并将其用作字符级 CNN 文本分类的输入预处理步骤。</p>
<p>我们已经证明，使用这种压缩技术是用于文本分类的深度学习卷积中表示文本的一种方便可能性。这一点尤为重要，因为在处理较少整理过的文本数据集时，使用字符级编码文本可能较重要，因为它对拼写错误，错别字，俚语，语言变体以及 Internet 文本的其他常见特征具有鲁棒性。</p>
<p>这种新颖的文本编码允许以紧凑的形式表示文本的较大部分，同时保留对任何单词（甚至是训练数据集中未出现过的单词）进行编码的能力。此外，由于紧凑而稀疏，此方法大大减少了训练 CNN 所需的时间，因此使用此编码方案的应用更易于访问。这为更复杂的应用，使用具有较低计算能力的设备以及探索可以与该输入表示形式结合的其他方法提供了方便。</p>
<p>本文使用两个 CNN 模型以及一个 LSTM 模型与本文提出的编码方法结合，进行实验，这些实验结果表明，即使采用了更简单的硬件配置，我们也可以在较短的时间内实现与<sup><a href="#fn_5" id="reffn_5">5</a></sup>相似的性能。此外，根据我们的结果，我们证明了<sup><a href="#fn_5" id="reffn_5">5</a></sup>的结论，该结论指出语言可以被视为一种信号，与其他语言没有任何区别。</p>
<p>需要注意的是，本文的主要目的是显示本文编码方法难道可行性，而不是产生更好的结果。因此，我们将精力集中在比较研究上。为此，将在自定义神经网络结构上应用我们的编码方法是可能的。我们的结果表明，将其与 LSTM 结合是克服固定矩阵限制的一个可能方向。在不久的未来，我们将专注于设计可能进一步改善结果的新网络结构。</p>
<p>本文研究还未使用其他信息理论的信息表示方法打开了一扇门。创建文本的数字表示。必须概述这样一个事实，即文本的这种紧凑的数字表示形式不限于 CNN 或神经网络领域。评估它们的影响作为其他分类算法的预处理步骤（稍作修改后）可能会很有趣。</p>
<h2 id="REFERENCES"><a href="#REFERENCES" class="headerlink" title="REFERENCES"></a>REFERENCES</h2><blockquote id="fn_1">
<sup>1</sup>. F. Sebastiani, “Machine learning in automated text categorization,” ACM Computing Surveys, vol. 34, no. 1, pp. 1–47, Mar. 2002. [Online]. Available: <a href="http://doi.acm.org/10.1145/505282.505283">http://doi.acm.org/10.1145/505282.505283</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. C. C. Aggarwal and C. X. Zhai, “A survey of text classification algorithms,” in Mining Text Data, C. C. Aggarwal and C. X. Zhai, Eds. Springer US, 2012, pp. 163–222. [Online]. Available: <a href="http://dx.doi.org/10.1007/978-1-4614-3223-4">http://dx.doi.org/10.1007/978-1-4614-3223-4</a> 6<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_3">
<sup>3</sup>. A. Hotho, A. Nrnberger, and G. Paa, “A brief survey of text mining,” LDV Forum - GLDV Journal for Computational Linguistics and Language Technology, vol. 20, no. 1, pp. 19–62, May 2005. [Online]. Available: <a href="http://www.kde.cs.uni-kassel.de/hotho/pub/2005/hotho05TextMining.pdf">http://www.kde.cs.uni-kassel.de/hotho/pub/2005/hotho05TextMining.pdf</a><a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_4">
<sup>4</sup>. R. Kosala and H. Blockeel, “Web mining research: a survey,” SIGKDD Explor. Newsl., vol. 2, no. 1, pp. 1–15, June 2000. [Online]. Available: <a href="http://dx.doi.org/10.1145/360402.360406">http://dx.doi.org/10.1145/360402.360406</a><a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_5">
<sup>5</sup>. X. Zhang, J. Zhao, and Y. LeCun, “Character-level convolutional networks for text classification,” in Advances in neural information processing systems, 2015, pp. 649–657.<a href="#reffn_5" title="Jump back to footnote [5] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_6">
<sup>6</sup>. I. Goodfellow, Y. Bengio, and A. Courville, Deep Learning. MIT Press, 2016, <a href="http://www.deeplearningbook.org">http://www.deeplearningbook.org</a>.<a href="#reffn_6" title="Jump back to footnote [6] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_7">
<sup>7</sup>. Y. LeCun, L. Bottou, Y. Bengio, and P. Haffner, “Gradient-based learning applied to document recognition,” in Proceedings of the IEEE, 1998, pp. 2278–2324.<a href="#reffn_7" title="Jump back to footnote [7] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_8">
<sup>8</sup>. J. Bergstra, O. Breuleux, F. Bastien, P. Lamblin, R. Pascanu, G. Des-jardins, J. Turian, D. Warde-Farley, and Y. Bengio, “Theano: a CPU and GPU math expression compiler,” in Proceedings of the Python for Scientific Computing Conference (SciPy), Jun. 2010, oral Presentation.<a href="#reffn_8" title="Jump back to footnote [8] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_9">
<sup>9</sup>. M. Abadi, A. Agarwal, P. Barham, E. Brevdo, Z. Chen, C. Citro, G. S. Corrado, A. Davis, J. Dean, M. Devin, S. Ghemawat, I. Goodfellow, A. Harp, G. Irving, M. Isard, Y. Jia, R. Jozefowicz, L. Kaiser, M. Kudlur, J. Levenberg, D. Mané, R. Monga, S. Moore, D. Murray, C. Olah, M. Schuster, J. Shlens, B. Steiner, I. Sutskever, K. Talwar, P. Tucker, V. Vanhoucke, V. Vasudevan, F. Viégas, O. Vinyals, P. Warden, M. Wattenberg, M. Wicke, Y. Yu, and X. Zheng, “TensorFlow: Large-scale machine learning on heterogeneous systems,” 2015, software available from tensorflow.org. [Online]. Available: <a href="https://www.tensorflow.org/">https://www.tensorflow.org/</a><a href="#reffn_9" title="Jump back to footnote [9] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_10">
<sup>10</sup>. F. Chollet et al., “Keras,” <a href="https://github.com/fchollet/keras">https://github.com/fchollet/keras</a>, 2015.<a href="#reffn_10" title="Jump back to footnote [10] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_11">
<sup>11</sup>. S. Mittal and J. S. Vetter, “A survey of CPU-GPU heterogeneous computing techniques,” ACM Computing Surveys, vol. 47, no. 4, pp. 69:1–69:35, Jul. 2015. [Online]. Available: <a href="http://doi.acm.org/10.1145/2788396">http://doi.acm.org/10.1145/2788396</a><a href="#reffn_11" title="Jump back to footnote [11] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_12">
<sup>12</sup>. A. Krizhevsky, I. Sutskever, and G. E. Hinton, “Imagenet classification with deep convolutional neural networks,” in Advances in Neural Information Processing Systems (NIPS), 2012, pp. 1097–1105.<a href="#reffn_12" title="Jump back to footnote [12] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_13">
<sup>13</sup>. G. Salton and M. McGill, Introduction to Modern Information Retrieval. New York, NY, USA: McGraw-Hill, 1983.<a href="#reffn_13" title="Jump back to footnote [13] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_14">
<sup>14</sup>. T. Mikolov, I. Sutskever, K. Chen, G. S. Corrado, and J. Dean, “Distributed representations of words and phrases and their compositionality,” in Advances in Neural Information Processing Systems (NIPS), 2013, pp. 3111–3119.<a href="#reffn_14" title="Jump back to footnote [14] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_15">
<sup>15</sup>. Y. Xiao and K. Cho, “Efficient character-level document classification by combining convolution and recurrent layers,” CoRR, vol. abs/1602.00367, 2016. [Online]. Available: <a href="http://arxiv.org/abs/1602.00367">http://arxiv.org/abs/1602.00367</a><a href="#reffn_15" title="Jump back to footnote [15] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_16">
<sup>16</sup>. S. Hochreiter and J. Schmidhuber, “Long short-term memory,” Neural computation, vol. 9, no. 8, pp. 1735–1780, 1997.<a href="#reffn_16" title="Jump back to footnote [16] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_17">
<sup>17</sup>. P. Blunsom, K. Cho, C. Dyer, and H. Schütze, “From characters to understanding natural language (C2NLU): Robust end-to-end deep learning for NLP (Dagstuhl Seminar 17042),” Dagstuhl Reports, vol. 7, no. 1, pp. 129–157, 2017. [Online]. Available: <a href="http://drops.dagstuhl.de/opus/volltexte/2017/7248">http://drops.dagstuhl.de/opus/volltexte/2017/7248</a><a href="#reffn_17" title="Jump back to footnote [17] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_18">
<sup>18</sup>. E. Silva de Moura, G. Navarro, N. Ziviani, and R. Baeza-Yates, “Fast and flexible word searching on compressed text,” ACM Trans. Inf. Syst., vol. 18, no. 2, pp. 113–139, Apr. 2000. [Online]. Available: <a href="http://doi.acm.org/10.1145/348751.348754">http://doi.acm.org/10.1145/348751.348754</a><a href="#reffn_18" title="Jump back to footnote [18] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_19">
<sup>19</sup>. S. Chetlur, C. Woolley, P. Vandermersch, J. Cohen, J. Tran, B. Catanzaro, and E. Shelhamer, “cudnn: Efficient primitives for deep learning,” CoRR, vol. abs/1410.0759, 2014. [Online]. Available: <a href="http://arxiv.org/abs/1410.0759">http://arxiv.org/abs/1410.0759</a><a href="#reffn_19" title="Jump back to footnote [19] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_20">
<sup>20</sup>. D. Harris and S. Harris, Digital design and computer architecture, 2nd ed. San Francisco, CA, USA: Morgan Kaufmann, 2012.<a href="#reffn_20" title="Jump back to footnote [20] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_21">
<sup>21</sup>. D. A. Huffman, “A method for the construction of minimum-redundancy codes,” Proceedings of the Institute of Radio Engineers, vol. 40, no. 9, pp. 1098–1101, September 1952.<a href="#reffn_21" title="Jump back to footnote [21] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_22">
<sup>22</sup>. N. Brisaboa, E. Iglesias, G. Navarro, and J. Paramá, “An efficient compression code for text databases,” Advances in Information Retrieval, pp. 78–78, 2003.<a href="#reffn_22" title="Jump back to footnote [22] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_23">
<sup>23</sup>. Y. Kim, “Convolutional neural networks for sentence classification,” CoRR, vol. abs/1408.5882, 2014. [Online]. Available: <a href="http://arxiv.org/abs/1408.5882">http://arxiv.org/abs/1408.5882</a><a href="#reffn_23" title="Jump back to footnote [23] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_24">
<sup>24</sup>. Y. Zhang and B. C. Wallace, “A sensitivity analysis of (and practitioners’ guide to) convolutional neural networks for sentence classification,” CoRR, vol. abs/1510.03820, 2015. [Online]. Available: <a href="http://arxiv.org/abs/1510.03820">http://arxiv.org/abs/1510.03820</a><a href="#reffn_24" title="Jump back to footnote [24] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_25">
<sup>25</sup>. X. Zhang and Y. LeCun, “Text understanding from scratch,” arXiv preprint arXiv:1502.01710, 2015.<a href="#reffn_25" title="Jump back to footnote [25] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_26">
<sup>26</sup>. N. Srivastava, G. Hinton, A. Krizhevsky, I. Sutskever, and R. Salakhutdinov, “Dropout: A simple way to prevent neural networks from overfitting,” Journal of Machine Learning Research, vol. 15, pp. 1929–1958, 2014. [Online]. Available: <a href="http://jmlr.org/papers/v15/srivastava14a.html">http://jmlr.org/papers/v15/srivastava14a.html</a><a href="#reffn_26" title="Jump back to footnote [26] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_27">
<sup>27</sup>. J. Lehmann, R. Isele, M. Jakob, A. Jentzsch, D. Kontokostas, P. N. Mendes, S. Hellmann, M. Morsey, P. van Kleef, S. Auer, and C. Bizer, “DBpedia - a large-scale, multilingual knowledge base extracted from wikipedia,” Semantic Web Journal, vol. 6, no. 2, pp. 167–195, 2015. [Online]. Available: <a href="http://jens-lehmann.org/files/2015/swj">http://jens-lehmann.org/files/2015/swj</a> dbpedia.pdf<a href="#reffn_27" title="Jump back to footnote [27] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_28">
<sup>28</sup>. J. McAuley and J. Leskovec, “Hidden factors and hidden topics: Understanding rating dimensions with review text,” in Proceedings of the 7th ACM Conference on Recommender Systems, ser. RecSys ’13. New York, NY, USA: ACM, 2013, pp. 165–172. [Online]. Available:<a href="http://doi.acm.org/10.1145/2507157.2507163">http://doi.acm.org/10.1145/2507157.2507163</a><a href="#reffn_28" title="Jump back to footnote [28] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_29">
<sup>29</sup>. M. D. Zeiler, “ADADELTA: An adaptive learning rate method,” CoRR, vol. abs/1212.5701, 2012. [Online]. Available: <a href="http://dblp.uni-trier.de/db/journals/corr/corr1212.html#abs-1212-5701">http://dblp.uni-trier.de/db/journals/corr/corr1212.html#abs-1212-5701</a><a href="#reffn_29" title="Jump back to footnote [29] in the text."> &#8617;</a>
</blockquote>
]]></content>
      <categories>
        <category>dissertation</category>
      </categories>
      <tags>
        <tag>paper translation</tag>
      </tags>
  </entry>
  <entry>
    <title>A Polynomial Algorithm for Testing Diagnosability of Discrete-Event Systems.</title>
    <url>/posts/c598fb85/</url>
    <content><![CDATA[<blockquote>
<p>文献翻译：一个测试离散事件系统可诊断性的多项式时间算法<br>authors: Shengbing Jiang, Zhongdong Huang, Vigyan Chandra, and Ratnesh Kumar<br>原文: <a href="https://ieeexplore.ieee.org/document/940942">A polynomial algorithm for testing diagnosability of discrete-event systems</a></p>
</blockquote>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>&emsp;&emsp;大型复杂系统中的错误诊断是一项关键任务。在离散事件系统（DES）领域，Sampath 等人提出了一种基于语言的错误诊断方法。他们为DES引入可诊断性概念和定义，并使用根据系统构建的诊断器来测试系统的可诊断性。这种测试可诊断性的方法的复杂度是系统状态数的指数级别的，对于系统错误数量是双倍指数级别的。本文给出一种不构建系统诊断器的可诊断性测试算法，其复杂度在系统状态数上是四阶的，在故障类型数上是线性的。</p>
<p>Index Terms: Complexity, diagnosability, discrete event system, failure diagnosis.</p>
<span id="more"></span>
<h2 id="I-INTRODUCTION"><a href="#I-INTRODUCTION" class="headerlink" title="I. INTRODUCTION"></a>I. INTRODUCTION</h2><p>&emsp;&emsp;错误诊断是大型复杂系统的一项关键任务。这个问题在包括离散事件系统<sup><a href="#fn_1" id="reffn_1">1</a></sup><sup><a href="#fn_2" id="reffn_2">2</a></sup><sup><a href="#fn_3" id="reffn_3">3</a></sup><sup><a href="#fn_4" id="reffn_4">4</a></sup><sup><a href="#fn_5" id="reffn_5">5</a></sup><sup><a href="#fn_6" id="reffn_6">6</a></sup>在内的各个领域的文献中都得到了相当多的关注。在<sup><a href="#fn_4" id="reffn_4">4</a></sup>中，Sampath等人提出了一种离散事件系统的错误诊断方法。他们提出了可诊断性的概念，并给出了测试可诊断性的充分必要条件。他们将条件表示为诊断器的一个属性。为了测试系统可诊断性，首先需要构造诊断器。构造诊断器和测试可诊断性的复杂度是系统状态数的指数级别的，对于错误事件数是双倍指数级别的。</p>
<p>&emsp;&emsp;显然，如果我们能够不构建诊断器的情况下，来测试目标系统的可诊断性，那么我们将可以节省为不可诊断系统构建诊断器的时间。在本文中，我们给出一种无需构造诊断器即可测试可诊断性的方法。该方法的复杂度是系统状态数量和错误事件数量的多项式。接下来，我们首先介绍离散事件系统的可诊断性概念，然后介绍我们的测试算法，最后，给出一个说明性的例子。</p>
<h2 id="II-DIAGNOSABILITY"><a href="#II-DIAGNOSABILITY" class="headerlink" title="II. DIAGNOSABILITY"></a>II. DIAGNOSABILITY</h2><p>我们首先给出系统模型，然后介绍由<sup><a href="#fn_4" id="reffn_4">4</a></sup>提出的可诊断性定义。</p>
<h3 id="A-System-model"><a href="#A-System-model" class="headerlink" title="A. System model"></a>A. System model</h3><p>&emsp;&emsp;令$G = (X,\Sigma,\delta,x_0)$是待诊断系统的有限状态机模型，其中</p>
<ul>
<li>$X$                         是一个状态有限集</li>
<li>$\Sigma$                          是一个事件标签的有限集</li>
<li>$\delta\subseteq X\times\Sigma\times X$ 是状态转移有限集</li>
<li>$x_0\in X$                是系统的初始状态</li>
</ul>
<p>我们假设所有状态自动机是可达的（accessible，所有状态可以从初始状态出发，经若干转移后到达），否则我们只考虑状态自动机中的可达部分。<br>我们用<script type="math/tex">\Sigma^*</script>表示包含所有有限长度事件序列的集合，其中包括空序<script type="math/tex">\varepsilon</script>。把<script type="math/tex">\Sigma^*</script>集合中的一个元素称为串（trace），用<script type="math/tex">\Sigma^*</script>的子集表示语言（language）。<br>对于一个串<script type="math/tex">s</script>和事件<script type="math/tex">\sigma</script>，我们用<script type="math/tex">\sigma\in s</script>表示事件<script type="math/tex">\sigma</script>包含于串<script type="math/tex">s</script>中，即串<script type="math/tex">s</script>发生了事件<script type="math/tex">\sigma</script>。系统<script type="math/tex">G</script>中的一个路径（path）是一个状态转移序列<script type="math/tex">(x_1,\delta_1,x_2,....,\delta_{n-1},x_n)</script>，其中对于每个<script type="math/tex">i\in \{1,...,n-1\},(x_i,\delta_i,x_{i+1})\in \delta</script>，如果<script type="math/tex">x_n=x_1</script>，则表示该路径是一个环（cycle）。我们用<script type="math/tex">L(G)\subseteq\Sigma^*</script>来描述系统<script type="math/tex">G</script>的生成语言，即系统<script type="math/tex">G</script>从初始状态开始能够执行的串的集合。同时假设<script type="math/tex">L(G)</script>是前缀闭合（prefix-closed）的，即<script type="math/tex">L(G)=pr(L(G))</script>，其中<script type="math/tex">pr(L(G))=\{u|\exists v\in\Sigma^*, uv\in L(G)\}</script>是一个由所有<script type="math/tex">L(G)</script>中的串的前缀组成的集合。用<script type="math/tex">\Sigma_o\subseteq\Sigma</script>表示系统的可观事件集，<script type="math/tex">\Sigma_{uo}=\Sigma - \Sigma_o</script>表示不可观事件集，<script type="math/tex">M:\Sigma\to \Sigma_o\cup \{\varepsilon\}</script>表示一个观察映射函数，<script type="math/tex">F={F_i,i=1,2,...,m}</script>表示错误类型的集合，<script type="math/tex">\psi:\Sigma\to F\cup\{\emptyset\}</script>表示一个为<script type="math/tex">\Sigma</script>中每个事件错误分配的函数（failure assignment function）。$M$的定义通常从$\Sigma$扩展到<script type="math/tex">\Sigma^*</script>，如下所示：$M(\varepsilon)=\varepsilon$，并且对于每一个串<script type="math/tex">s\in \Sigma^*, \sigma\in\Sigma:M(s\sigma)=M(s)M(\sigma)</script>。</p>
<p>对于本文研究的系统，和<sup><a href="#fn_4" id="reffn_4">4</a></sup>一样，我们作出以下假设：</p>
<ul>
<li>A1) 系统$G$的生成语言是活语言（live language）。这意味着系统中的每一个状态均定义相应的状态转移。</li>
<li>A2) 系统$G$中不存在不可观事件的环。</li>
<li>A3) 所有错误事件均是不可观的，即$(\forall\sigma\in\Sigma,\psi(\sigma)\neq\emptyset)\Rightarrow M(\sigma)=\varepsilon$。</li>
</ul>
<h3 id="B-Diagnosability"><a href="#B-Diagnosability" class="headerlink" title="B. Diagnosability"></a>B. Diagnosability</h3><p>离散事件系统的可诊断性<sup><a href="#fn_4" id="reffn_4">4</a></sup>定义描述如下：</p>
<p><strong>Definition 1:</strong> 一个前缀封闭语言$L$关于观察映射$M$和错误分配函数$\psi$是可诊断的当：</p>
<script type="math/tex; mode=display">
(\forall F_i\in F)(\exists n_i\in N)(\forall s\in L, \psi(s_f)=F_i) \\
(\forall v = st \in L, \lVert t\rVert \ge n_i) \\
\Rightarrow(\forall w\in L, M(w)=M(v))(\exists u\in pr(\{w\}),\psi(u_f)=F_i)</script><p>其中$s_f$和$u_f$分别表示串$s$和串$u$的最后一个事件，$pr({w})$是$w$所有前缀组成的集合。如果系统$G$的生成语言$L(G)$是可诊断的，则该系统是可诊断的。</p>
<p>根据上面定义，若$s$是$L$中一个以$F_i$错误事件结尾的串，$v$是$s$的任意一个充分长后缀，则任意一个$L$中与$v$拥有相同观察序列的的串$w$，即$M(w)=M(v)$，串$w$中一定包含错误事件$F_i$。</p>
<h2 id="III-ALGORITHM"><a href="#III-ALGORITHM" class="headerlink" title="III. ALGORITHM"></a>III. ALGORITHM</h2><p>我们现在展示测试可诊断性的算法。</p>
<p><strong>Algorithm 1:</strong> 对于给定系统$G=(X,\Sigma, \delta, x_0)$，一个观察映射$M$和一个错误分配函数$\psi$，做以下操作：</p>
<ul>
<li>1) 获取一个非确定有限状态自动机（nondeterministic finite-state machine）$G_o = (X_o,\Sigma_o,\delta_o,x^o_0)$，其中语言$L(G_o)=M(L(G))$：<ul>
<li>$X_o = {(x,f)|x\in X_1\cup{x_0},f\subseteq F}$是自动机的有限状态集，其中$X_1={x\in X|\exists(x’,\sigma,x)\in\delta 且 M(\sigma)\neq\varepsilon}$是$G$能通过可观序列转移到达的状态组成的集合，$f$是一个从$x_0$到$x$的路径的错误类型。</li>
<li>$\Sigma_o$是可观事件集，$G_o$的事件标签集合。</li>
<li>$\delta_o\subseteq X_o\times\Sigma_o\times X_o$是状态转移集。$((x,f),\delta,(x’,f’))\in \delta_o$当且仅当对于$\forall i \in {1,2,…,n}, M(\sigma_i)=\varepsilon, M(\sigma)=\sigma$且$f’={\psi(\sigma_i)|\psi(\sigma_i)\neq\emptyset, 1\leq i\leq n}\cup f$，系统$G$中存在这样一个路径$(x,\sigma_1,x_1,…,\sigma_n,x_n,\sigma,x’)(n\geq 0)$。</li>
<li>$x^o_0=(x_0,\emptyset)\in X_o$是$G_o$的初始状态。</li>
</ul>
</li>
<li>2) 计算$G_d=(G_o||G_o)$，即$G_o$与其自身的严格组合（composition）计算。$G_o=(X_d,\Sigma_o,\delta_d,x^d_0)$，其中<ul>
<li>$X_d={(x^o_1,x^o_2)|x^o_1,x^o_2\in X_o}$ 是状态集；</li>
<li>$\Sigma_o$是$G_d$的事件标签集；</li>
<li>$\delta_d\subseteq X_d\times\Sigma_o\times X_d$是状态转移集。$((x^o_1,x^o_2),\delta,(y^o_1,y^o_2))\in \delta_d$当且仅当$(x^o_1,\sigma, y^o_2)$和$(x^o_2,\sigma,y^o_2)$均包含于$\delta_o$中；</li>
<li>$x^d_0$是$G_d$的初始状态。</li>
</ul>
</li>
<li>3) 检查$G_d$中是否存在这样一个环$cl = (x_1,\sigma_1,x_2, …, x_n, \sigma_n, x_1), n\geq 1, x_i = ((x^1_i, f^1_i),(x^2_i,f^2_i)), i = 1, 2, …, n$, 使得 $f^1_1\neq f^2_1$。如果存在，则输出该系统是不可诊断的，最后这一步骤可以先标识$G_d$中的状态$((x^1,f^1),(x^2,f^2))$，其中$f^1\neq f^2$，然后删除其他所有状态以及相关的转移，判断剩余的图中是否存在环即可得到结果。</li>
</ul>
<p>接下来，我们给出两个定理，展示<strong>Algorithm 1</strong> 中状态机$G_o$和$G_d$的一些属性。这里省略了证明，因为它们可以直接遵循$G_o$和$G_d$的定义得到。</p>
<p><strong>Lemma 1:</strong> 对于状态机$G_o$：</p>
<ul>
<li>1) $L(G_o) = M(L(G))$；</li>
<li>2) 对于$G_o$中每一个作为环的路径$tr$：<script type="math/tex; mode=display">
tr = ((x_0,\emptyset), \sigma_0, (x_1,f_1), ..., (x_k,f_k), \\
\sigma_k, ..., (x_n,f_n), \sigma_n, (x_k,f_k))</script></li>
</ul>
<p>我们有</p>
<ul>
<li>对于任意$i, j\in {k,k+1,…,n}; f_i=f_j$；</li>
<li><script type="math/tex; mode=display">\exists uv^*\in L(G) 使得 M(u) = \sigma_0...\sigma_{k-1},M(v)=\sigma_k...\delta_n; \\ \{\psi(\sigma)|\sigma\in u, \psi(\sigma)\neq\emptyset\}=f_k</script></li>
</ul>
<p><strong>Lemma 2:</strong> 对于$G_d$中每一个作为环的路径$tr$：<script type="math/tex">tr = (x^d_0, \sigma_0,x_1,...,x_k,\sigma_k,...,x_n,\sigma_n,x_k) \\
x_i = ((x^1_i,f^1_i),(x^2_i,f^2_i)), i = 1, 2, ..., n</script>有：</p>
<ul>
<li>1) $G_o$中存在两个作为环的路径 $tr_1$和$tr_2$：<script type="math/tex; mode=display">
tr_1 = ((x_0,\emptyset), \sigma_0, (x^1_1,f^1_1),...,(x^1_k,f^1_k),\\
\sigma_k, ..., (x^1_n,f^1_n),\sigma_n, (x^1_k,f^1_k))\\
tr_2 = ((x_0,\emptyset), \sigma_0, (x^2_1,f^2_1),...,(x^2_k,f^2_k),\\
\sigma_k, ..., (x^2_n, f^2_n), \sigma_n, (x^2_k, f^2_k)).</script></li>
<li>2) 对于任意$i, j \in{k, k+1, …, n}$, 有$(f^1_i=f^1_j) \land (f^2_i=f^2_j)$。</li>
</ul>
<p>接着，我们再提供一个定理确保<strong>Algorithm 1</strong>的正确性。</p>
<p><strong>Theorem 1</strong>: $G$ 是可诊断的当且仅当$G_d$中的每一个环$cl$：</p>
<script type="math/tex; mode=display">
cl = (x_1,\sigma_1,x_2,...,x_n,\sigma_n,x_1),\qquad n\geq 1 \\
x_i = ((x^1_i,f^1), (x^2_i,f^2)),\qquad i=1,2,...,n</script><p>我们有$f^1=f^2$。</p>
<p><strong>Proof</strong>: 对于必要性，假设$G$是可诊断的，但<script type="math/tex">G_d</script>中存在一个环$cl$，<script type="math/tex">cl=(x_k,\sigma_k,x_{k+1},...,x_n,\sigma_n,x_K), n\geq k, x_i=((x^1_i,f^1),(x^2_i,f^2)), i = k, k+1,...,x_n</script>使得$f^1\neq f^2$。因为$G_d$是可达的，$G_d$中存在一个以环$cl$结尾的路径$tr$，即$tr = (x^d_0,\sigma_0,x_1,…,x_k,\sigma_k,…,x_n,\sigma_n,x_k)$。据<strong>Lemma 2</strong>，$G_o$中存在两个路径$tr_1$和$tr_2$：</p>
<script type="math/tex; mode=display">
tr_1 = ((x_0,\emptyset),\sigma_0,(x^1_1,f^1_1),...,(x^1_k,f^1),\\
\sigma_k,...,(x^1_n,f^1),\sigma_n,(x^1_k,f^1))\\
tr_2 = ((x_0,\emptyset),\sigma_0,(x^2_1,f^2_1),...,(x^2_k,f^2),\\
\sigma_k,...,(x^2_n,f^2),\sigma_n,(x^2_k,f^2))\\</script><p>更多地，根据<strong>Lemma 1</strong>，我们可得<script type="math/tex">\exists u_1v^*_1\in L(G)</script>使得<script type="math/tex">M(u_1)=M(u_2) = \sigma_0...\sigma_{k-1}, M(v_1)=M(v_2)=\sigma_k...\sigma_n</script> 并且<script type="math/tex">\{\psi(\sigma)|\sigma\in u_i, \psi(\sigma)\neq \emptyset\}=\{\psi(\sigma)|\sigma\in u_iv_i,\psi(\sigma)\neq \emptyset\}=f^i, i = 1,2</script>。因为$f^1\neq f^2$，我们假设$F_k\in f^1 - f^2\neq \emptyset$。然后$\exists s\in L(G)$使得 $\psi(s_f)=F_k$ 且对于某些<script type="math/tex">t\in \Sigma^*; u_1\in st</script>。对于任意整数$n_k$，我们可以选择另一个整数$l$，使得$\lVert tv^l_1\rVert &gt;n_k$。<br>则有$M(u_2,v^l_2)=M(stv^l_1)$并且<script type="math/tex">\{\psi(\sigma)|\sigma\in u_2v_2, \psi(\sigma)\neq \emptyset\}=f^2</script>，这意味着$u_2v^l_2$中不包含任何类型为$F_k$对应的错误事件。因此，根据可诊断性的定义，系统$G$是不可诊断的。与假设矛盾，所以必要性成立。</p>
<p>对于充分性，假设$G_d$中的每一个环$cl$，$cl = (x_1,\sigma_1,x_2,…,x_n,\sigma_n,x_1), n\geq 1, x_i=((x^1_i,f^1),(x^2_i,f^2)), i = 1, 2, …, n$, 我们有$f^1=f^2$。<br>根据<strong>Lemma 2</strong>的第二句，我们知道该假设意味着$\forall x = ((x^1,f^1),(x^2,f^2)) \in X_d, if f^1\neq f^2$，则$x$不包含于一个循环中。更进一步地，对于$x_i=(x^1_i,f^1_i),(x^2_i,f^2), 1 \leq i\geq k$, $G_d$中的任意状态序列$(x_1,x_2,…,x_k)$，如果对于$\forall i\in {1,2,…,k}$有$f^1_i\neq f^2_i$，则状态序列的长度限制在$G_d$状态数之内，即$k\leq |X_d|$。</p>
<p>现在，令$s$是$L(G)$中以$F_k$类型错误事件结尾的串，即$\psi(s_f)=F_k$，我们称对于$\lVert t\rVert &gt; |X_d|\times(|X|-1), \forall w\in L(G), M(w)=M(v)$， $\forall v=st\in L(G)$, 则$w$中包含$F_k$类型的错误事件。综上，对于任何从$x^d_0$出发通过执行$G_d$中$M(s)$到达的状态$x\in X_d$，有对于$G_d$中任意从$x$开始的状态序列，一个状态$y = ((y^1,f^1),(y^2,f^2))\in X_d, \land f^1=f^2$可以在$|X_d|-1$步之内到达。这意味着$\forall v = st \in L(G) \land \lVert M(t)\rVert &gt; |X_d|, \forall w \in L(G) \land M(w)=M(v)$，$w$中必定包含$F_k$类型的错误事件。进一步假设$G$中不存在不可观环，任何$M(t)$中的可观事件最多可在$|X|-1$个不可观事件之后被跟踪到。因此，对于上面的串$t$，$\lVert t\rVert \leq ((\lVert M(t)\rVert + 1) \times (|X|-1)$，即$\lVert M(t)\rVert \geq \lVert t\rVert / (|X|-1)-1$。所以如果$\lVert t\rVert &gt; |X_d|\times(|X|-1)$，则$\lVert M(t)\rVert\geq \lVert t\rVert/(|X|-1)-1 &gt; (|X_d|\times(|X|-1))/(|X|-1)-1 = |X_d|-1$，确立我们的主张（注意，我们隐式地假设$|X|&gt;1$；否则如果$|X|=1$，根据不存在不可观环的假设，将不存在任何使用错误标签的转移，系统显然是可诊断的）。根据<strong>Lemma 1</strong>，系统$G$是可诊断的，充分性也证明完毕。</p>
<p><strong>Remark 1</strong>: 根据<strong>Algorithm 1</strong>，我们知道$G_o$中的状态数是$|X|\times 2^{|F|}$，$G_o$中的转移数是$|X|^2\times 2^{2|F|}\times|\Sigma_o|$。因为$G_d = G_o||G_o$，$G_d$中的状态数为$|X|^2\times 2^{2|F|}$，$G_d$中的转移数为$|X|^4\times 2^{4|F|}\times|\Sigma_o|$。</p>
<p><strong>Algorithm 1</strong>的第一步，构造$G_o$的复杂度为$O(|X|^2\times 2^{2|F|}$， 而<strong>Algorithm 1</strong>的第二步，构造$G_d$的复杂度为$O(|X|^4\times 2^{4|F|}\times|\Sigma_o|)$。执行<strong>Algorithm 1</strong>的第三步，它适当地修剪$G_d$中检测到的“违规”环的的存在，与状态数和转移数是呈线性关系的，即$O(|X|^4\times 2^{4|F|})$。注意当移除所有不符合规则的环后，转移标签将是不相关的。</p>
<p>所以<strong>Algorithm 1</strong>的复杂度是$O(|X|^4\times 2^{4|F|}\times|\Sigma_o|)$，它是$G$中状态数的多项式级别和$G$中错误类型数的指数级别。</p>
<p>在<sup><a href="#fn_4" id="reffn_4">4</a></sup>中，提供了另一个可诊断性的充分必要条件。该条件被表示为系统诊断器的一个属性。所以为了测试可诊断性，我们必须先构造目标系统的诊断器，然后检查诊断器的属性。其中构造诊断器和检查诊断器属性的复杂度都是系统状态数的指数级别和错误类型数的双倍指数级别。在<strong>Algorithm 1</strong>中，测试系统的可诊断性不需要构造诊断器。</p>
<p><strong>Remark 2</strong>: 测试可诊断性的复杂度对于错误类型数量可以是多项式级别的，对于一个拥有错误类型$F = {F_i, i = 1, 2, …, m}$的系统是可诊断的，当且仅当系统的每一个错误类型$F_i, i = 1, 2, …,m$都是可诊断的。换句话说，对于每个单独的错误类型集${F_1}, …, {F_m}$应用<strong>Algorithm 1</strong> $m$ 次。因为每一个错误类型集中只包含一个错误类型，根据<strong>Remark 1</strong>，可知每一次测试的复杂度为$O(|X|^4\times 2^{4|1|}\times|\Sigma_o|) = O(|X|^4\times|\Sigma_o|)$。因此，总的测试复杂度为$O(|X|^4\times|\Sigma_o|\times|F|)$。</p>
<div align="center" style="display: flex; flex-direction:column;">
    <img data-src="diagram-of-system-G.png"/>
    <span>Fig. 1. Diagram of system G.</span>
</div>

<p><strong>Example 1</strong>: 考虑一个系统 $G = (X, \Sigma, \delta, x_0)$</p>
<ul>
<li><script type="math/tex; mode=display">X = \{x_0, x_1, x_2, x_3, x_4\}</script></li>
<li><script type="math/tex; mode=display">\Sigma = \{\sigma_1, \sigma_2, \sigma_3, \sigma_{uo}, \sigma_{f1},\sigma_{f2},\sigma_{f3}\}</script></li>
<li><script type="math/tex; mode=display">\{(x_0,\sigma_1,x_1), (x_1,\sigma_{f1},x_2), (x_1, \sigma_{uo}, x_2), (x_2, \sigma_{f2}, x_3), (x_3, \sigma_2, x_3), (x_2, \sigma_{f1}, x_4), (x_4, \sigma_3, x_4)\}</script></li>
</ul>
<p>并拥有可观事件集<script type="math/tex">\Sigma_o = \{\sigma_1, \sigma_2, \sigma_3\}</script>。系统见图<em>Fig. 1</em>。令<script type="math/tex">F = \{F_1, F_2\}</script>作为错误类型集，$\psi$是一个错误分配函数， <script type="math/tex">\psi(\sigma_{uo}) = \psi(\sigma_i) = \emptyset, i = 1, 2, 3, \psi(\sigma_{f1}) = F_1, \psi(\sigma_{f2})=F_2</script>。根据<strong>Algorithm 1</strong>的第一步，我们可以从$G$来获取$G_o$，见<em>Fig. 2</em>。<strong>Algorithm 1</strong>的第二步，计算$G_o$和其自身的严格组合，$G_d = G_o||G_o$，见<em>Fig. 3</em>。在<em>Fig. 3</em>中，在$((x_3,{F_2}), (x_3, {F_1,F_2}$上存在一个自环。所以，根据<strong>Algorithm 1</strong>的最后一步，我们知道该系统$G$是不可诊断的。</p>
<div align="center" style="display: flex; flex-direction:column;">
    <img data-src="diagram-of-system-G_o.png"/>
    <span>Fig. 2. Diagram of system Go.</span>
</div>

<div align="center" style="display: flex; flex-direction:column;">
    <img data-src="diagram-of-system-G_d.png"/>
    <span>Fig. 3. Diagram of system Gd.</span>
</div>

<p>现在，我们假设不区分错误类型$F_1$和$F_2$，即令<strong>Fig. 3</strong>中$F_2 = F_1$并删除一些冗余的状态，我们计算修改后系统对应的$G_d$，这里忽略了该结果。在修改后的$G_d$中，不存在任何违反<strong>Algorithm 1</strong>中第三步规则的环。因此，修改后的系统是可诊断的。</p>
<h2 id="IV-CONCLUSION"><a href="#IV-CONCLUSION" class="headerlink" title="IV. CONCLUSION"></a>IV. CONCLUSION</h2><p>在本文中，我们提供了一个测试离散事件系统可诊断性的算法。与<sup><a href="#fn_4" id="reffn_4">4</a></sup>中的测试方法相比，我们的算法无需为待诊断系统构造诊断器。我们算法的复杂度是系统状态数的四阶和错误类型数的线性阶。而<sup><a href="#fn_4" id="reffn_4">4</a></sup>中测试方法的复杂度是系统状态数的指数阶和错误类型数的双倍指数阶。</p>
<blockquote id="fn_1">
<sup>1</sup>. Chen, Yi-Liang, and Gregory Provan. “Modeling and diagnosis of timed discrete event systems-a factory automation example.” Proceedings of the 1997 American Control Conference (Cat. No. 97CH36041). Vol. 1. IEEE, 1997.<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. L. Holloway and S. Chand, “Time templates for discrete event fault monitoring in manufacturing systems,” in Proc. 1994 Amer. Control Conf.,1994, pp. 701–706.<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_3">
<sup>3</sup>. F. Lin, “Diagnosability of discrete-event systems and its applications,” J. Discrete Event Dyn. Syst.: Theory Appl., vol. 4, no. 2, pp. 197–212, May 1994.<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_4">
<sup>4</sup>. M. Sampath, R. Sengupta, S. Lafortune, K. Sinnamohideen, and D. Teneketzis, “Diagnosability of discrete-event systems,” IEEE Trans. Automat. Contr., vol. 40, pp. 1555–1575, Sept. 1995.<a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_5">
<sup>5</sup>. S. H. Zad, R. H. Kwong, and W. M. Wonham, “Fault diagnosis in timed discrete-event systems,” in Proc. 38th IEEE Conf. Decision Control, Phoenix, AZ, Dec. 1999, pp. 1756–1761.<a href="#reffn_5" title="Jump back to footnote [5] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_6">
<sup>6</sup>. G. Westerman, R. Kumar, C. Stroud, and J. R. Heath, “Discrete-event systems approach for delay fault analysis in digital circuits,” in Proc. 1998 Amer. Control Conf., Philadelphia, PA, 1998.<a href="#reffn_6" title="Jump back to footnote [6] in the text."> &#8617;</a>
</blockquote>
]]></content>
      <categories>
        <category>dissertation</category>
      </categories>
      <tags>
        <tag>paper translation</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7通过yum(yellow dog update modifier) 安装mysql5.7</title>
    <url>/posts/86d29d2c/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="配置yum源"><a href="#配置yum源" class="headerlink" title="配置yum源"></a>配置yum源</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载mysql安装源包</span></span><br><span class="line">root @~&gt; wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm</span><br><span class="line"><span class="comment"># 安装mysql源</span></span><br><span class="line">root @~&gt; yum localinstall mysql57-community-release-el7-8.noarch.rpm</span><br></pre></td></tr></table></figure>
<p>检查mysql源是否安装成功:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root @~&gt; yum repolist enabled | grep <span class="string">&quot;mysql.*-community.*&quot;</span></span><br></pre></td></tr></table></figure>
<p>如下图则安装成功:</p>
<p><img data-src="repo-resource.png" alt="mysql_source"></p>
<h3 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ ~&gt; yum install -y mysql-community-server</span><br></pre></td></tr></table></figure>
<h3 id="启动MySQL服务并设置开机自动启动"><a href="#启动MySQL服务并设置开机自动启动" class="headerlink" title="启动MySQL服务并设置开机自动启动"></a>启动MySQL服务并设置开机自动启动</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ ~&gt; systemctl start mysqld</span><br></pre></td></tr></table></figure>
<p>查看MySQL启动状态</p>
<p><img data-src="mysql-status.png" alt="mysqld进程状态"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ ~&gt; systemctl <span class="built_in">enable</span> mysqld</span><br><span class="line">root@ ~&gt; systemctl daemon-reload</span><br></pre></td></tr></table></figure>
<h3 id="修改默认密码"><a href="#修改默认密码" class="headerlink" title="修改默认密码"></a>修改默认密码</h3><p>刚安装完的mysql会自动给root用户分配一个临时密码，而且必须重新设置密码(从5.5版本开始)</p>
<ul>
<li>先查看root用户的临时密码</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ ~&gt; grep <span class="string">&quot;temporary password&quot;</span> /var/<span class="built_in">log</span>/mysqld.log</span><br></pre></td></tr></table></figure>
<ul>
<li>使用临时的密码登录进mysql来设置新的密码</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> PASSWORD = PASSWORD(<span class="string">&#x27;[YOUR_NEW_PASSWORD]&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img data-src="temporary-password.png" alt="查看临时密码"></p>
<ul>
<li>可能遇到的问题：设置的密码过于简单mysql报错:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Your password does not satisfy the current policy requirements.</span><br></pre></td></tr></table></figure>
<p>解决方法：由于刚安装的mysql的密码默认强度是最高的，若想要设置简单的密码就要修改<strong>validate_password_policy</strong>的值，</p>
<h4 id="validate-password-policy有以下取值："><a href="#validate-password-policy有以下取值：" class="headerlink" title="validate_password_policy有以下取值："></a>validate_password_policy有以下取值：</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Policy</th>
<th style="text-align:center">Tests Performed</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0 or LOW</td>
<td style="text-align:center">Length</td>
</tr>
<tr>
<td style="text-align:center">1 or MEDIUM</td>
<td style="text-align:center">Length;numeric,lowercase/uppercase,and special characters</td>
</tr>
<tr>
<td style="text-align:center">2 or STRONG</td>
<td style="text-align:center">Length;numeric,lowercase/uppercase,and special characters; dictionary file</td>
</tr>
</tbody>
</table>
</div>
<p>操作：</p>
<ul>
<li>设置安全级别</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> global validate_password_policy=0;</span><br></pre></td></tr></table></figure>
<ul>
<li>设置密码长度为8，可以设置为其他值，最小为4位</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> global validate_password_length=4;</span><br></pre></td></tr></table></figure>
<p>之后就可以设置简单的密码了。</p>
<h3 id="允许root远程登录"><a href="#允许root远程登录" class="headerlink" title="允许root远程登录"></a>允许root远程登录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;[YOUR_PASSWORD]&#x27;</span> WITH GRANT OPTION;</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure>
<h3 id="修改字符集编码为UTF-8"><a href="#修改字符集编码为UTF-8" class="headerlink" title="修改字符集编码为UTF-8"></a>修改字符集编码为UTF-8</h3><ul>
<li>查看当前字符编码</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">&quot;char%&#x27;;</span></span><br></pre></td></tr></table></figure>
<p>检测是否都是utf-8(filesystem除外)，如果不是就需要修改。 <strong>character_set_server</strong>一般是lantin1。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 停止mysqld服务</span></span><br><span class="line">systemctl stop mysqld</span><br><span class="line"><span class="comment"># 进入my.cnf文件，一般是/etc/路径下</span></span><br><span class="line">vim /etc/my.cnf</span><br><span class="line"><span class="comment"># 在[mysqld]下追加character-set-server=utf-8</span></span><br><span class="line"><span class="comment"># 在[mysql]下追加default-character-set=utf-8</span></span><br><span class="line"><span class="comment"># 启动mysqld</span></span><br><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql5.7安装</tag>
      </tags>
  </entry>
  <entry>
    <title>Character-level Convolutional Networks for Text Classification</title>
    <url>/posts/1b531d86/</url>
    <content><![CDATA[<blockquote>
<p>文献翻译：文本分类字符级别卷积网络<br>authors: Xiang Zhang, Junbo Zhao, Yann LeCun<br>原文: <a href="https://arxiv.org/abs/1509.01626">Character-level Convolutional Networks for Text Classification</a></p>
</blockquote>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>本文提供了使用字符级卷积网络（ConvNets）进行文本分类的实证研究。我们构建了几个大型数据集，以表明字符级卷积网络可以达到最新水平或竞争结果。可以与传统模型（例如词袋BoW，n-grams 其 TFIDF 变体）以及深度学习模型（例如基于单词的 ConvNets 和递归神经网络）进行比较。</p>
<span id="more"></span>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>文本分类是自然语言处理的经典研究问题，其中需要为自由文本文档分配预定义的类别。文本分类研究的范围从设计最佳特征到选择最佳的机器学习分类器。迄今为止，几乎所有的文本分类技术都是基于单词的，其中一些有序的单词组合（例如 n-gram）的简单统计通常表现最佳<sup><a href="#fn_12" id="reffn_12">12</a></sup>。</p>
<p>另一方面，许多研究人员发现卷积网络（ConvNets）<sup><a href="#fn_17" id="reffn_17">17</a></sup><sup><a href="#fn_18" id="reffn_18">18</a></sup>非常适合用于从原始信息中提取信息，因而卷积网络从计算机视觉领域被扩展到语音识别等领域。特别地，深度学习研究中早期使用的时延网络本质上是对序列数据进行建模的卷积网络。<sup><a href="#fn_1" id="reffn_1">1</a></sup><sup><a href="#fn_31" id="reffn_31">31</a></sup>。</p>
<p>在本文中，我们探索将文本视为一种字符级别的原始信号，并对其应用时间（一维）卷积网络 ConvNets。本文仅使用分类任务作为例证，说明 ConvNets 理解文本的能力。从以往的研究，我们知道 ConvNets 通常需要大规模的数据集才能很好地工作，因此我们也构建了几个这样的数据集。并提供了传统模型和其他深度学习模型的一组比较。</p>
<p>已有文献探索了将卷积网络应用于文本分类或整个自然语言处理中，并已经证明，ConvNets 可以直接应用于分布<sup><a href="#fn_6" id="reffn_6">6</a></sup><sup><a href="#fn_16" id="reffn_16">16</a></sup>或离散<sup><a href="#fn_13" id="reffn_13">13</a></sup>的词嵌入（Word embedding）中，而无需了解语言的语法或语义结构。这些方法已被证明与传统模型相比具有竞争力。</p>
<p>目前已有一些使用字符级别特征进行自然语言处理的相关研究工作。其中包含使用带有线性分类器的字符级别 n-gram<sup><a href="#fn_15" id="reffn_15">15</a></sup>,以及将字符级别特征合并到 ConvNets<sup><a href="#fn_28" id="reffn_28">28</a></sup><sup><a href="#fn_29" id="reffn_29">29</a></sup>。这些 ConvNet 方法使用单词作为基础，在单词<sup><a href="#fn_28" id="reffn_28">28</a></sup>或单词 n-gram<sup><a href="#fn_29" id="reffn_29">29</a></sup> 的分布式表示上提取字符级别特征，对词性标记和信息检索进行改进。</p>
<p>本文是首次仅在字符级别上应用 ConvNets 的文章。我们证明，在大规模数据集上进行训练时，除了以前的研究得出的，即 ConvNets 不需要语言的语法或语义结构方面的知识外，深层 ConvNets 也是不需要单词的相关的知识的。这种工程上的简化对于可以适用于不同语言的单个系统而言至关重要，因为字符始终是文本必要的构成元素，不管是否将文本分割成单词。仅处理字符还具有以下优点：可以自然地学习诸如拼写错误和表情符号之类的异常字符组合。</p>
<h2 id="2-Character-level-Convolutional-Networks"><a href="#2-Character-level-Convolutional-Networks" class="headerlink" title="2. Character-level Convolutional Networks"></a>2. Character-level Convolutional Networks</h2><p>在本节中，我们经介绍文本分类的字符级别 ConvNets 的设计。该设计是模块化的，并通过反向传播<sup><a href="#fn_27" id="reffn_27">27</a></sup>计算梯度来执行优化。</p>
<h3 id="2-1-Key-Modules"><a href="#2-1-Key-Modules" class="headerlink" title="2.1 Key Modules"></a>2.1 Key Modules</h3><p>主要组件是时间卷积模块，它仅计算一维卷积。假设有一个离散输入函数$g(x)\in[1,l]\to \mathbb{R}$和一个离散核函数$f(x)\in[1,k]\to\mathbb{R}$。步长（stride）为$d$，$f(x)$和$g(x)$之间的卷积$h(y)\in[1,[(l-k)/d]+1]\to\mathbb{R}$ 定义如下</p>
<script type="math/tex; mode=display">
h(y) = \sum^k_{x=1}f(x)\cdot g(y\cdot d-x+c)</script><p>其中$c=k-d+1$是一个偏置常数。就像在计算机视觉上的传统卷积网络一样，该模块由一组这样的内核函数$f<em>{ij}(x)(i=1,2,…,m\quad and\quad j=1,2,…,n)$ 来进行参数化，通常称为权重（weights），以及一组输入 $g_i(x)$ 和输出 $h_j(y)$。我们称每个$g_i$ 为输入特征，每个$h_i$为输出特征，用 $m$ 表示输入特征的大小，$n$ 表示输出特征的大小。通过在 $g_i(x)$ 和 $f</em>{ij}(x)$ 之间卷积在 $i$ 上的总和来表示输出 $h_j(y)$。</p>
<p>帮助我们训练更深层模型的一个关键模块是时间最大池化（temporal max-pooling，一维最大池化）。它是计算机视觉<sup><a href="#fn_2" id="reffn_2">2</a></sup>中使用的最大池化模块的一维版本。给定一个离散输入函数 $g(x)\in [1,l]\to \mathbb{R}$， $g(x)$ 的 max-pooling 函数 $h(y)\in [1,[(l-k)/d]+1]\to \mathbb{R}$ 定义如下</p>
<script type="math/tex; mode=display">
h(y) = max_{x=1}^k g(y\cdot d -x +c)</script><p>其中 $c=k-d+1$ 是一个偏置常数。这样的池化模块能使我们训练超过 6 层的 ConvNets 模型，而其他的层均会失败，<sup><a href="#fn_3" id="reffn_3">3</a></sup>中的分析可能对此有所启发。</p>
<p>在模型中使用的非线性修正器阈值函数 $h(x) = max{0,x}$，这让我们模型中的卷积层能与修正线性单元类似（ReLUs）<sup><a href="#fn_24" id="reffn_24">24</a></sup>。算法使用随机梯度下降（SGD），其最小批量为 128，使用动量（momentum）为 0.9，初始步长为 0.01，每 3 个 epoch 减半 10 次。每个 epoch 都采用固定数量的随机训练样本，这些样本在各个类别上使用均匀采样。稍后将详细给出每个数据集使用的样本数。模型使用 Torch 7<sup><a href="#fn_4" id="reffn_4">4</a></sup>实现。</p>
<h3 id="2-2-Character-quantization"><a href="#2-2-Character-quantization" class="headerlink" title="2.2 Character quantization"></a>2.2 Character quantization</h3><p>我们的模型接收一个由编码后字符形成的序列作为输入。通过为输入的语言规定字母表（alphabet），然后使用字符的 one-hot 编码来量化每个字符。然后将字符序列转换为这样的序列，一个大小为固定长度$l_0$的向量。序列中超过长度$l_0$的所有字符都会被忽略，空字符或不在字母表中字符用 0 向量进行量化表示。字符量化的顺序与字符读取的顺序是相反的，因此最新读取的字符始终处于输出的头部，从而使全连接层更易于将权重与最新读取的字符相关联。</p>
<p>我们所有模型使用的字符表包含 70 个字符，其中包含 26 个英文字母，10 个数字，33 个其他字符和换行符。如下：</p>
<p><img data-src="alphabet.png" alt=""></p>
<p>之后，我们还与使用了不同字母表的模型进行对比，在这些模型的字母表中区分大写和小写字母。</p>
<h3 id="2-3-Model-Design"><a href="#2-3-Model-Design" class="headerlink" title="2.3 Model Design"></a>2.3 Model Design</h3><p>我们设计两个卷积神经网络——一个大的和一个小的。它们都有 9 层，其中 6 层卷积层和 3 层全连接层。见图 Figure 1。</p>
<p><img data-src="figure-1.png" alt=""></p>
<p>因为我们字符量化的方法，模型输入的特征（feature）固定为 70，并且输入特征长度（length）为 1014。似乎1014个字符已经可以捕获大多数感兴趣的文本。我们还在 3 个全连接层之间插入两个 dropout 层<sup><a href="#fn_10" id="reffn_10">10</a></sup>来进行正则化。它们的 dropout rate 为 0.5。Table 1列出了卷积层的配置，Table 2列出了全连接层的配置。</p>
<p><img data-src="table-1.png" alt=""></p>
<p>我们使用高斯分布来初始化权重。大模型初始化使用的均值和标准差为$(0,0.02)$，小模型初始化使用的均值和标准差为$(0,0.05)$。</p>
<p><img data-src="table-2.png" alt=""></p>
<p>对于不同的问题，模型的输入的长度可能不同（例如我们的模型使用 $l_0=1014$），在我们模型的设计中，很容易知道，给定输入长度$l_0$，最后一个卷积层之后（所有全连接层之前）的的输出帧长度为 $l_6=(l_0-96)/27$。该数字乘以第 6 层的帧大小将得出第一个全连接层的输入维度。</p>
<h3 id="2-4-Data-Augmentation-using-Thesaurus"><a href="#2-4-Data-Augmentation-using-Thesaurus" class="headerlink" title="2.4 Data Augmentation using Thesaurus"></a>2.4 Data Augmentation using Thesaurus</h3><p>许多研究人员发现，适当使用数据增强技术对于控制深度学习的泛化错误很有作用。当我们找到模型具有适当的不变属性时，这些技术通常效果很好。就文本而言，使用图像或语言识别中进行信号转换来增强数据是不合理的，因为字符的确切顺序可能会形成严格的句法和语义。因此，进行数据增强的最佳方法是使用人工措词，但这是不现实的且昂贵的，因为我们数据集中的样本量通常非常大。因此，对我们而言，数据增强中最自然的选择是使用同义词来替换单词或短语。</p>
<p>我们使用英文同义词来进行数据增强实验，该词库是从 LibreOffice 项目中使用的 mytheas 组件中获得的。该词库又是从 Word-Net<sup><a href="#fn_7" id="reffn_7">7</a></sup>中获取的，其中单词或短语的每个同义词都按照与最常见的含义的语义接近度来进行排序。为了确定要替换的单词数，我们从给定的文本中提取所有可替换的单词，然后随机选择 $r$ 个要替换的单词来替换。$r$ 的概率由参数为 $p$ 的几何分布确定，其中 $P[r]\thicksim p^r$。给定单词的同义次的索引 $s$也由另一种几何分布来确定，其中 $P[s]\thicksim q^s$。这样，当同义词偏离最常见的含义时，其被选中的可能性就会变小，我们将使用该数据增强技术，其中 $p=0.5, q=0.5$。</p>
<h2 id="3-Comparison-Models"><a href="#3-Comparison-Models" class="headerlink" title="3. Comparison Models"></a>3. Comparison Models</h2><p>为了公平地比较竞争的模型，我们使用传统和深度学习方法进行了一系列实验。我们尽力选择可以提供可比且具有竞争力的结果的模型，并且在不进行任何模型选择的情况下，如实地报告实验结果。</p>
<p><strong>Bag-of-words and its TFIDF.</strong> 对于每一个数据集，bag-of-words 模型通过选择训练集中最频繁的 50,000 个单词来构造模型。对于常规的 bag-of-word方法，我们用每个单词的计数作为特征。对于 TFIDF（term-frequency inverse-document-frequency）<sup><a href="#fn_14" id="reffn_14">14</a></sup>版本，我们使用单词的计数作为词频。逆文档频率是样本总数与训练样本子集中样本数的除数的对数。然后通过除以最大特征数值来进行正则化。</p>
<p><strong>Bag-of-ngrams and its TFIDF.</strong> bag-of-ngrams 模型通过从每一个数据集中的训练集中选择 500,000 个最频繁 n-grams （最多5-grams）来构建。特征的计算方式与 bag-of-words 模型一样。</p>
<p><strong>Bag-of-means on word embedding.</strong> 我们也有一个实验模型从每个数据集的训练子集的 word2vec<sup><a href="#fn_23" id="reffn_23">23</a></sup>上应用 k 均值，然后将这些学习的方法用作聚类词的代表。我们考虑了在训练子集中出现超过 5 次的所有单词。嵌入的维数为 300。bag-of-means 特征的计算方式与 bag-of-words 模型中的方式一样。均值数为 5000。</p>
<h3 id="3-1-Deep-Learning-Methods"><a href="#3-1-Deep-Learning-Methods" class="headerlink" title="3.1 Deep Learning Methods"></a>3.1 Deep Learning Methods</h3><p>最近，深度学习方法一直开始应用于文本分类中，我们选择两种简单且具有代表性的模型进行比较。其中一种是基于单词的 ConvNets，另一种是简单的长期短期记忆网络模型（LSTM）<sup><a href="#fn_11" id="reffn_11">11</a></sup>。</p>
<p><strong>Wrod-based ConvNets.</strong> 在有关基于单词的 ConvNets 用于文本分类的大量最新研究中，区别之一是选择使用预训练的或端到端的学习的单词表示形式。我们使用预训练的 word2vec<sup><a href="#fn_23" id="reffn_23">23</a></sup>嵌入<sup><a href="#fn_16" id="reffn_16">16</a></sup>和查找表<sup><a href="#fn_5" id="reffn_5">5</a></sup>进行比较。在两种情况下，嵌入大小均为 300，与 bag-of-means 模型相同。为了确保公平地进行比较，每种情况下的模型在层数和每层输出大小方面均与字符级别 ConvNets 相同。还进行了同义词替换数据增强。</p>
<p><strong>Long-short term memory.</strong> 我们还提供了与 RNN 网络模型（即长期短期记忆网络，LSTM<sup><a href="#fn_11" id="reffn_11">11</a></sup>）的比较。该 LSTM 模型是基于单词的，与上文的模型一样，使用大小为 300 的预训练 word2vec 嵌入。通过取所有的 LSTM 单元的输出平均值形成一个特征向量，然后对该特征向量使用多项逻辑回归来构建模型。模型输出的维度为 512。本文使用的 LSTM 变体是常见的 “vanilla” 结构<sup><a href="#fn_8" id="reffn_8">8</a></sup><sup><a href="#fn_9" id="reffn_9">9</a></sup>。我们还使用了梯度正则，取值为 5。见 Figure 2。</p>
<p><img data-src="figure-2.png" alt=""></p>
<h3 id="3-2-Choice-of-Alphabet"><a href="#3-2-Choice-of-Alphabet" class="headerlink" title="3.2 Choice of Alphabet"></a>3.2 Choice of Alphabet</h3><p>对于英文字母表，一个明显的选择数是否区分大小写字母。本文给出了选择的相关实验结果，结果表明，当考虑区分大小写时，通常（但并非总是）会得到比较差的结果。一种可能的解释是语义不会随字母大小写发生改变，因此正则化必然是存在好处的。</p>
<h2 id="4-Large-scale-Datasets-and-Results"><a href="#4-Large-scale-Datasets-and-Results" class="headerlink" title="4. Large-scale Datasets and Results"></a>4. Large-scale Datasets and Results</h2><p>以前在不同领域对 ConvNets 进行的研究表明，它们通常与大规模的数据集配合进行训练。特别是当模型使用低级原始特征表示的时候（本文中使用的字符级别）。然而，大多数用于文本分类的开放数据集都非常小，并且大规模的数据集通常被划分成较小的训练集以及测试集<sup><a href="#fn_21" id="reffn_21">21</a></sup>。因此，我们没有使用它们，而自己构建几个大规模数据集，范围从数十万到数百万个样本，见 Table 3。</p>
<p><img data-src="table-3.png" alt=""></p>
<p><strong>AG’s new corpus.</strong>（AG 新闻语料）我们通过网络<sup><a href="#fn_2" id="reffn_2">2</a></sup>获取了 AG 新闻文章语料库。它包含来自 2000 多个新闻来源的 496,835 个分类的新闻文章。我们仅从标题和描述字段中选取该语料库中最多的 4 个类别来构建数据集。每个类别的训练样本数据量为 30,000，测试数量为 1900。</p>
<p><strong>Sogou’s new corpus.</strong> 该数据集是 SogouuCA 和 SogouCS 新闻语料库的组合<sup><a href="#fn_32" id="reffn_32">32</a></sup>，总共包含各种主题中的 2,909,551 调新闻文章。然后，通过手动分类新闻的领域名，我们使用新闻的 URL 标记新闻。这使我们获得了大量带有其类别标签的新闻文章。类别很多，但大多数包含很少的文章。我们选择 5 个类别-“体育”，“金融”，“娱乐”，“汽车”和“技术”。每个班级选择的训练样本数量为 90,000，测试集为 12,000。尽管这是中文数据集，我们使用 pypinyin 包集合 jieba 分词来生成拼音。然后将英文模型应用于此数据集则无需进行任何更改。其中使用标题和内容字段。</p>
<p><img data-src="table-4.png" alt=""></p>
<p><strong>DBPedia ontology dataset.</strong> DBpedia 是一个众包社区，旨在从 Wikipedia 中提取结构化信息<sup><a href="#fn_19" id="reffn_19">19</a></sup>。通过从 DBPedia 2014中选择 14 个不重叠的类来构建 DBPedia 本体数据集。从这 14 个类别中的每一个类中，我们随机选择 40,000 个训练样本和 5,000 个测试样本。我们用于此数据集的字段包含每个 Wikipedia 文章的标题和摘要。</p>
<p><strong>Yelp reviews.</strong> Yelp 评论数据集来自 2015 年的 Yelp 数据集挑战赛。该数据集包含 1,569,264 个具有评论文本的样本。从该数据集构建了两个分类任务——一个预测用户给定的恒星总数，另一个通过考虑恒星 1 和 2 为负，恒星 3 和 4 正，来预测极性标签。完整的数据集在每颗恒星中具有 130,000 个训练样本和 10,000 个测试样本，而极性数据集在每个极性中具有 280,000 个训练样本和 19,000 个测试样本。</p>
<p><strong>Amazon reviews.</strong>  我们从斯坦福网络分析项目 （SNAP）获得了 Amazon 评论数据集，该数据集横跨 18 年，来自 2,643,053 个产品的 6,43,669 个用户中的 34,686,770 条评论<sup><a href="#fn_22" id="reffn_22">22</a></sup>。与 Yelp 评论数据集相似，我们也构建了 2 个数据集——一个完整分数预测和另一个极性预测。完整的数据集包含每个类别中的 600,000 个训练样本和 130,000 个测试样本，而极性数据集则包含 1,800,000 个训练样本和 200,00 个测试样本。</p>
<p>Table 4列出了我们从这些数据集中获得的所有适用与模型的测试错误。请注意，由于我们没有中文词库，因此使用搜狗数据集并没有使用数据增强。我们将最佳结果标记为蓝色，将较差结果标记为红色。</p>
<h2 id="5-Discussion"><a href="#5-Discussion" class="headerlink" title="5. Discussion"></a>5. Discussion</h2><p><img data-src="figure-3.png" alt=""></p>
<p>为了更好地了解 Table 4 中的结果，我们在本节中提供了一些经验分析。为了方便我们的分析，我们在Figure 3 中提供了相对于比较模型的相对误差。</p>
<p>这些图的每一个都是通过比较模型和字符级别 ConvNets 模型的误差之间的差来计算的，然后除以比较模型误差。图中的所有 ConvNets 都是带有词库数据增强的大型模型。</p>
<p><strong>字符级别 ConvNets 是一个高效的方法</strong>。我们实验中的最重要的结论是，字符级别的 ConvNets 可以不需要单词的情况下进行文本分析。这有力地证明了，语言也可以被视为与任何其他种类类似的信号。</p>
<p><strong>数据集大小在传统模型与 ConvNets 模型之间通常差异明显。</strong>从 Figure 3 中可以明显看出，较大的数据集往往表现更好。像 n-grams TFIDF 这样的传统方法荏苒是多达几十万个样本规模数据集的强大候选者，而字符级别 ConvNets 只有在数据集规模到达几百万个样本规模时，我们才能看到它较好的表现。</p>
<p><strong>ConvNets 可以很好地处理用户生成的数据。</strong>用户生成数据的文字编排程度不同。例如，在我们的百万个数据集岁，亚马逊评论数据集中往往是原始的用户输入，而用户可能会格外注意他们在 Yahoo! 上的写的评论回答。比较基于单词的深度模型（Figure 3, c,d,e）的图表表明，字符级别 ConvNets 可以更好地处理较少编排的用户生成的文本。此属性表明 ConvNets 可以对现实情况具有更好的适用性。但是，需要进一步的分析来验证 ConvNets 确实擅长于识别额外的字符组合（例如拼写错误和表情符号）的假设，因为仅我们的实验并未显示任何明确的证据。</p>
<p><strong>根据字母表的选择有会不同的结果。</strong> Figure 3表明，使用区分字母大小写的字母表，可能会有不同的结果。对于百万规模的数据集，通常不做这种区分会更好。一种可能的解释是存在正则化效应，但这是有待验证的。</p>
<p><strong>任务的语义可能并不重要。</strong>我们的数据集包括两种任务：情感分析（Yelp 和 Amazon 评论）和主题分类（所有其他任务）。任务语义上的这种二分法似乎在决定哪种方法更好时不起作用。</p>
<p><strong>Bag-of-means 是对 word2vec 的滥用<sup><a href="#fn_20" id="reffn_20">20</a></sup>。</strong>从 Table 4 和 Figure 3a 中可以观察到最明显的事实之一是，bag-of-means 模型在每种情况下的性能较差。与传统模型相比，这表明分布式单词表示的这种简单使用可能无法为我们提供文本分类的优势。但是，我们的实验并不代表任何其他语言处理任务或以任何其他方式使用 word2vec。</p>
<p><strong>天下没有免费的午餐。</strong>我们的实验再次验证了没有一个适用于所有数据集的机器学习模型。本节中讨论的因素都可以在决定哪种方法最合适某些特定应用的过程中发挥作用。</p>
<h2 id="6-Conclusion-and-Outlook"><a href="#6-Conclusion-and-Outlook" class="headerlink" title="6. Conclusion and Outlook"></a>6. Conclusion and Outlook</h2><p>本文提供了针对文本分类的字符级别分类卷积网络的实证研究。我们使用了几个大型数据集，并使用许多传统模型和深度学习模型进行了比较。一方面，分析表明字符级别的 ConvNet 是一种有效的方法。另一方面，我们的模型在比较实验中的表现效果取决于许多因素，例如数据集的大小，文本是否经过整理以及字母表的选择。</p>
<p>将来，我们希望将字符级别的 ConvNets 应用到更广泛的语言处理任务中，尤其是在需要结构化输出的应用场景中。</p>
<h2 id="Acknowledgement"><a href="#Acknowledgement" class="headerlink" title="Acknowledgement"></a>Acknowledgement</h2><p>我们衷心感谢 NVIDIA Corporation 的捐赠，其中包括捐赠了2 个用于该研究的 Tesla K40 GPU。 我们非常感谢 Amazon.com Inc 支持用于这项研究的 AWS in Education Research 补助金。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><blockquote id="fn_1">
<sup>1</sup>. L. Bottou, F. Fogelman Soulié, P. Blanchet, and J. Lienard. Experiments with time delay networks and dynamic time warping for speaker independent isolated digit recognition. In Proceedings of EuroSpeech 89, volume 2, pages 537–540, Paris, France, 1989.<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. Y.-L. Boureau, F. Bach, Y. LeCun, and J. Ponce. Learning mid-level features for recognition. In Computer Vision and Pattern Recognition (CVPR), 2010 IEEE Conference on, pages 2559–2566. IEEE, 2010.<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_3">
<sup>3</sup>. Y.-L. Boureau, J. Ponce, and Y. LeCun. A theoretical analysis of feature pooling in visual recognition. In Proceedings of the 27th International Conference on Machine Learning (ICML-10), pages 111–118, 2010.<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_4">
<sup>4</sup>. R. Collobert, K. Kavukcuoglu, and C. Farabet. Torch7: A matlab-like environment for machine learning. In BigLearn, NIPS Workshop, number EPFL-CONF-192376, 2011.<a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_5">
<sup>5</sup>. R. Collobert, J. Weston, L. Bottou, M. Karlen, K. Kavukcuoglu, and P. Kuksa. Natural language processing (almost) from scratch. J. Mach. Learn. Res., 12:2493–2537, Nov. 2011.<a href="#reffn_5" title="Jump back to footnote [5] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_6">
<sup>6</sup>. C. dos Santos and M. Gatti. Deep convolutional neural networks for sentiment analysis of short texts. In Proceedings of COLING 2014, the 25th International Conference on Computational Linguistics: Technical Papers, pages 69–78, Dublin, Ireland, August 2014. Dublin City University and Association for Computational Linguistics.<a href="#reffn_6" title="Jump back to footnote [6] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_7">
<sup>7</sup>. C. Fellbaum. Wordnet and wordnets. In K. Brown, editor, Encyclopedia of Language and Linguistics, pages 665–670, Oxford, 2005. Elsevier.<a href="#reffn_7" title="Jump back to footnote [7] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_8">
<sup>8</sup>. A. Graves and J. Schmidhuber. Framewise phoneme classification with bidirectional lstm and other neural network architectures. Neural Networks, 18(5):602–610, 2005.<a href="#reffn_8" title="Jump back to footnote [8] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_9">
<sup>9</sup>. K. Greff, R. K. Srivastava, J. Koutnı́k, B. R. Steunebrink, and J. Schmidhuber. LSTM: A search space odyssey. CoRR, abs/1503.04069, 2015.<a href="#reffn_9" title="Jump back to footnote [9] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_10">
<sup>10</sup>. G. E. Hinton, N. Srivastava, A. Krizhevsky, I. Sutskever, and R. R. Salakhutdinov. Improving neural networks by preventing co-adaptation of feature detectors. arXiv preprint arXiv:1207.0580, 2012.<a href="#reffn_10" title="Jump back to footnote [10] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_12">
<sup>12</sup>. T. Joachims. Text categorization with suport vector machines: Learning with many relevant features. In Proceedings of the 10th European Conference on Machine Learning, pages 137–142. Springer-Verlag, 1998.<a href="#reffn_12" title="Jump back to footnote [12] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_13">
<sup>13</sup>. R. Johnson and T. Zhang. Effective use of word order for text categorization with convolutional neural networks. CoRR, abs/1412.1058, 2014.<a href="#reffn_13" title="Jump back to footnote [13] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_14">
<sup>14</sup>. K. S. Jones. A statistical interpretation of term specificity and its application in retrieval. Journal of Documentation, 28(1):11–21, 1972.<a href="#reffn_14" title="Jump back to footnote [14] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_15">
<sup>15</sup>. I. Kanaris, K. Kanaris, I. Houvardas, and E. Stamatatos. Words versus character n-grams for anti-spam filtering. International Journal on Artificial Intelligence Tools, 16(06):1047–1067, 2007.<a href="#reffn_15" title="Jump back to footnote [15] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_16">
<sup>16</sup>. Y. Kim. Convolutional neural networks for sentence classification. In Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP), pages 1746–1751, Doha, Qatar, October 2014. Association for Computational Linguistics.<a href="#reffn_16" title="Jump back to footnote [16] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_17">
<sup>17</sup>. Y. LeCun, B. Boser, J. S. Denker, D. Henderson, R. E. Howard, W. Hubbard, and L. D. Jackel. Backpropagation applied to handwritten zip code recognition. Neural Computation, 1(4):541–551, Winter 1989.<a href="#reffn_17" title="Jump back to footnote [17] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_18">
<sup>18</sup>. Y. LeCun, L. Bottou, Y. Bengio, and P. Haffner. Gradient-based learning applied to document recognition. Proceedings of the IEEE, 86(11):2278–2324, November 1998.<a href="#reffn_18" title="Jump back to footnote [18] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_19">
<sup>19</sup>. J. Lehmann, R. Isele, M. Jakob, A. Jentzsch, D. Kontokostas, P. N. Mendes, S. Hellmann, M. Morsey, P. van Kleef, S. Auer, and C. Bizer. DBpedia - a large-scale, multilingual knowledge base extracted from wikipedia. Semantic Web Journal, 2014.<a href="#reffn_19" title="Jump back to footnote [19] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_20">
<sup>20</sup>. G. Lev, B. Klein, and L. Wolf. In defense of word embedding for generic text representation. In C. Biemann, S. Handschuh, A. Freitas, F. Meziane, and E. Mtais, editors, Natural Language Processing and Information Systems, volume 9103 of Lecture Notes in Computer Science, pages 35–50. Springer International Publishing, 2015.<a href="#reffn_20" title="Jump back to footnote [20] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_21">
<sup>21</sup>. D. D. Lewis, Y. Yang, T. G. Rose, and F. Li. Rcv1: A new benchmark collection for text categorization research. The Journal of Machine Learning Research, 5:361–397, 2004.<a href="#reffn_21" title="Jump back to footnote [21] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_22">
<sup>22</sup>. J. McAuley and J. Leskovec. Hidden factors and hidden topics: Understanding rating dimensions with review text. In Proceedings of the 7th ACM Conference on Recommender Systems, RecSys ’13, pages 165–172, New York, NY, USA, 2013. ACM.<a href="#reffn_22" title="Jump back to footnote [22] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_23">
<sup>23</sup>. T. Mikolov, I. Sutskever, K. Chen, G. S. Corrado, and J. Dean. Distributed representations of words and phrases and their compositionality. In C. Burges, L. Bottou, M. Welling, Z. Ghahramani, and K. Weinberger, editors, Advances in Neural Information Processing Systems 26, pages 3111–3119. 2013.<a href="#reffn_23" title="Jump back to footnote [23] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_24">
<sup>24</sup>. V. Nair and G. E. Hinton. Rectified linear units improve restricted boltzmann machines. In Proceedings of the 27th International Conference on Machine Learning (ICML-10), pages 807–814, 2010.<a href="#reffn_24" title="Jump back to footnote [24] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_25">
<sup>25</sup>. R. Pascanu, T. Mikolov, and Y. Bengio. On the difficulty of training recurrent neural networks. In ICML 2013, volume 28 of JMLR Proceedings, pages 1310–1318. JMLR.org, 2013.<a href="#reffn_25" title="Jump back to footnote [25] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_26">
<sup>26</sup>. B. Polyak. Some methods of speeding up the convergence of iteration methods. {USSR} Computational Mathematics and Mathematical Physics, 4(5):1 – 17, 1964.<a href="#reffn_26" title="Jump back to footnote [26] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_27">
<sup>27</sup>. D. Rumelhart, G. Hintont, and R. Williams. Learning representations by back-propagating errors. Nature, 323(6088):533–536, 1986.<a href="#reffn_27" title="Jump back to footnote [27] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_28">
<sup>28</sup>. C. D. Santos and B. Zadrozny. Learning character-level representations for part-of-speech tagging. In Proceedings of the 31st International Conference on Machine Learning (ICML-14), pages 1818–1826, 2014.<a href="#reffn_28" title="Jump back to footnote [28] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_29">
<sup>29</sup>. Y. Shen, X. He, J. Gao, L. Deng, and G. Mesnil. A latent semantic model with convolutional-pooling structure for information retrieval. In Proceedings of the 23rd ACM International Conference on Conference on Information and Knowledge Management, pages 101–110. ACM, 2014.<a href="#reffn_29" title="Jump back to footnote [29] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_30">
<sup>30</sup>. I. Sutskever, J. Martens, G. E. Dahl, and G. E. Hinton. On the importance of initialization and momentum in deep learning. In S. Dasgupta and D. Mcallester, editors, Proceedings of the 30th International Conference on Machine Learning (ICML-13), volume 28, pages 1139–1147. JMLR Workshop and Conference Proceedings, May 2013.<a href="#reffn_30" title="Jump back to footnote [30] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_31">
<sup>31</sup>. A. Waibel, T. Hanazawa, G. Hinton, K. Shikano, and K. J. Lang. Phoneme recognition using time-delay neural networks. Acoustics, Speech and Signal Processing, IEEE Transactions on, 37(3):328–339, 1989.<a href="#reffn_31" title="Jump back to footnote [31] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_32">
<sup>32</sup>. C. Wang, M. Zhang, S. Ma, and L. Ru. Automatic online news issue construction in web environment. In Proceedings of the 17th International Conference on World Wide Web, WWW ’08, pages 457–466, New York, NY, USA, 2008. ACM.<a href="#reffn_32" title="Jump back to footnote [32] in the text."> &#8617;</a>
</blockquote>
]]></content>
      <categories>
        <category>dissertation</category>
      </categories>
      <tags>
        <tag>paper translation</tag>
      </tags>
  </entry>
  <entry>
    <title>The Notion of the Diagnosability</title>
    <url>/posts/57ea30e/</url>
    <content><![CDATA[<blockquote>
<p>文献内容翻译：可诊断性概念<br>authors: Meera Sampath, Raja Sengupta, StCphane Lafortune, Member, IEEE, Kasim Sinnamohideen, Member, IEEE, and Demosthenis Teneketzis, Member, IEEE<br>原文: <a href="https://ieeexplore.ieee.org/document/412626">Diagnosability of discrete-event systems</a></p>
</blockquote>
<span id="more"></span>
<h2 id="A-The-System-Model"><a href="#A-The-System-Model" class="headerlink" title="A. The System Model"></a>A. The System Model</h2><p>待诊断系统通常使用一个 FSM 或生成器（generator）来进行建模。</p>
<script type="math/tex; mode=display">
G = (X, \Sigma, \delta, x_0)</script><p>其中$X$是状态空间，$\Sigma$是事件集，$\delta$是一个部分转移函数，$x_0$是系统的初始状态。系统模型$G$记录系统正常和错误行为。系统的行为使用$G$生成的前缀闭合语言$L(G)$来描述<sup><a href="#fn_1" id="reffn_1">1</a></sup>。此后，我们使用$L$直接表示$L(G)$，$L$是<script type="math/tex">\Sigma^*</script>的子集，其中<script type="math/tex">\Sigma^*</script>是事件集的 Kleene 闭包<sup><a href="#fn_2" id="reffn_2">2</a></sup>。</p>
<p>$\Sigma$中一些事件是可观的，即它们的发生是被观测到的，其他的是不可观的。因此，事件集可以划分为<script type="math/tex">\Sigma = \Sigma_o\cup\Sigma_{uo}</script>，其中<script type="math/tex">\Sigma_o</script>表示可观事件集，而<script type="math/tex">\Sigma_{uo}</script>表示不可观事件集。系统中可观事件可能是以下情况下之一：控制器发出的指令，在执行上述命令后立即读取的传感器读数以及传感器读数的变化。不可观事件可以是错误事件或导致传感器未记录的系统状态更改（见<sup><a href="#fn_3" id="reffn_3">3</a></sup>）。</p>
<p>令<script type="math/tex">\Sigma_f\subseteq \Sigma</script>表示待诊断的错误事件集。不失一般性地，我们假设<script type="math/tex">\Sigma_f\subseteq\Sigma_{uo}</script>，因为一个可观的错误事件显然是容易诊断的。我们的目标是根据系统生成的串来诊断是否有错误事件的发生，其中串中包含的事件均是可观的。在这种情况下，我们将错误事件集划分成多个不相交的集（disjoint set），对应表示不同的错误类型。</p>
<script type="math/tex; mode=display">
\Sigma_f = \Sigma_{f1}\cup\cdots\cup\Sigma_{fm}.</script><p>用$\Pi_f$表示这个划分。使用$\Pi_f$主要出于以下考虑：</p>
<ul>
<li>1) 仪器不足可能会导致无法诊断每个可能的错误；</li>
<li>2) 我们可能不需要唯一标识每个错误事件的发生。我们可能只是想知道一组错误事件集中是否有一个错误事件发生了，例如，当一组错误事件对系统的影响相同时。</li>
</ul>
<p>此后，当我们写到”<script type="math/tex">F_i</script>类型的错误发生了“，意味着”集合<script type="math/tex">\Sigma_{fi}</script>中有错误事件发生了“。</p>
<p>我们假设研究的系统：</p>
<ul>
<li>A1) 系统$G$的生成语言是活语言，即$X$中的每一个状态$x$均有定义转移，即系统不会到达一个没有事件标签的点；</li>
<li>A2) 系统$G$中不存在任何由不可观事件形成的环，即<script type="math/tex">\exists n_o\in \mathbb{IN}</script>使得<script type="math/tex">\forall ust\in L, s\in \Sigma^*_{uo}\Rightarrow\lVert s\rVert\leq n_o</script>，其中$\lVert s\rVert$表示串$s$的长度。</li>
</ul>
<p>针对$L$是活语言的假设主要是为了研究简单。稍作修改，当该假设放松时，本文的所有主要结果均成立。假设2) 确保了系统生成的观察具备某些规律。由于错误的检测是基于系统的可观转移，我们要求$G$不产生任意长度的不可观事件序列。</p>
<p>在<sup><a href="#fn_2" id="reffn_2">2</a></sup>中，我们详细讨论了用于错误诊断的离散事件系统建模。假设待诊断系统包含许多不同的物理组件以及一组传感器。我们首先为每个独立的组件构建相应的 FSM。这些模型会记录相应组件的正常和错误行为。考虑一个这样的例子，一个由泵、阀门和控制器组成的简单 HVAC 系统。Fig. 1描绘了该系统组件的模型。从组件模型和传感器图开始，然后我们生成了一个复合模型，该模型捕获了组件之间的交互并将传感器图纳入其中。这个复合模型就是我们执行错误诊断的系统$G$。</p>
<div align="center" style="display: flex; flex-direction:column;">
    <img data-src="component-models-for-a-simple-HVAC-system.png"/>
    <span>Fig. 1. Component models for a simple HVAC system.</span>
</div>

<p>我们在本节的系统模型上总结一些符号和生成器$G’$的结构，以便之后使用。</p>
<p><strong>1) Notation:</strong> 空串用$\varepsilon$表示。用$\overline{s}$表示任意串<script type="math/tex">s\in\Sigma^*</script>的前缀闭包。$L$的$s$后语言用$L/s$表示，即</p>
<script type="math/tex; mode=display">
L/s = \{t\in\Sigma^*|st\in L\}</script><p>我们通常定义投影<script type="math/tex">P:\Sigma^*\to \Sigma^*_o</script> <sup><a href="#fn_1" id="reffn_1">1</a></sup></p>
<script type="math/tex; mode=display">
\begin{eqnarray}
P(\varepsilon)& = &\varepsilon \\
P(\sigma)& = &\sigma &if\quad \sigma\in\Sigma_o \\
P(\sigma)& =& \varepsilon& if\quad \sigma \in \Sigma_{uo}\\
P(s\sigma)& = &P(s)P(\sigma) &s\in \Sigma^*, \sigma\in\Sigma.
\end{eqnarray}</script><p>换句话说，$P$简单地”清除“了串中的不可观事件。逆投影操作$P^{-1}_L$定义如下：</p>
<script type="math/tex; mode=display">
P^{-1}_L(y) = \{s\in L:P(s)=y\}</script><p>用$s_f$表示串$s$的最后一个事件，我们定义：</p>
<script type="math/tex; mode=display">\Psi(\Sigma_{fi} = \{s\sigma_f\in L:\sigma_f\in \Sigma_{fi}\}</script><p>即<script type="math/tex">\Psi(\Sigma_{fi})</script>表示$L$中所有以错误类型为<script type="math/tex">F_i</script>的错误事件结尾的串的集合。考虑<script type="math/tex">\sigma\in\Sigma</script>以及<script type="math/tex">s\in\Sigma^*</script>。我们用<script type="math/tex">\sigma\in s</script>表示串$s$发生了事件<script type="math/tex">\sigma</script>。略微滥用符号，我们用<script type="math/tex">\Sigma_{fi}\in s</script>表示对于<script type="math/tex">\sigma_f\in\Sigma_{fi}</script>有<script type="math/tex">\sigma_f\in s</script>，或正式地，<script type="math/tex">\overline{s}\cap\Psi(\Sigma_{fi})\neq\emptyset</script>。我们定义</p>
<script type="math/tex; mode=display">
X_o = \{x_0\}\cup\{x\in X:x中包含一个可观事件\}.</script><p>用$L(G,x)$表示从$G$中状态$x$出发产生的所有串的集合，我们定义</p>
<script type="math/tex; mode=display">
L_o(G, x) = \{s\in L(G,x):s=u\sigma, u\in \Sigma^*_{uo}, \sigma\in \Sigma_o\}</script><p>以及</p>
<script type="math/tex; mode=display">
L_{\sigma}(G,x) = \{s\in L_o(G,x):s_f=\sigma\}.</script><p>其中，$L<em>o(G,x)$表示从状态$x$开始以第一个可观事件结束的所有串的集合。$$L</em>{\sigma}(G,x)$$表示$L_o(G,x)$中以一个特定可观事件结束的串的集合。</p>
<p><strong>2) The Generator G’</strong>: 接下来的部分，我们需要特殊构造一个拥有语言$P(L)$的生成器$G’$</p>
<script type="math/tex; mode=display">
P(L) = \{t:t=P(s) 对于某些 s\in L\}</script><p>$G’$通常是不确定的（nondeterministic），并且它的结构如下</p>
<script type="math/tex; mode=display">
G' = (X_o, \Sigma_o, \delta_{G'}, x_0)</script><p>其中<script type="math/tex">X_o</script>，<script type="math/tex">\Sigma_o</script>和$x<em>0$先前已经定义过了。$G’$的转移关系由$$\delta</em>{G’}\subseteq (X_o\times\Sigma\times X_o)$$，其定义如下</p>
<script type="math/tex; mode=display">
(x,\sigma,x')\in \delta_{G'} \\
如果 \delta(x,s) = x' 对于某些 s\in L_{\sigma}(G,x)</script><p>可以很轻易地验证$L(G’) = P(L)$. Figs. 4-6 展示了如果为$G$三个不同系统构造$G’$。</p>
<div align="center" style="display: flex; flex-direction:column;">
    <img data-src="Example-of-a-system-with-an-F1-indeterminate-cycle-in-its-diagnoser-Gd.png"/>
    <span>Fig. 4. Example of system with F1 indeterminate cycle in its diagnoser Gd.</span>
</div>
<div align="center" style="display: flex; flex-direction:column;">
    <img data-src="Example-of-a-system-with-a-cycle-of-F1-uncertain-states-in-its-diagnoser-Gd.png"/>
    <span>Fig. 5. Example of system with a cycle of F1-uncertain states in its diagnoser Gd.</span>
</div>
<div align="center" style="display: flex; flex-direction:column;">
    <img data-src="Another-example-of-a-system-with-an-F1-indeterminate-cycle-in-its-diagnoser.png"/>
    <span>Fig. 6. Another example of system with F1 indeterminate cycle in its diagnoser.</span>
</div>

<h2 id="B-Approaches-to-Defining-Diagnosability"><a href="#B-Approaches-to-Defining-Diagnosability" class="headerlink" title="B. Approaches to Defining Diagnosability"></a>B. Approaches to Defining Diagnosability</h2><p>我们现在准备定义可诊断性的概念。一般而言，一个语言$L$是可诊断的若它能够在有限确切延迟内，使用记录的可观事件串诊断出任意错误类型的发生。我们将给出可诊断性的两种定义方式，其中第一个定义要比第二个定义严格。我们之后将参考的概念是可诊断性和I-可诊断性。</p>
<p><strong>Diagnosability</strong>: 通常，我们定义可诊断性如下。<br><strong>Definition 1:</strong> 一个前缀闭合语言$L$对于投影$P$和$\Sigma_f$上的错误划分$\Pi_f$是可诊断的当</p>
<script type="math/tex; mode=display">
(\forall i\in \Pi_f)(\exists n_i\in \mathbb{IN})[\forall s\in \Psi(\Sigma_{fi})](\forall t\in L/s) \\
[\lVert t\rVert\geq n_i\Rightarrow D]</script><p>其中诊断条件D</p>
<script type="math/tex; mode=display">
w \in P^{-1}_L[P(st)]\Rightarrow\Sigma_{fi}\in w</script><p>上面可诊断性的定义意味着，$s$是一个以错误事件集<script type="math/tex">\Sigma_{fi}</script>中一个错误事件结尾的串，$t$是$s$的充分长后缀。诊断条件D表示系统语言中任何一个与串$st$产生相同投影序列的串必定包含错误事件集<script type="math/tex">\Sigma_{fi}</script>中的一个错误事件。这意味着，$s$的每一个连续的$t$都可以用于在有限延迟之内，在具体最多$n$个系统状态转移之后，来诊断错误类型<script type="math/tex">F_i</script>对应错误事件的发生。换句话说，可诊断性要求系统每一个错误事件发生后，再记录更多的可观事件，以便系统诊断该错误事件的发生。</p>
<p>来自同一个错误划分的多错误情况需要特别注意。当一个串$s$中发生同一个错误类型$F<em>i$的多个错误事件，上面的可诊断性定义不要求每一个错误事件的发生都被检测到。能够在发生第一个错误后的有限多个事件中得出串$s$中发生了错误事件集$\Sigma</em>{fi}$中的错误事件。在后面的部分中， 我们将看到这一特性是如何区分可能的多个错误发生的情况与任何划分集合中没有多个错误发生的情况。</p>
<p>我们展示上面可诊断性概念的一个简单例子。考虑Fig. 2中表示的系统。这里$\alpha, \beta, \gamma$和$\delta$是可观事件，<script type="math/tex">\sigma_{uo}</script>是不可观事件，而<script type="math/tex">\sigma_{f1},\sigma_{f2},\sigma_{f3}</script>是错误事件，<script type="math/tex">x_0</script>是系统的初始状态<script type="math/tex">1</script>。如果选择错误划分<script type="math/tex">\Sigma_{f1}=\{\sigma_{f1},\sigma_{f2}\}</script>和<script type="math/tex">\Sigma_{f2}=\{\sigma_{f3}\}</script>，即它不需要区分错误事件<script type="math/tex">\sigma_{f1}</script>和<script type="math/tex">\sigma_{f2}</script>，对于<script type="math/tex">n_1=2</script>和<script type="math/tex">n_2=1</script>，上面的系统是可诊断的。另一方面，如果错误划分是<script type="math/tex">\Sigma_{f1}=\{\sigma_{f1}\}</script>，<script type="math/tex">\Sigma_{f2}=\{\sigma_{f2}\}</script>和<script type="math/tex">\Sigma_{f3}=\{\sigma_{f3}\}</script>，则系统是不可诊断的，因为它无法推断出错误事件<script type="math/tex">\sigma_{f2}</script>是否发生。</p>
<p><strong>2) I-Diagnosability</strong>: 上面的可诊断性定义要求$L$中的所有串满足诊断条件D。我们现在提出一个宽松的可诊断性定义（术语表示为I-可诊断性），它不需要$L$的所有的串都满足诊断条件D，但适用于那些错误事件后跟与每种错误类型相关的某些指示可观事件形成的串。这种修改是出于对下面实际情况的考虑。例如，考虑一个拥有控制单元的 HVAC 系统。正常模式操作下，每当控制器检测到系统上的热负荷时，它都会发出”open value“（打开阀门）来作出响应，同样，当负载消失时，它会发出”close value“（关闭阀门）指令。假设控制器发生了错误，它无法检测到系统是否出现负荷，因此不会发出任何指令控制。假设在运行期间控制器确实发生了错误，并且进一步假设系统有可能执行任意长度的事件序列，而这不涉及任何指令。在这种情况下，很明显无法诊断任何错误的发生。根据之前的定义，这样的系统是不可诊断的。在修改后的可诊断性定义情况中，我们将”open value“和”close value“分别与指示器事件（“stuck-closed“和”stuck-open”）相关联作为指示事件，并要求系统在确定其可诊断性之前，执行”open value”事件或”close value”事件。在执行对应指示事件之后能够探测到错误事件，则系统是可诊断的，反之，若在执行指示事件之后，仍无法探测到错误事件，则系统是不可诊断的。总结一下，I-可诊断性仅需要在错误事件相关的指示事件发生后，诊断出该错误的发生。</p>
<p>我们首先将$\Sigma_f$中的每一个错误事件与一个或多个可观指示事件相关联。令$\Sigma_I\subseteq \Sigma_o$表示指示事件集，$I_f:\Sigma_f\to 2^{\Sigma_f}$表示指示映射函数（indicator map）。接着，我们选择一个$\Sigma_f$的一个错误划分，使得</p>
<script type="math/tex; mode=display">
\bigcup_{i\in \Pi_f}\Sigma_{fi} = \Sigma_f</script><p>额外的限制，对于每一个 $i = 1,\cdots,m$</p>
<script type="math/tex; mode=display">
\sigma_{f1},\sigma_{f2}\in\Sigma_{fi}\Rightarrow I_f(\sigma_{f1}) = I_f(\sigma_{f2})</script><p>然后定义</p>
<script type="math/tex; mode=display">
I(\Sigma_{fi}) = I_f(\sigma_f) 对于任一 \sigma_f\in \Sigma_{fi}.</script><p>我们现在有一个与每个错误类型<script type="math/tex">F_i</script>相关联的可观指示事件集<script type="math/tex">I(\Sigma_{fi})</script>（更多关于实际系统指示事件选择的内容见<sup><a href="#fn_2" id="reffn_2">2</a></sup>）。</p>
<p>我们现在给出I-可诊断性的定义。<br><strong>Definition 2</strong>: 一个前缀闭合活语言$L$对于投影$P$，$\Sigma_f$上的错误划分$\Psi_f$和指示映射$I$是I-可诊断的当</p>
<script type="math/tex; mode=display">
(\forall i\in\Pi_f)(\exists n_i\in IN)(\forall s\in \Psi(\Sigma_{fi}))\\
(\forall t_1t_2\in L/s:st_1\in \Psi[I(\Sigma_{fi})])\quad[\lVert t_2\rVert\geq n_i\Rightarrow D]</script><p>其中诊断条件D为</p>
<script type="math/tex; mode=display">
w\in P^{-1}_L[P(st_1t_2)]\Rightarrow \Sigma_{fi}\in w.</script><p>注意<script type="math/tex">\Psi(I(\Sigma_{fi}))</script>表示$L$中所有以<script type="math/tex">I(\Sigma_{fi})</script>集合中的一个可观事件结尾的串的集合。因此，对于I-可诊断性，它要求在<script type="math/tex">I(\Sigma_f)</script>中指示事件发生后，最多进行<script type="math/tex">n_i</script>次系统状态转移推断出<script type="math/tex">F_i</script>错误类型的错误事件的发生。</p>
<div align="center" style="display: flex; flex-direction:column;">
    <img data-src="Example-of-a-system-with-multiple-failures.png"/>
    <span>Fig. 2. Example of system with multiple failures.</span>
</div>

<p>考虑如 Fig. 2图中的系统。假设其选择的指示事件集如下：<script type="math/tex">I(\Sigma_{f1})=\{\gamma\}, I(\Sigma_{f2})=\{\delta\}</script>和<script type="math/tex">I(\Sigma_{f3})=\{\delta\}</script>。系统的错误划分为：<script type="math/tex">\Sigma_{f1}=\{\sigma_{f1}\}, \Sigma_{f2}=\{\sigma_{f2}\}</script>和<script type="math/tex">\Sigma_{f3}=\{\sigma_{f3}\}</script>。对于<script type="math/tex">n_1=0,n_3=0</script>，系统是I-可诊断的。应该注意的是，尽管不可能推断指示事件对应错误事件<script type="math/tex">\sigma_{f2}</script>的发生，即$\delta$没有跟踪该错误事件，但这并不违反I-可诊断性的诊断条件。</p>
<p><sup><a href="#fn_1" id="reffn_1">1</a></sup>:P. J. Ramadge and W. M. Wonham, “The control of discrete-event systems,” Proc. ZEEE, vol. 77, no. 1, pp. 81-98, 1989.<br><sup><a href="#fn_2" id="reffn_2">2</a></sup>:J. Hopcroft and J. Ullman, Introduction to Automata Theory, Languages, and Computation. Reading, MA: Addison Wesley, 1979.<br><sup><a href="#fn_3" id="reffn_3">3</a></sup>:__, “Failure diagnosis using discrete-event models,” Dept. EECS, Umv. of Michigan, MI 48109, 1994, Tech. Rep. CGR 94-3. (Accepted for publication% IEEE Trans. Conrr. Syst. Tech..)</p>
]]></content>
      <categories>
        <category>dissertation</category>
      </categories>
      <tags>
        <tag>paper translation</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Github国内访问出现的问题</title>
    <url>/posts/7e3029b3/</url>
    <content><![CDATA[<p>主要通过修改hosts文件解决Github在国内访问不了、访问慢和页面加载异常的问题(没钱买vpn~)。</p>
<p>简单了解一下github, github是目前全球最大的男性同性交友网站(~滑稽~), 使用示例如下：</p>
<p><img data-src="/images/解决Github访问问题/communication.jpg" alt=""></p>
<span id="more"></span>
<p>开个玩笑，回归正题。</p>
<h3 id="为什么访问不了以及访问速度会很慢？"><a href="#为什么访问不了以及访问速度会很慢？" class="headerlink" title="为什么访问不了以及访问速度会很慢？"></a>为什么访问不了以及访问速度会很慢？</h3><p>GitHub在中国大陆访问速度慢的问题原因有很多，但最直接和最主要的原因是GitHub的分发加速网络的域名遭到DNS污染。</p>
<p>由于GitHub的加速分发CDN域名assets-cdn.github.com遭到DNS污染，导致无法连接使用GitHub的加速分发服务器，才使得中国大陆访问速度很慢。</p>
<p><img data-src="github_problem.png" alt="problem"></p>
<h3 id="如何解决DNS污染？"><a href="#如何解决DNS污染？" class="headerlink" title="如何解决DNS污染？"></a>如何解决DNS污染？</h3><p>一般的DNS问题都可以通过修改Hosts文件来解决，GitHub的CDN域名被污染问题也不例外，同样可以通过修改Hosts文件解决。</p>
<p>将域名解析直接指向IP地址来绕过DNS的解析，以此解决污染问题。</p>
<h4 id="获取被污染域名的实际IP地址"><a href="#获取被污染域名的实际IP地址" class="headerlink" title="获取被污染域名的实际IP地址"></a>获取被污染域名的实际IP地址</h4><p>访问<a href="https://www.ipaddress.com">ipaddress.com</a>,使用ip lookup 工具获得相关域名的ip地址。</p>
<p>例如： github.com</p>
<p><img data-src="github_ipaddress.png" alt="ip address"></p>
<p>可以看到，我查出的域名ip地址为： <code>192.30.253.112</code> 和 <code>192.30.253.113</code> (任取一个即可)</p>
<h4 id="修改host文件，在文件中添加一行："><a href="#修改host文件，在文件中添加一行：" class="headerlink" title="修改host文件，在文件中添加一行："></a>修改host文件，在文件中添加一行：</h4><p><strong>[注] ： windows的hosts文件位置为： </strong><br><code>C:/windows/system32/drivers/etc/hosts</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.30.253.112 github.com</span><br></pre></td></tr></table></figure>
<h4 id="刷新dns缓存"><a href="#刷新dns缓存" class="headerlink" title="刷新dns缓存"></a>刷新dns缓存</h4><p>打开命令行cmd,输入如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ipconfig /flushdns</span><br></pre></td></tr></table></figure>
<p>此时再刷新页面即可。此时可以正常访问github，但是访问速度还是很慢，我们接着做优化。</p>
<h4 id="Github-访问提速"><a href="#Github-访问提速" class="headerlink" title="Github 访问提速"></a>Github 访问提速</h4><p>在hosts文件中继续加入，如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># GitHub Start</span><br><span class="line">192.30.253.112 github.com</span><br><span class="line">192.30.253.119 gist.github.com</span><br><span class="line">151.101.228.133 assets-cdn.github.com</span><br><span class="line">151.101.228.133 raw.githubusercontent.com</span><br><span class="line">151.101.228.133 gist.githubusercontent.com</span><br><span class="line">151.101.228.133 cloud.githubusercontent.com</span><br><span class="line">151.101.228.133 camo.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars0.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars1.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars2.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars3.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars4.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars5.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars6.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars7.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars8.githubusercontent.com</span><br><span class="line">192.30.253.116  api.github.com</span><br><span class="line"># GitHub End</span><br></pre></td></tr></table></figure>
<div class="note warning"><p><strong>注意</strong> : 这里域名对应的ip是通过dns查询工具查询得到的，你应当选择的是延时相对较小且比较稳定的ip。</p>
</div>
<p>例如，上面的<code>151.101.228.133</code>是对我来说较好的ip:</p>
<p><img data-src="ping_test.png" alt="dns 查询检测"></p>
<div class="note info"><p>推荐的dns查询检测工具：</p>
<ul>
<li><a href="https://tool.lu/dns/">DNS查询 - 在线工具</a></li>
<li><a href="http://tool.chinaz.com/dns/">DNS检测|DNS查询-站长工具</a></li>
</ul>
<p>你可对单个域名多查询几次，以挑选稳定且速度较快的ip。</p>
</div>
<h4 id="快速地访问github"><a href="#快速地访问github" class="headerlink" title="快速地访问github"></a>快速地访问github</h4><p>再次刷新dns缓存后，你已经可以快速地访问github了。</p>
<p><img data-src="github_test.gif" alt=""></p>
<div class="note primary"><p>参考：<a href="https://github.com/chenxuhua/issues-blog/issues/3">https://github.com/chenxuhua/issues-blog/issues/3</a></p>
</div>
]]></content>
      <categories>
        <category>tips</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Docker 运行 Oracle 数据库</title>
    <url>/posts/c5182a98/</url>
    <content><![CDATA[<p>虽然之前上过 oracle 数据库相关的课程，但学得比较浅，上完课后也没怎么使用到 oracle 数据库，一般都使用 mysql、mariadb 等。</p>
<p>最近因为工作需要，不得不重新认真学学 Oracle 数据库了「重复学习真的很浪费时间😓」，而首先需要考虑的就是如何安装一个 oracle 数据库了，之前已有在 windows 系统下直接安装 oracle 数据库的经验。</p>
<p>理论上，再在 win10 上安装一个 oracle 数据库很简单，但我平时主要使用笔记本电脑上的 manjaro 系统，其他的系统只是备用而已。</p>
<span id="more"></span>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>自从用了 Docker 之后，平时自己在学习或开发，遇到需要在本机上搭建相关环境时，就会很自然地想到能不能使用 Docker 容器来处理呢！</p>
<p>主要是想让搭建的开发环境与系统环境隔离，我们只在需要使用时才启动相关的容器。当我们不需要使用到该已搭建的环境时，也方便清理！</p>
<p>既然已经决定要使用 Docker 来安装并运行 oracle 数据库，那么我们应该首先看看官方有没有提供相应的镜像，如果有的话，我们便可以直接 <code>pull</code> 下来，然后运行即可。没有，我们也可从基础镜像开始配置，如从 <code>oracle-linux</code> 开始，一层一层去配置我们需要的镜像。</p>
<h2 id="1-资源下载及准备"><a href="#1-资源下载及准备" class="headerlink" title="1. 资源下载及准备"></a>1. 资源下载及准备</h2><p>好在通过 google 直接搜 「run oracle database using docker」，便有了相关的资源。</p>
<p>我选择了 oracle 在 github 上提供的 <a href="https://github.com/oracle/docker-images/tree/master/OracleDatabase/SingleInstance">docker-image</a> 库。他们也提供了相应的 README.md，给出了如何构建及运行 oracle 镜像的说明。</p>
<p>接下来，我将以 Oracle Database 12c Release 1 (12.1.0.2) Enterprise Edition and Standard Edition 2 为例，简单介绍该镜像的构建及运行使用。</p>
<h3 id="1-1-镜像构建"><a href="#1-1-镜像构建" class="headerlink" title="1.1 镜像构建"></a>1.1 镜像构建</h3><p>将 docker-image 库下 <code>OracleDatabase</code> 目录下的所有文件下载下来后，在构建相应版本数据库之前，我们还需要从 <a href="http://www.oracle.com/technetwork/database/enterprise-edition/downloads/index.html">Oracle Technology Network</a> 上下载需要构建数据库版本相应的 linux x86 二进制安装包，放到 <code>OracleDatabase/SingleInstance/dockerfiles/&lt;version&gt;</code>  目录中。</p>
<p>接着，只需要执行 <code>buildDockerImage.sh</code> 即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[oracle@localhost dockerfiles]$ ./buildDockerImage.sh -h</span><br><span class="line"></span><br><span class="line">Usage: buildDockerImage.sh -v [version] [-e | -s | -x] [-i] [-o] [Docker build option]</span><br><span class="line">Builds a Docker Image for Oracle Database.</span><br><span class="line"></span><br><span class="line">Parameters:</span><br><span class="line">   -v: version to build</span><br><span class="line">       Choose one of: 11.2.0.2  12.1.0.2  12.2.0.1  18.3.0  18.4.0  19.3.0</span><br><span class="line">   -e: creates image based on &#x27;Enterprise Edition&#x27;</span><br><span class="line">   -s: creates image based on &#x27;Standard Edition 2&#x27;</span><br><span class="line">   -x: creates image based on &#x27;Express Edition&#x27;</span><br><span class="line">   -i: ignores the MD5 checksums</span><br><span class="line">   -o: passes on Docker build option</span><br><span class="line"></span><br><span class="line">* select one edition only: -e, -s, or -x</span><br><span class="line"></span><br><span class="line">LICENSE UPL 1.0</span><br><span class="line"></span><br><span class="line">Copyright (c) 2014-2019 Oracle and/or its affiliates. All rights reserved.</span><br></pre></td></tr></table></figure>
<p>因为我们要构建 12.1.0.2 企业版数据库，因此执行 <code>./buildDockerImage.sh -v 12.1.0.2 -e</code>。<br><div class="note info"><p>需要注意的，完成该构建镜像过程后，只是生成安装了 Oracle 二进制文件的镜像。在容器第一次启动时，才会创建一个新的数据库实例，当数据库准备好可以使用时，会打印以下几行提示：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#########################</span><br><span class="line">DATABASE IS READY TO USE!</span><br><span class="line">#########################</span><br></pre></td></tr></table></figure></p>
</div></p>
<p>以上是我们使用官方提供的 Dockerfile 来构建的镜像的例子，当然我们也可以使用我们编写的 Dockerfile 来扩展镜像，如创建用户和表空间等。</p>
<blockquote>
<p>官方提供的 Dockerfile 使用 oracle-linux 作为镜像基础层。</p>
</blockquote>
<p>数据库的字符集编码会在镜像构建过程中进行配置。11g Express Edition 仅支持 UTF-8，标准版 2 和企业版可以在我们第一次运行容器时进行配置，可为不同表空间配置不同的字符集。</p>
<div class="note warning"><p>我们知道，docker 在构建镜像时，会将所有需要使用到的文件打包传送到构建上下文 (build context) 中，交由 dockerd 服务器来执行构建。</p>
<p>因此，我们应该尽量让构建上下文只包含我们需要的文件，必要时请使用 <code>.dokerignore</code> 文件，来忽略构建镜像时不需要用到的文件。</p>
</div>
<p>镜像的构建过程可能需要花费点时间。以我为例，我选择的数据库版本下载下来的安装包大概 4G 左右，然后构建镜像需要 22 步（22 层），花了将近一个小时吧。</p>
<p>镜像的构建过程大概如下（仅列出关键步）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">Building image &#x27;oracle/database:12.2.0.1-ee&#x27; ...</span><br><span class="line">Sending build context to Docker daemon  3.454GB</span><br><span class="line">Step 1/22 : FROM oraclelinux:7-slim as base</span><br><span class="line">...</span><br><span class="line">Step 2/22 : LABEL &quot;provider&quot;=&quot;Oracle&quot;                                                     &quot;issues&quot;=&quot;https://github.com/oracle/docker-images/issues&quot;               &quot;volume.data&quot;=&quot;/opt/oracle/oradata&quot;                                     &quot;volume.setup.location1&quot;=&quot;/opt/oracle/scripts/setup&quot;                    &quot;volume.setup.location2&quot;=&quot;/docker-entrypoint-initdb.d/setup&quot;            &quot;volume.startup.location1&quot;=&quot;/opt/oracle/scripts/startup&quot;                &quot;volume.startup.location2&quot;=&quot;/docker-entrypoint-initdb.d/startup&quot;        &quot;port.listener&quot;=&quot;1521&quot;                                                  &quot;port.oemexpress&quot;=&quot;5500&quot;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Step 3/22 : ENV ORACLE_BASE=/opt/oracle     ORACLE_HOME=/opt/oracle/product/12.2.0.1/dbhome_1     INSTALL_DIR=/opt/install     INSTALL_FILE_1=&quot;linuxx64_12201_database.zip&quot;     INSTALL_RSP=&quot;db_inst.rsp&quot;     CONFIG_RSP=&quot;dbca.rsp.tmpl&quot;     PWD_FILE=&quot;setPassword.sh&quot;     RUN_FILE=&quot;runOracle.sh&quot;     START_FILE=&quot;startDB.sh&quot;     CREATE_DB_FILE=&quot;createDB.sh&quot;     SETUP_LINUX_FILE=&quot;setupLinuxEnv.sh&quot;     CHECK_SPACE_FILE=&quot;checkSpace.sh&quot;     CHECK_DB_FILE=&quot;checkDBStatus.sh&quot;     USER_SCRIPTS_FILE=&quot;runUserScripts.sh&quot;     INSTALL_DB_BINARIES_FILE=&quot;installDBBinaries.sh&quot;</span><br><span class="line">...</span><br><span class="line">Step 4/22 : ENV PATH=$ORACLE_HOME/bin:$ORACLE_HOME/OPatch/:/usr/sbin:$PATH     LD_LIBRARY_PATH=$ORACLE_HOME/lib:/usr/lib     CLASSPATH=$ORACLE_HOME/jlib:$ORACLE_HOME/rdbms/jlib</span><br><span class="line">...</span><br><span class="line">Step 5/22 : COPY $SETUP_LINUX_FILE $CHECK_SPACE_FILE $INSTALL_DIR/</span><br><span class="line">...</span><br><span class="line">Step 6/22 : COPY $RUN_FILE $START_FILE $CREATE_DB_FILE $CONFIG_RSP $PWD_FILE $CHECK_DB_FILE $USER_SCRIPTS_FILE $ORACLE_BASE/</span><br><span class="line">...</span><br><span class="line">Step 7/22 : RUN chmod ug+x $INSTALL_DIR/*.sh &amp;&amp;     sync &amp;&amp;     $INSTALL_DIR/$CHECK_SPACE_FILE &amp;&amp;     $INSTALL_DIR/$SETUP_LINUX_FILE &amp;&amp;     rm -rf $INSTALL_DIR</span><br><span class="line">...</span><br><span class="line">Step 8/22 : FROM base AS builder</span><br><span class="line">...</span><br><span class="line">Step 9/22 : ARG DB_EDITION</span><br><span class="line">...</span><br><span class="line">Step 10/22 : RUN yum -y install unzip</span><br><span class="line">...</span><br><span class="line">Step 11/22 : COPY --chown=oracle:dba $INSTALL_FILE_1 $INSTALL_RSP $INSTALL_DB_BINARIES_FILE $INSTALL_DIR/</span><br><span class="line">...</span><br><span class="line">Step 12/22 : USER oracle</span><br><span class="line">...</span><br><span class="line">Step 13/22 : RUN chmod ug+x $INSTALL_DIR/*.sh &amp;&amp;     sync &amp;&amp;     $INSTALL_DIR/$INSTALL_DB_BINARIES_FILE $DB_EDITION</span><br><span class="line">...</span><br><span class="line">Step 14/22 : FROM base</span><br><span class="line">...</span><br><span class="line">Step 15/22 : USER oracle</span><br><span class="line">...</span><br><span class="line">Step 16/22 : COPY --chown=oracle:dba --from=builder $ORACLE_BASE $ORACLE_BASE</span><br><span class="line">...</span><br><span class="line">Step 17/22 : USER root</span><br><span class="line">...</span><br><span class="line">Step 18/22 : RUN $ORACLE_BASE/oraInventory/orainstRoot.sh &amp;&amp;     $ORACLE_HOME/root.sh</span><br><span class="line">...</span><br><span class="line">Step 19/22 : USER oracle</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>构建完成后，我们使用 <code>docker images</code> 来查看相关的镜像。</p>
<p><img data-src="docker-built-oracle-images.png" alt=""></p>
<h2 id="2-运行及使用"><a href="#2-运行及使用" class="headerlink" title="2. 运行及使用"></a>2. 运行及使用</h2><p>由于我们构建的 oracle 数据库是企业版 2，因此容器运行主要参考如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --name &lt;container name&gt; \</span><br><span class="line">-p &lt;host port&gt;:1521 -p &lt;host port&gt;:5500 \</span><br><span class="line">-e ORACLE_SID=&lt;your SID&gt; \</span><br><span class="line">-e ORACLE_PDB=&lt;your PDB name&gt; \</span><br><span class="line">-e ORACLE_PWD=&lt;your database passwords&gt; \</span><br><span class="line">-e ORACLE_CHARACTERSET=&lt;your character set&gt; \</span><br><span class="line">-v [&lt;host mount point&gt;:]/opt/oracle/oradata \</span><br><span class="line">oracle/database:19.3.0-ee</span><br><span class="line"></span><br><span class="line">Parameters:</span><br><span class="line">   --name:        The name of the container (default: auto generated)</span><br><span class="line">   -p:            The port mapping of the host port to the container port. </span><br><span class="line">                  Two ports are exposed: 1521 (Oracle Listener), 5500 (OEM Express)</span><br><span class="line">   -e ORACLE_SID: The Oracle Database SID that should be used (default: ORCLCDB)</span><br><span class="line">   -e ORACLE_PDB: The Oracle Database PDB name that should be used (default: ORCLPDB1)</span><br><span class="line">   -e ORACLE_PWD: The Oracle Database SYS, SYSTEM and PDB_ADMIN password (default: auto generated)</span><br><span class="line">   -e ORACLE_CHARACTERSET:</span><br><span class="line">                  The character set to use when creating the database (default: AL32UTF8)</span><br><span class="line">   -v /opt/oracle/oradata</span><br><span class="line">                  The data volume to use for the database.</span><br><span class="line">                  Has to be writable by the Unix &quot;oracle&quot; (uid: 54321) user inside the container!</span><br><span class="line">                  If omitted the database will not be persisted over container recreation.</span><br><span class="line">   -v /opt/oracle/scripts/startup | /docker-entrypoint-initdb.d/startup</span><br><span class="line">                  Optional: A volume with custom scripts to be run after database startup.</span><br><span class="line">                  For further details see the &quot;Running scripts after setup and on startup&quot; section below.</span><br><span class="line">   -v /opt/oracle/scripts/setup | /docker-entrypoint-initdb.d/setup</span><br><span class="line">                  Optional: A volume with custom scripts to be run after database setup.</span><br><span class="line">                  For further details see the &quot;Running scripts after setup and on startup&quot; section below.</span><br></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --name dev-oracle-database \</span><br><span class="line">-p 1521:1521 -p 5500:5500 \</span><br><span class="line">-e ORACLE_SID=ORCLCDB \</span><br><span class="line">-e ORACLE_PDB=ORCLPDB1 \</span><br><span class="line">-e ORACLE_PWD=&lt;your password&gt; \</span><br><span class="line">-e ORACLE_CHARACTERSET=UTF-8 \</span><br><span class="line">-v ./docker-volumes/dev-oracle-database/oradata:/opt/oracle/oradata \</span><br><span class="line">-d oracle/database:12.2.0.1-ee</span><br></pre></td></tr></table></figure>
<p>在容器启动后及数据库创建完成后，我们可以通过以下方式连接数据库：</p>
<div class="note info"><p>如果本机系统上没有 oracle 数据库的客户端，我们可以直接 <code>docker exec -it &lt;container_id&gt; or &lt;container_name&gt; bash</code> 进入容器，之后再使用容器中提供的 <code>sqlplus</code> 去连接数据库。</p>
<p>oracle-linux 系统中肯定是有相应的工具的。</p>
<p>当然啦，当本机上有 Oracle 数据库客户端后，就可以用我们熟悉的方式去连接数据库了。</p>
</div>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sqlplus sys/&lt;your password&gt;@//localhost:1521/&lt;your SID&gt; as sysdba</span><br><span class="line">sqlplus system/&lt;your password&gt;@//localhost:1521/&lt;your SID&gt;</span><br><span class="line">sqlplus pdbadmin/&lt;your password&gt;@//localhost:1521/&lt;Your PDB name&gt;</span><br></pre></td></tr></table></figure>
<p>该 oracle 数据库容器还配置了 OEM (Oracle Enterprise Manager) Express ,我们可以通过浏览器打开以下 URL 来访问:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://localhost:5500/em/</span><br></pre></td></tr></table></figure></p>
<div class="note info"><p>Oracle 数据库容器可以通过使用 <code>O_DIRECT</code> 标志来绕过一些文件的文件系统缓存。但不建议在不支持 <code>O_DIRECT</code> 标志的文件系统上运行容器。</p>
</div>
<p><strong>修改 admin 账号的密码</strong></p>
<p>如果第一次启动容器时没有指定密码的话，则会生成随机密码。我们可以在输出日志中的以下行，找到这些账号的密码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ORACLE PASSWORD FOR SYS, SYSTEM AND PDBADMIN:</span><br></pre></td></tr></table></figure>
<p>要修改这些账号的密码，我们可以通过 <code>docker exec</code> 去执行容器中的 <code>setPassword.sh</code> 脚本：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> &lt;container name&gt; ./setPassword.sh &lt;your password&gt;</span><br></pre></td></tr></table></figure>
<div class="note warning"><p>其他版本的数据库的容器的运行与上面提到的企业版和标准版 2 有点不一样，具体可以参考<br>Oracle 在 docker-image 库中给出相关 README.md 文件。</p>
</div>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>本文主要简单介绍了，如何使用 oracle 提供的 docker-image 库构建自己想要的 oracle 数据库镜像，然后运行并使用已构建的镜像。</p>
<p>实际上，除了使用 oracle 提供的 docker-image 库自己构建相应的镜像外（能使用提供的 Dockerfile 进行自定义），我们也能直接通过类似 <code>docker pull store/oracle/database-enterprise:12.2.0.1-slim</code> 命令直接从官方库上下相应的镜像。</p>
<p><strong>References</strong></p>
<ol>
<li><a href="https://github.com/oracle/docker-images/tree/master/OracleDatabase/SingleInstance">https://github.com/oracle/docker-images/tree/master/OracleDatabase/SingleInstance</a></li>
<li><a href="https://dzone.com/articles/oracle-12c-image-installation-in-docker">https://dzone.com/articles/oracle-12c-image-installation-in-docker</a></li>
</ol>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot + Docker + Nginx 负载均衡实现</title>
    <url>/posts/39885a36/</url>
    <content><![CDATA[<p>Nginx 是高性能的 http 服务器，反向代理服务器。结合 Tomcat 一起使用可以很容易实现负载均衡。</p>
<p>本文主要介绍使用 SpringBoot + Docker + Nginx 实现的负载均衡的一次简单实践。</p>
<p><img data-src="/images/Dev/springboot-docker-load-balancing/sb-nginx-load-balancing.png" alt=""></p>
<span id="more"></span>
<h2 id="1-构建-SpringBoot-项目-Docker-镜像"><a href="#1-构建-SpringBoot-项目-Docker-镜像" class="headerlink" title="1. 构建 SpringBoot 项目 Docker 镜像"></a>1. 构建 SpringBoot 项目 Docker 镜像</h2><p>我个人使用 docker 已经有一段时间了，虽然仍有许多未掌握的内容，但它确实在开发过程中给我带来了极大的便利。docker 能够为开发者提供一致的开发环境和部署环境，很好地提升了编程开发体验。接下来，我将给出两个几乎相同的 SpringBoot 项目，然后用 docker 来构建镜像。</p>
<h3 id="1-1-SpringBoot-项目"><a href="#1-1-SpringBoot-项目" class="headerlink" title="1.1 SpringBoot 项目"></a>1.1 SpringBoot 项目</h3><p>由于我们的主要目的是实现负载均衡，因此只需要简单的 SpringBoot 项目实现即可。</p>
<ol>
<li>创建 SpringBoot 项目，添加 <code>spring-boot-starter-web</code> 和  <code>spring-boot-starter-test</code> 依赖就可以了；</li>
<li>然后，编译一个简单的 <code>RestController</code>，写一个处理 <code>GET</code> 请求 Mapping，返回一个字符串即可。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Demo1Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/app&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sayHello/&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(<span class="meta">@PathVariable(&quot;name&quot;)</span> String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + name + <span class="string">&quot; from demo1. &quot;</span> + <span class="keyword">new</span> Date().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第二个 SpringBoot 也是类似的，为了区分，我们将 <code>/app/sayHello&#123;name&#125;</code> 的返回字符串改为 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + name + <span class="string">&quot; from demo2 at &quot;</span> + <span class="keyword">new</span> Date().toString();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="编写-Dockerfile"><a href="#编写-Dockerfile" class="headerlink" title="编写 Dockerfile"></a>编写 Dockerfile</h4><p>我们知道，运行 SpringBoot 项目，是通过 <code>java -jar xxx.jar</code> 的方式来运行的。因此我们可以编写如下 <code>Dockerfile</code>：</p>
<p>sb-demo1 <code>Dockerfile</code>:<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">MAINTAINER</span> rovo98 &lt;rovo984sff@gmail.com&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /tmp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> target/demo1-0.0.1-SNAPSHOT.jar app1.jar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [ <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;java -Djava.security.egd=file:/dev/./urandom -jar /app1.jar&quot;</span> ]</span></span><br></pre></td></tr></table></figure></p>
<p>sb-demo2 <code>Dockerfile</code>:<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">MAINTAINER</span> rovo98 &lt;rovo984sff@gmail.com&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /tmp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> target/demo2-0.0.1-SNAPSHOT.jar app2.jar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [ <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;java -Djava.security.egd=file:/dev/./urandom -jar /app2.jar&quot;</span> ]</span></span><br></pre></td></tr></table></figure></p>
<div class="note info"><p>关于 <code>-Djava.security.egd=file:/dev/./urandom</code> 系统属性的作用：主要是为了提升 docker 容器中 Tomcat 启动的性能。</p>
<p>Tomcat 使用 <code>java.security.SecureRandom</code> 来提供密码学上安全性强的伪随机数。类 Unix 系统具有一个特殊的文件 <code>/dev/random</code> 来通过访问从设备驱动程序和其他源收集的环境噪声来提供伪随机数。这这种情况下，如果请求大于熵，则会发生阻塞。而 <code>/dev/urandom</code> 则永远不会阻塞，即使伪随机数产生器的种子在启动时没有完全用熵初始化。另外，还有一个 <code>/dev/arandom</code>特殊文件，它则是在启动时阻塞，直到种子已经完全初始化为止，之后就再也不会阻塞了。</p>
<p>默认情况下，JVM 使用 <code>/dev/random</code> 作为 <code>SecureRandom</code> 的伪随机数生成器，因此，Java 代码可能会以我们不期望的方式进行阻塞。<code>-Djava.security.egd=file:/dev/./urandom</code> 就是为了告诉JVM 使用 <code>/dev/urandom</code> 而不是 <code>/dev/random</code> 的。</p>
<p>额外的  <code>/./</code> 似乎是让 JVM 使用 <code>SHA1PRNG</code> 算法作为 PRNG (Pseudo Random Number Generater，伪随机数生成器)的基础。它要比<code>/dev/urandom</code> 的原始伪随机数生成算法要强。</p>
</div>
<h3 id="1-2-构建镜像的方式"><a href="#1-2-构建镜像的方式" class="headerlink" title="1.2 构建镜像的方式"></a>1.2 构建镜像的方式</h3><ol>
<li><p>直接通过 <code>docker image build -t &lt;tag&gt; &lt;context_location&gt;</code> 命令来进行构建:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker image build -t springboot-docker-demo/sb-demo1:latest .</span><br></pre></td></tr></table></figure>
</li>
<li><p>maven 项目可以使用 <code>dockerfile-maven-plugin</code> 插件来构建镜像:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dockerfile-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span>$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                    &lt;tag&gt;$&#123;version&#125;&lt;/tag&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>unpack<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>unpack<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactItems</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactItem</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>$&#123;project.groupId&#125;<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">artifactItem</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">artifactItems</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>之后使用如 <code>mvn clean compiler:compile jar:jar spring-boot:repackage dockerfile:build</code> 这样的命令即可构建出相应的镜像。</p>
<h2 id="2-配置-Nginx"><a href="#2-配置-Nginx" class="headerlink" title="2. 配置 Nginx"></a>2. 配置 Nginx</h2><p>同样地，还是使用 docker 来运行 nginx，但不管用什么方式，我们都只需要关注 nginx 的配置文件 <code>nginx.conf</code> 的编写，之后在运行 nginx 容器时，将相应的配置文件、日志目录等以数据卷的方式挂载到容器中即可。</p>
<h3 id="2-1-proxy-pass-反向代理"><a href="#2-1-proxy-pass-反向代理" class="headerlink" title="2.1 proxy_pass 反向代理"></a>2.1 proxy_pass 反向代理</h3><p>nginx 实现反向代理的方式非常简单，只需要在配置文件中的 <code>proxy_pass</code> 后写要代理的服务器的地址即可。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123; # simple reverse-proxy</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  domain2.com www.domain2.com;</span><br><span class="line">    access_log   logs/domain2.access.log  main;</span><br><span class="line"></span><br><span class="line">    # serve static files</span><br><span class="line">    location ~ ^/(images|javascript|js|css|flash|media|static)/  &#123;</span><br><span class="line">      root    /var/www/virtual/big.server.com/htdocs;</span><br><span class="line">      expires 30d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # pass requests for dynamic content to rails/turbogears/zope, et al</span><br><span class="line">    location / &#123;</span><br><span class="line">      proxy_pass      http://127.0.0.1:8080;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-upstream-负载均衡"><a href="#2-2-upstream-负载均衡" class="headerlink" title="2.2 upstream 负载均衡"></a>2.2 upstream 负载均衡</h3><p>类似地，实现负载均衡，也只需要对 nginx 的配置文件进行简单的修改即可。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream big_server_com &#123;</span><br><span class="line">    server 127.0.0.3:8000 weight=5;</span><br><span class="line">    server 127.0.0.3:8001 weight=5;</span><br><span class="line">    server 192.168.0.1:8000;</span><br><span class="line">    server 192.168.0.1:8001;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  server &#123; # simple load balancing</span><br><span class="line">    listen          80;</span><br><span class="line">    server_name     big.server.com;</span><br><span class="line">    access_log      logs/big.server.access.log main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">      proxy_pass      http://big_server_com;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>nginx 的配置文件参考 <a href="https://www.nginx.com/resources/wiki/start/topics/examples/full/">https://www.nginx.com/resources/wiki/start/topics/examples/full/</a></p>
<h2 id="3-运行方式"><a href="#3-运行方式" class="headerlink" title="3. 运行方式"></a>3. 运行方式</h2><p>上面我们已经准备好了所有需要的镜像，要运行这些镜像，启动容器，我们有以下几种方式。</p>
<h3 id="3-1-直接启动各容器"><a href="#3-1-直接启动各容器" class="headerlink" title="3.1 直接启动各容器"></a>3.1 直接启动各容器</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --rm -p 8080:8080 --name sb-demo1 -d springboot-docker-demo/demo1</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --rm -p 8089:8080 --name sb-demo2 -d springboot-docker-demo/demo2</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --rm -p 80:80 --name sb-nginx -d nginx:latest \</span><br><span class="line">-v ./nginx-data/conf/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">-v ./nginx-data/html:/etc/nginx/nginx/html</span><br><span class="line">-v ./nginx-data/<span class="built_in">log</span>:/var/<span class="built_in">log</span>/nginx</span><br></pre></td></tr></table></figure>
<p>此时，<code>nginx.conf</code>中关于负载均衡配置的部分应该这样编写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">upstream app &#123;</span><br><span class="line">    #ip_hash;</span><br><span class="line">    server localhost:8080 weight=1;</span><br><span class="line">    server localhost:8088 weight=1;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">        proxy_pass http://app;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种运行方式下，两个 SpringBoot 项目是暴露的，即我们能通过 <code>localhost:8080</code> 或 <code>localhost:8088</code> 来对 SpringBoot 应用进行访问。如果要只让 nginx 能被外界访问，而两个SpringBoot 项目不要被外界访问，我们可以使用 <code>docker network</code> 来创建一个网络，用于连接这些容器。</p>
<h3 id="3-2-docker-compose-方式"><a href="#3-2-docker-compose-方式" class="headerlink" title="3.2 docker-compose 方式"></a>3.2 docker-compose 方式</h3><p>docker-compose 是 docker 提供的定义由多个容器组成的应用的方式，以更好地组织和管理多个容器组成的应用。为了运行我们的应用，我们可以编写以下 <code>docker-compose.yml</code> 文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">app1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">springboot-docker-demo/demo1:latest</span></span><br><span class="line">    <span class="comment">#    build: ./demo1 # if using build approach, un-comment demo1 dir in .dockerignore file.</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">sb-demo1</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">webnet:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">10.0</span><span class="number">.1</span><span class="number">.4</span></span><br><span class="line">  <span class="attr">app2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">springboot-docker-demo/demo2:latest</span></span><br><span class="line">    <span class="comment">#    build: ./demo2 # if using build approach, un-comment demo2 dir in .dockerignore file.</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">sb-demo2</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">webnet:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">10.0</span><span class="number">.1</span><span class="number">.3</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">sb-nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx-data/conf/nginx.conf:/etc/nginx/nginx.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx-data/html:/etc/nginx/nginx/html</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx-data/log:/var/log/nginx</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">webnet:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">10.0</span><span class="number">.1</span><span class="number">.2</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">webnet:</span></span><br><span class="line">    <span class="attr">ipam:</span></span><br><span class="line">      <span class="attr">driver:</span> <span class="string">default</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">subnet:</span> <span class="number">10.0</span><span class="number">.1</span><span class="number">.0</span><span class="string">/24</span></span><br></pre></td></tr></table></figure>
<p>执行 <code>docker-compose up -d</code> 来运行，通过这种方式，能让所有的容器运行在同一个网络中，并只让 nginx 暴露出 80 端口，以供外部访问。</p>
<p>不过，需要注意的是，为了方便，我在创建网络时配置了子网，并为各个容器指定了固定 ip 地址。这时，<code>nginx.conf</code> 中 upstream 部分应该改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream app &#123;</span><br><span class="line">    #ip_hash;</span><br><span class="line">    server 10.0.1.4:8080 weight=1;</span><br><span class="line">    server 10.0.1.3:8088 weight=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-使用-docker-stack-deploy-部署到-swarm-集群上"><a href="#3-3-使用-docker-stack-deploy-部署到-swarm-集群上" class="headerlink" title="3.3 使用 docker stack deploy 部署到 swarm 集群上"></a>3.3 使用 docker stack deploy 部署到 swarm 集群上</h3><p>通过 <code>docker stack deploy docker-compose.yml</code> 的方式能够将应用部署到 swarm 集群上。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create three virtualbox machines</span></span><br><span class="line">docker-machine create --driver virtualbox myvm1</span><br><span class="line">docker-machine create --driver virtualbox myvm2</span><br><span class="line">docker-machine create --driver virtualbox myvm3</span><br></pre></td></tr></table></figure>
<p><code>docker-machine ls</code>:</p>
<p><img data-src="sb-docker-stack-machines.png" alt=""></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create a swarm</span></span><br><span class="line">docker swarm init --advertise-addr 192.168.1.100</span><br><span class="line"><span class="comment"># add host mahcine as  manager</span></span><br><span class="line">docker swarm join-token manager</span><br><span class="line"><span class="comment"># add virtual machines as workers</span></span><br><span class="line">docker-machine ssh myvm1 <span class="string">&quot;docker swarm join --token SWMTKN-1-10nk6yfukgx4ie1d739i8w43itzdzya2yvo51je0hgisvxqzkf-3awbtfab6h00873ic7njvt8yr 192.168.1.100:2377&quot;</span></span><br><span class="line">docker-machine ssh myvm2 <span class="string">&quot;docker swarm join --token SWMTKN-1-10nk6yfukgx4ie1d739i8w43itzdzya2yvo51je0hgisvxqzkf-3awbtfab6h00873ic7njvt8yr 192.168.1.100:2377&quot;</span></span><br><span class="line">docker-machine ssh myvm3 <span class="string">&quot;docker swarm join --token SWMTKN-1-10nk6yfukgx4ie1d739i8w43itzdzya2yvo51je0hgisvxqzkf-3awbtfab6h00873ic7njvt8yr 192.168.1.100:2377&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># deploy app to the swarm</span></span><br><span class="line">docker stack deploy -c docker-compose.yml sb-load-balancing-demo</span><br></pre></td></tr></table></figure>
<p>之后可使用 <code>docker service ls</code> 或 <code>docker stack services &lt;service_name&gt;</code> 来查看应用的部署情况。</p>
<h3 id="运行结果测试"><a href="#运行结果测试" class="headerlink" title="运行结果测试"></a>运行结果测试</h3><p>为了更快地测试结果，我使用的 <code>docker-compose</code> 的运行方式。</p>
<p><img data-src="sb-load-balancing-result-testing.gif" alt=""></p>
<p>可以看到，在刷新后，nginx 能够将请求分发给另一个 SpringBoot 应用，来实现负载均衡。当然，我们还可以结合 <code>ip_hash</code> 使用，此时，客户端第一次访问应用时，会分配到一个特定 SpringBoot 应用，之后再次访问时会继续访问同一个 SpringBoot 应用。</p>
<h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>使用 nginx 结合 Tomcat 实现负载均衡看起来是非常简单的，但有些事情必须要实际动手实践才能真正地掌握。在实践的过程中往往也能发现自己之前未能察觉的或他人未提到的问题。</p>
<p>使用 docker 确实能够让的人的开发体验有所提升，熟练使用 docker 后，在日常开发以及学习中，我们即便是在个人笔记本电脑上也能快速地搭建出需要的环境。</p>
<p>本文涉及相关源代码: <a href="https://github.com/rovo98/java-dev-practices/tree/master/dev-practices/springboot-docker-demo">springboot-docker-nginx-load-balacning</a></p>
<blockquote>
<p>references:</p>
<ol>
<li><a href="https://docs.nginx.com/nginx/admin-guide/web-server/web-server/">https://docs.nginx.com/nginx/admin-guide/web-server/web-server/</a></li>
<li><a href="https://stackoverflow.com/questions/58991966/what-java-security-egd-option-is-for">https://stackoverflow.com/questions/58991966/what-java-security-egd-option-is-for</a></li>
<li><a href="https://fbrx.github.io/post/fixing-tomcat-startup-performance-on-cloud-servers/">https://fbrx.github.io/post/fixing-tomcat-startup-performance-on-cloud-servers/</a></li>
<li><a href="https://docs.docker.com/develop/dev-best-practices/">https://docs.docker.com/develop/dev-best-practices/</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Practices</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>SpringBoot</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL - 查找并清除重复的数据行</title>
    <url>/posts/a264c38d/</url>
    <content><![CDATA[<p>在实际开发场景中，我们需要导入数据库中的数据可能包含重复的行（row）。当然如果在建表时，对数据表中相应的字段进行限制的话，则有可能不会出现这样的问题。</p>
<p>接下来，我们谈一谈，如果数据库中已有重复的数据行，我们该如何把它们找出来，并将这些数据行删除。</p>
<span id="more"></span>
<h2 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h2><p>为了方便后续进行处理展示，我们将创建一个简单的数据库，仅包含一个数据表，且该表包含重复的数据行。下面是创建测试用的数据库相应的 <code>sql</code> 脚本。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- NOTICE: noly for testing &#x27;find&amp;remove dupicate rows experiment&#x27;.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> schema IF <span class="keyword">EXISTS</span> testdb;</span><br><span class="line"><span class="keyword">CREATE</span> schema IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> testdb;</span><br><span class="line"></span><br><span class="line">USE testdb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student</span><br><span class="line">(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">5</span>),</span><br><span class="line">    mail <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">primary</span> key (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- insert data contains duplicate rows.</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">&#x27;Stu1&#x27;</span>, <span class="string">&#x27;stu1@testdb.com&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="number">2</span>, <span class="string">&#x27;Stu2&#x27;</span>, <span class="string">&#x27;stu2@testdb.com&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="number">3</span>, <span class="string">&#x27;Stu3&#x27;</span>, <span class="string">&#x27;stu3@testdb.com&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="number">4</span>, <span class="string">&#x27;Stu4&#x27;</span>, <span class="string">&#x27;stu4@testdb.com&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="number">5</span>, <span class="string">&#x27;Stu5&#x27;</span>, <span class="string">&#x27;stu5@testdb.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--  the following are duplcate rows.</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="number">6</span>, <span class="string">&#x27;Stu4&#x27;</span>, <span class="string">&#x27;stu4@testdb.com&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="number">7</span>, <span class="string">&#x27;Stu5&#x27;</span>, <span class="string">&#x27;stu5@testdb.com&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="2-查找重复的数据行"><a href="#2-查找重复的数据行" class="headerlink" title="2. 查找重复的数据行"></a>2. 查找重复的数据行</h2><p>查找重复数据行的业务需求 - 「找到名字<code>name</code>相同的数据行」。</p>
<ol>
<li>使用自连接 self <code>join</code>:<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s1.<span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">as</span> s1</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> student <span class="keyword">as</span> s2</span><br><span class="line">    <span class="keyword">ON</span> s1.name <span class="operator">=</span> s2.name</span><br><span class="line"><span class="keyword">WHERE</span> s1.id <span class="operator">&lt;&gt;</span> s2.id;</span><br></pre></td></tr></table></figure></li>
<li>使用子查询:<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s1.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">AS</span> s1</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span> name</span><br><span class="line">    <span class="keyword">FROM</span> student</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> name <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line">) <span class="keyword">AS</span> s2 <span class="keyword">ON</span> s1.name <span class="operator">=</span> s2.name;</span><br></pre></td></tr></table></figure></li>
<li>使用双表查询:<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s1.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> student s1, student s2</span><br><span class="line"><span class="keyword">WHERE</span> s1.name <span class="operator">=</span> s2.name <span class="keyword">AND</span> s1.id <span class="operator">&lt;&gt;</span> s2.id;</span><br></pre></td></tr></table></figure></li>
<li>使用 <code>group by</code>:<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, mail</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> name, mail</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="number">2</span>) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="3-删除重复的数据行"><a href="#3-删除重复的数据行" class="headerlink" title="3. 删除重复的数据行"></a>3. 删除重复的数据行</h2><p>要删除重复的数据行，与查找重复数据行的方式类似，使用 <code>delete from</code> 语法即可。</p>
<blockquote>
<p>删除重复的 <code>id</code> 字段较大的数据行，保留 <code>id</code> 较小的数据行</p>
</blockquote>
<ol>
<li>使用双表进行删除:<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> s1</span><br><span class="line"><span class="keyword">FROM</span> student s1, student s2</span><br><span class="line"><span class="keyword">WHERE</span> s1.name <span class="operator">=</span> s2.name <span class="keyword">AND</span> s1.id <span class="operator">&gt;</span> s2.id;</span><br></pre></td></tr></table></figure></li>
<li>使用自链接 self join:<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> s1</span><br><span class="line"><span class="keyword">FROM</span> student s1</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> student s2</span><br><span class="line"><span class="keyword">ON</span> s1.name <span class="operator">=</span> s2.name</span><br><span class="line"><span class="keyword">WHERE</span> s1.id <span class="operator">&gt;</span> s2.id;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是关于查找和删除数据库中重复数据行的相关方法，需要说明的是，除了上面提到的 sql 以外，相信还有更多的实现方式。从简单易用的角度来考虑的话，双表以及自链接的实现方式都是不错的选择。</p>
<p>最后，对于已相关 sql 实现方法，我们并未对 sql 执行的性能进行测试。</p>
<blockquote>
<p>References</p>
<ul>
<li><a href="https://www.dbrnd.com/2015/09/find-duplicate-records-in-mysql/">https://www.dbrnd.com/2015/09/find-duplicate-records-in-mysql/</a></li>
<li><a href="https://howtodoinjava.com/sql/how-to-remove-duplicate-rows-in-mysql-without-using-temporary-table/">https://howtodoinjava.com/sql/how-to-remove-duplicate-rows-in-mysql-without-using-temporary-table/</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Dev</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM知识体系(二) | 内存管理</title>
    <url>/posts/57a6bf72/</url>
    <content><![CDATA[<p><img data-src="/images/java/basic/run-time-data-areas.png" alt="run-time-data-areas"><br>主要简单的了解JVM的内存区(Memory Area)以及GC(Garbage Collection)垃圾回收机制。</p>
<span id="more"></span>
<h2 id="一、内存结构"><a href="#一、内存结构" class="headerlink" title="一、内存结构"></a>一、内存结构</h2><p>Java虚拟机定义了许多的<strong>运行时数据区(run-time data areas)</strong>, 供程序执行时使用。</p>
<p>其中，一些数据区域随着JVM的创建而创建，只有在JVM退出时在销毁，即属于JVM。<br>而其他的数据区随着进程(<em>Thread</em>)的创建而创建，进程销毁时也随之销毁(每个线程独有)。</p>
<h3 id="1-逻辑分区"><a href="#1-逻辑分区" class="headerlink" title="1. 逻辑分区"></a>1. 逻辑分区</h3><p>JVM 内存在应用<strong>逻辑上</strong>可以分为以下区域:</p>
<h4 id="1-1-pc-Register-程序计数器"><a href="#1-1-pc-Register-程序计数器" class="headerlink" title="1.1.pc Register - 程序计数器"></a>1.1.pc Register - 程序计数器</h4><p>存放当前执行语句(JVM instruction)的物理地址，随线程创建而创建。(每个线程均需要一个程序计数器)</p>
<h4 id="1-2-JVM-Stacks-虚拟机栈"><a href="#1-2-JVM-Stacks-虚拟机栈" class="headerlink" title="1.2.JVM Stacks - 虚拟机栈"></a>1.2.JVM Stacks - 虚拟机栈</h4><p>每个java虚拟机线程都有个私有的java虚拟机栈，与线程同创建。Java虚拟机栈存储<strong>帧(Frame)</strong>, Java虚拟机栈类似于C语言中的栈：它用于保存局部变量(<strong>Thread-local variables</strong>), 并在方法的调用和返回中发挥作用。</p>
<div class="note warning"><ul>
<li>java虚拟机栈的内存分配不需要是连续的。</li>
<li>栈的大小可以是固定或动态扩展/收缩的，JVM允许我们对栈的初始大小进行控制，在动态扩展情况下，可以指定栈允许的最大和最小分配空间(通过<code>-Xss</code>和<code>-Xsx</code>来配置)。</li>
</ul>
<p><strong>Notice:</strong></p>
<ul>
<li>当线程中的计算需求超出Java虚拟机允许的范围时(线程请求的栈深度超过JVM运行深度), 会抛出<code>StackOverflowError</code>;</li>
<li>在允许动态扩展栈的大小的情况下，当无法满足一次扩展需求或剩余的内存不足以为一个新线程创建栈时， JVM会抛出<code>OutOfMemoryError</code>。</li>
</ul>
</div>
<h4 id="1-3-Heap-堆"><a href="#1-3-Heap-堆" class="headerlink" title="1.3.Heap - 堆"></a>1.3.Heap - 堆</h4><p>堆作为运行时数据区，为所有的类实例和数组分配内存，属于所有Java线程共享的。<strong>堆在JVM启动时创建，对象的堆存储由自动存储管理系统(GC)来回收</strong>, 对象永远不会被显式的释放。</p>
<div class="note warning"><ul>
<li>和线程栈一样，堆的大小是可以固定或动态扩展的，堆的内存不需要是连续的;</li>
<li>堆的大小动态调整范围指定通过<code>-Xms</code>和<code>-Xmx</code>来指定;</li>
</ul>
<p><strong>Notice:</strong></p>
<ul>
<li>当堆无法申请到内存时(即GC无法申请到内存时), JVM会抛出<code>OutOfMemoryError</code>。</li>
</ul>
</div>
<h4 id="1-4-Method-Area-方法区"><a href="#1-4-Method-Area-方法区" class="headerlink" title="1.4.Method Area - 方法区"></a>1.4.Method Area - 方法区</h4><p>和堆一样，方法区同样是所有线程共享的(随着JVM的启动而创建)。方法区存放每个类的类结构，如运行常量池(run-time constant pool)、字段(<em>field</em>)、构造方法和方法代码(包括类实例化方法)。</p>
<div class="note warning"><ul>
<li>虽然方法区在逻辑上是堆的一部分，但是垃圾收集器不会对它进行收集，Java SE8版本的规范没有对方法区的位置和对方法区中已编译代码的管理策略提出强制要求;</li>
<li>方法区同样是可以是固定大小或动态扩展的，内存也不需要是连续的;</li>
</ul>
<p><strong>Notice:</strong></p>
<ul>
<li>当方法区的内存无法满足内存申请需求时，JVM会抛出<code>OutOfMemoryError</code>。</li>
</ul>
</div>
<h4 id="1-5-Run-time-Constant-Pool-运行时常量池"><a href="#1-5-Run-time-Constant-Pool-运行时常量池" class="headerlink" title="1.5.Run-time Constant Pool - 运行时常量池"></a>1.5.Run-time Constant Pool - 运行时常量池</h4><p>通过之前对类文件<code>.class</code>格式的了解，我们知道每个类文件中都是有一个<code>constant_pool[constant_count]</code>的表(<em>Table</em>)的, 存放字符串常量，类和接口名称，字段名称以及类文件结构及其结构中引用的其他常量。</p>
<p>它包含几种常量，从编译时已知的数字字面量(<em>numeric literals</em>)到必须在运行时解析的方法和字段引用。</p>
<p>每个运行时常量池都是在上文提到的方法区中创建的，当<strong>当JVM创建类或接口时，将创建类或接口的运行常量池</strong>(其实，通过我们已经了解到的类加载机制，知道当类加载时是将类文件以二进制数据的形式加载到方法区中，运行时常量池的创建在类加载过程中完成)。</p>
<div class="note warning"><p>创建类或接口时，如果创建运行时常量池所需的内存大于方法区中的可用内存，则JVM将抛出<code>OutOfMemoryError</code>。</p>
</div>
<h4 id="1-6-Native-Method-Stacks-本地方法栈"><a href="#1-6-Native-Method-Stacks-本地方法栈" class="headerlink" title="1.6. Native Method Stacks - 本地方法栈"></a>1.6. Native Method Stacks - 本地方法栈</h4><p>JVM实现的传统栈(conventional stack), 也称为”C栈”, 用于支持Java编程语言以外的语言编写的方法。</p>
<p>本地方法栈也可以供诸如C语言的Java虚拟机指令集解释器的实现来使用。对于无法加载本地方法且本身不依赖于传统栈的Java虚拟机实现来说，并不需要提供本地方法栈。</p>
<p>如果JVM实现提供了本地方法栈，和线程栈一样，通常也是在创建每个线程时为每个线程分配一个本地方法栈。</p>
<div class="note warning"><ul>
<li>本地方法栈可以是固定大小或动态扩展的，当是固定大小时，可以在创建栈时独立选择每个本地方法栈的大小;</li>
</ul>
<p><strong>Notice: (和线程栈类似)</strong></p>
<ul>
<li>当线程中的计算需求超出Java虚拟机允许的范围时(线程请求的本地方法栈深度超过JVM运行深度), 会抛出<code>StackOverflowError</code>;</li>
<li>在允许动态扩展栈的大小的情况下，当无法满足一次扩展需求或剩余的内存不足以为一个新线程创建本地方法栈时， JVM会抛出<code>OutOfMemoryError</code>。</li>
</ul>
</div>
<div class="note primary"><p>此部分内容主要参考 JAVA SE 8 Java Virtual Machine Specification</p>
<ul>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5</a><br>其他参考链接:</li>
<li><a href="https://www.geeksforgeeks.org/java-memory-management/">https://www.geeksforgeeks.org/java-memory-management/</a></li>
<li><a href="https://howtodoinjava.com/java/garbage-collection/jvm-memory-model-structure-and-components/">https://howtodoinjava.com/java/garbage-collection/jvm-memory-model-structure-and-components/</a></li>
</ul>
</div>
<h3 id="2-内存模型"><a href="#2-内存模型" class="headerlink" title="2. 内存模型"></a>2. 内存模型</h3><p>JVM内存由以下的部分组成:</p>
<ul>
<li><strong>堆内存(Heap Memory)</strong>: 存放Java对象;</li>
<li><strong>非堆内存(Non-Heap Memory)</strong>: 用于java程序存储加载的类和其他元数据;</li>
<li>JVM本身代码，JVM内部结构，加载的探查器(Loaded profiler agent)代码和数据等。</li>
</ul>
<p><img data-src="jvm-2-jvm_memory_structure.gif" alt=""></p>
<h4 id="2-1-堆内存"><a href="#2-1-堆内存" class="headerlink" title="2.1 堆内存"></a>2.1 堆内存</h4><p>堆内存是运行时数据区，从中分配所有Java类实例和数组的内存，堆在JVM启动时创建，堆的大小可以是固定的或动态扩展的，堆的大小可以由以下的vm参数来指定:</p>
<ul>
<li><code>-Xms&lt;size&gt;</code>: 设置堆的初始大小;</li>
<li><code>-Xmx&lt;size&gt;</code>: 设置堆的最大内存大小.</li>
</ul>
<p>默认情况下，最大堆的大小设置为<code>64Mb</code>。</p>
<p>JVM 堆内存在物理上分为两个部分: 新生代(<strong>nursery or young generation</strong>)和老年代(<strong>old space or old generation</strong>)。<br>新生代是为分配新对象而保留的堆的部分空间。当新生代占满时，通过<strong>Minor GC</strong>对新生代区域执行垃圾回收动作，其中在新生代中生存足够长时间的所有对象(经历过若干次Minor GC后保留下来的对象)将被迁移到老年代, 从而释放新生代的空间以为更多的对象分配空间。</p>
<p><img data-src="jvm2-jvm-heap-memory-model.png" alt="jvm-heap-memory-model"></p>
<p><strong>Minor GC</strong>分为三个部分: <strong>伊甸园(Eden)</strong>区、和两个<strong>幸存区(Survivor) S0(from), S1(to)</strong></p>
<p><strong>关于新生代内存空间(Young Generation/Nursery):</strong></p>
<ul>
<li>大多数对象的创建都是位于<strong>Eden</strong>区的(因为有可能一些比较大的对象是直接在老年代中创建);</li>
<li>当Eden区填满对象时，执行Minor GC并将所有幸存对象移到其中一个幸存区空间;</li>
<li>Minor GC还会检查幸存区中的对象，并将幸存的对象移动到另一个幸存区，即幸存区总有一个是空的(即GC算法中的<code>mark-and-copy</code>算法);</li>
<li>在多次Minor GC中存活下来的对象会被移动到老年代中。至于经过多少次Minor GC能晋升到老年代由JVM决定，控制对象的“年龄阈值(这里的年龄指对象被移动的次数)”.</li>
</ul>
<p>Java 最近的版本中的新生代中还包含一个<strong>保留区(reserved)</strong>， 用于保存最近创建的对象，防止对象在Minor GC执行之前被提升。</p>
<p>关于老年代内存空间(<strong>Old Generation - Tenured</strong>)</p>
<p>当老年区填满时，老年区同样会执行垃圾收集，称为<strong>Major GC</strong>，老年代中包含那些从多次Minor GC中幸存的对象，通常执行一次Major GC 时间要比较长，因为Minor GC旨在快速找到在新生代中依然存活的对象并将它们移动，所以Minor GC执行的频率和速度都要Major GC的更大。</p>
<p>根据阈值限制，可以使用<code>-XX:+PrintTenuringDistribution</code>来检查，它按年龄来显示对象，将对象从<strong>Survivor</strong>空间移到<strong>Tenured</strong>空间中。</p>
<p>我们还有许多其他有用的参数设置，如<code>-XX:InitialTenuringThreshold</code>, <code>-XX:MaxTenuringThreshold</code>和<code>-XX:TargetSurvivorRatio</code>, 可以用它们来最大限度的利用<strong>tenured</strong>和<strong>survivor</strong>空间。<br>通过设置<code>-XX:InitialTenuringThreshold</code>和<code>-XX:MaxTenuringThreshold</code>来设置对象的“年龄”的初始值和允许的最大值。</p>
<p><img data-src="jvm2-jvm-java-memory-architecture.jpg" alt="java-memory-architecture"></p>
<h4 id="2-2-非堆内存"><a href="#2-2-非堆内存" class="headerlink" title="2.2 非堆内存"></a>2.2 非堆内存</h4><p>JVM堆以外内存，包含JVM缓存空间，类结构如运行常量池、字段和方法数据，方法构造方法。</p>
<h5 id="2-2-1-元空间-Metaspace"><a href="#2-2-1-元空间-Metaspace" class="headerlink" title="2.2.1.元空间(Metaspace)"></a>2.2.1.元空间(Metaspace)</h5><p>在Java8及以上版本已经没有了<strong>Permanent Generation 永久代</strong>这块区域，将不会再有关于<code>java.lang.OutOfMemoryError: PermGen</code>内存问题的存在。与驻留在Java堆中的<strong>Perm Gen</strong>不同，Metaspace 已经不是堆的一部分了。</p>
<p>类元数据多数情况下都是从本地内存中分配的。默认情况下，Metaspace会自动增加其大小(直接由底层操作系统提供支持), 而Perm Gen始终是有固定的上限的。我们可以是这两个vm参数来指定Metaspace 的大小: <code>-XX:MetaSpaceSize</code>和<code>-XX:MaxMetaspaceSize</code>。</p>
<p><strong>Metaspace</strong>背后的含义是类的生命周期机器元数据，这与类加载器的生命周期相匹配。也就是说只要类加载器处于活动中，元数据就会在Metaspace中保持活动状态且无法释放。</p>
<h5 id="2-2-2-代码缓存-Code-Cache"><a href="#2-2-2-代码缓存-Code-Cache" class="headerlink" title="2.2.2.代码缓存(Code Cache)"></a>2.2.2.代码缓存(Code Cache)</h5><p>运行Java程序时，它以分层的方式执行代码。在第一层，使用客户机编译器(C1 compiler)来编译代码。分析数据(<em>profiling data</em>)在服务器编译器的第二层中(C2 compiler)使用，以优化的方式编译该代码。默认情况下，Java7未启用分层编译，但在Java8中启用了分层编译。</p>
<p>即时编译器(JIT compiler)将编译的代码存储在称为<strong>代码缓存</strong>的区域中，它是一个用于保存已编译代码的特殊堆。如果该区域的大小超过阈值，则该区域将被刷新，且GC不会重新定位这些对象。</p>
<p>Java8中已经解决了一些性能问题和编译器未重新启用的问题，而在Java7中避免这些问题的方案之一是将代码缓存区域的大小增加到一个永远不会达到的程度。</p>
<h5 id="2-2-3-方法区-Method-Area"><a href="#2-2-3-方法区-Method-Area" class="headerlink" title="2.2.3.方法区(Method Area)"></a>2.2.3.方法区(Method Area)</h5><p>方法区是Perm Gen 空间的一部分，用于存储类结构(运行时常量池和静态变量)以及方法和构造方法的代码。</p>
<h5 id="2-2-4-内存池-Memory-Pool"><a href="#2-2-4-内存池-Memory-Pool" class="headerlink" title="2.2.4.内存池(Memory Pool)"></a>2.2.4.内存池(Memory Pool)</h5><p>内存池由JVM内存管理器创建，用于创建不可变对象池。内存池可以属于Heap或Perm Gen， 具体取决于JVM内存管理器的实现。</p>
<h5 id="2-2-5-运行时常量池-Run-time-Constant-Pool"><a href="#2-2-5-运行时常量池-Run-time-Constant-Pool" class="headerlink" title="2.2.5.运行时常量池(Run-time Constant Pool)"></a>2.2.5.运行时常量池(Run-time Constant Pool)</h5><p>运行时常量池，即每个类中的<code>constant_pool</code>表， 它包含类运行时常量和静态方法。运行时常量池是方法区的一部分。</p>
<h5 id="2-2-6-Java栈-Java-Stack"><a href="#2-2-6-Java栈-Java-Stack" class="headerlink" title="2.2.6.Java栈 (Java Stack)"></a>2.2.6.Java栈 (Java Stack)</h5><p>Java栈内存用于线程的执行。它们包含暂时的方法的特定值(Thread-local variables, 线程局部变量), 以及对从该方法引用的堆中其他对象的引用。</p>
<h4 id="2-3-Java-堆配置选项"><a href="#2-3-Java-堆配置选项" class="headerlink" title="2.3 Java 堆配置选项"></a>2.3 Java 堆配置选项</h4><p>Java提供了很多关于堆内存的配置选项，我们可以使用它们来设置内存大小及其比例。下面是一些常用的配置项:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">VM Switch</th>
<th style="text-align:center">VM Switch Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>-Xms</code></td>
<td style="text-align:center">用于在JVM启动时设置初始堆大小</td>
</tr>
<tr>
<td style="text-align:center"><code>-Xmx</code></td>
<td style="text-align:center">用于设置最大堆大小</td>
</tr>
<tr>
<td style="text-align:center"><code>-Xmn</code></td>
<td style="text-align:center">设置新生代区域的大小，剩下的空间用于老年代</td>
</tr>
<tr>
<td style="text-align:center"><code>-XX:PermGen</code></td>
<td style="text-align:center">用于设置永久代 Perm Gen 的初始大小</td>
</tr>
<tr>
<td style="text-align:center"><code>-XX:MaxPermGen</code></td>
<td style="text-align:center">用于设置Perm Gen的最大内存空间</td>
</tr>
<tr>
<td style="text-align:center"><code>-XX:SurvivorRatio</code></td>
<td style="text-align:center">设置Eden区的比例(Eden/Survivor)，如新生代大小为10M, -XX:SurvivorRatio=2, 则Eden空间将预留5M, Survivor各预留2.5M。默认值是8</td>
</tr>
<tr>
<td style="text-align:center"><code>-XX:NewRatio</code></td>
<td style="text-align:center">设置老年代Tenured/新生代young Gen的比例，默认是2</td>
</tr>
</tbody>
</table>
</div>
<div class="note primary"><p>参考链接:</p>
<ul>
<li><a href="https://betsol.com/2017/06/java-memory-management-for-java-virtual-machine-jvm/">https://betsol.com/2017/06/java-memory-management-for-java-virtual-machine-jvm/</a></li>
<li><a href="https://dzone.com/articles/java-8-permgen-metaspace">https://dzone.com/articles/java-8-permgen-metaspace</a></li>
</ul>
</div>
<h2 id="二、垃圾回收"><a href="#二、垃圾回收" class="headerlink" title="二、垃圾回收"></a>二、垃圾回收</h2><h3 id="1-垃圾回收机制"><a href="#1-垃圾回收机制" class="headerlink" title="1. 垃圾回收机制"></a>1. 垃圾回收机制</h3><h4 id="1-1-流程"><a href="#1-1-流程" class="headerlink" title="1.1 流程"></a>1.1 流程</h4><p>垃圾回收一个释放堆内空间以创建新对象的过程。Java的最佳特性之一就是垃圾自动收集，垃圾收集器是JVM管理的进程，它可以查看内存中的所有对象，并找出程序中任何部分都没有引用的对象，删除并回收空间以分配给其他新创建的对象。通过垃圾收集有以下步骤:</p>
<ul>
<li><strong>Marking 标记</strong>: 标记哪些对象是可达对象(live objects)，哪些是不可达对象(dead objects), 垃圾收集器会以一个GC root开始遍历对象图(Object Graph)， 此过程会引起”Stop the World Pause”(将当前所有运行的线程挂起，直到对象图遍历完毕);<br><img data-src="jvm-1-gc-mark.png" alt="jvm-gc-marking"></li>
<li><strong>Normal Deletion 普通删除</strong>: 删除不可达对象并回收分配给其他对象的空闲空间;<br><img data-src="jvm-1-gc-mark-sweep.png" alt="jvm-gc-mark-sweep"></li>
<li><strong>Deletion with compacting</strong>: 性能考虑，在删除不可达对象之后，会将所有幸存对象移动到一起，腾出整段空闲的空间(内存碎片处理);<br><img data-src="jvm-1-gc-mark-sweep-compact.png" alt="jvm-gc-mark-sweep-compact"></li>
<li><strong>Copy 复制</strong>: 将堆内存分成两个相等大小的分区，每次只使用一个区域，当完成标记后，直接将幸存对象复制到另一个分区即可。(例如Young Gen 中两个Survivor区)<br><img data-src="jvm-1-gc-mark-copy.png" alt="jvm-gc-mark-copy"></li>
</ul>
<p>上面给出步骤涉及的内容其实就是Java垃圾收集中使用的算法。</p>
<div class="note danger"><p>自JDK 1发布以来，Java垃圾收集从未使用过<strong>引用计数算法 References Counting</strong>, 因为会出现”循环引用“，即对象<code>A</code>引用对象<code>B</code>, 而对象<code>B</code>引用对象<code>A</code>， 使得它们永远无法被垃圾收集器回收。</p>
<p>关于<strong>Stop the World Pause</strong>:<br>所有的垃圾收集都会引起”Stop the World Pause”，即应用中的所有线程都要被挂起，直到对象图遍历完成。(因为如果对象图发生变化的话，对象图将无法正确的遍历)。</p>
<p>对于新生代而言，由于存放的是短期对象，所以Minor GC过程非常快，应用程序可以说几乎不受它引起的”Stop the World Pause”的影响。</p>
<p>但是，Major GC 就需要很长时间了，它会检查所有的活动对象。我们应该尽量让Major GC最少执行，因为它会使应用程序持续很长时间没有响应。</p>
</div>
<h4 id="1-2-策略"><a href="#1-2-策略" class="headerlink" title="1.2 策略"></a>1.2 策略</h4><p>虚拟机栈、本地方法栈和程序计数器在编译完毕后已经可以确定所需内存空间，程序执行完毕后也会自动释放所有内存空间，所以不需要进行动态回收优化。JVM内存调优主要是针对堆和方法区的两大区域的内存。</p>
<p>通常对象分为<strong>Strong</strong>、<strong>Soft</strong>、<strong>weak</strong>、<strong>phantom</strong>四种类型，强引用不会被回收，软引用在内存达到溢出边界时回收，弱引用在每次回收周期时回收，虚引用专门被标记为回收对象，具体回收策略如下:</p>
<ul>
<li>对象优先在Eden区中分配;</li>
<li>新生对象回收策略Minor GC(频繁);</li>
<li>老年代(Tenured)对象回收策略Full GC/Major GC(慢);</li>
<li>大对象直接进入老年年代；超过<code>3m</code>的对象直接进入老年代 - <code>-XX:PretenuredSizeThreshold=3145728</code>(3M);</li>
<li>长期存活对象进入老年代(经过若干次Minor GC的对象): Survivor中的对象经过一次Minor GC后，年龄会增加一岁，超过15岁进入老年代 - <code>:XX:MaxTenuringThreshold=15</code>;</li>
<li>动态对象年龄判定: 设置Survivor区对象占用一般空间以上的对象进入老年代。</li>
</ul>
<h3 id="2-垃圾回收器"><a href="#2-垃圾回收器" class="headerlink" title="2. 垃圾回收器"></a>2. 垃圾回收器</h3><p>我们可以在应用程序中使用五种垃圾收集类型。只需要在执行JVM参数来启用相应的垃圾收集策略即可。</p>
<ol>
<li><strong>Serial GC(串行GC)</strong> - <code>-XX:UseSerialGC</code>: 串行GC使用简单的<code>mark-sweep-compact</code>算法，可以用于新生代和老年代的垃圾收集，例如Minor GC和 Major GC;</li>
<li><strong>Parallel GC(并行GC)</strong> - <code>-XX:UseParallelGC</code>: 并行GC和串行GC相同，不同之处在于它为新生代垃圾收集生成N个线程，其中N是系统中的CPU核心数。我们还可以使用<code>-XX:ParallelGCThreads=n</code>来控制线程数;</li>
<li><strong>Parallel Old GC(并行旧GC)</strong> - <code>-XX:UseParallelOldGC</code>: 这与并行GC相同，只不过它除了为新生代生成多个线程以外，同时也对老年代生成多个线程;</li>
<li><strong>Concurrent Mark Sweep(并发标记扫描, CMS)</strong> - <code>-XX:UseConcMarkSweepGC</code>: CMS也称为并发低暂停收集器。它为老年代做垃圾收集。CMS垃圾收集器尝试通过在应用程序线程呃逆同时执行大多数垃圾收集工作来最小化由于垃圾收集导致的暂停。年轻一代的CMS收集器使用与并行GC相同的算法，我们可以使用<code>-XX:ParallelCMSThreads=n</code>参数来控制CMS收集器的线程数;</li>
<li><strong>G1 Garbage Collector(G1垃圾收集器)</strong> - <code>-XX:+UseG1GC</code>: G1从长远来看是要替换CMS收集器的。G1收集器是并行，并发和递增紧凑的低暂停垃圾收集器。G1不像其他收集器那样工作，并且没有新生代和老年代的概念，它将堆空间划分为多个大小相同的堆区域。当调用垃圾收集器时，它首先收集具有较少实时数据的区域，因此称为”Garbage First”, 即G1。</li>
</ol>
<p>更多关于G1GC的内容可以<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/G1.html">查看Oracle给出的文档</a>。</p>
<div class="note primary"><p>参考链接:</p>
<ul>
<li><a href="https://iq.opengenus.org/memory-management-in-java-mark-sweep-compact-copy/">https://iq.opengenus.org/memory-management-in-java-mark-sweep-compact-copy/</a></li>
<li><a href="https://plumbr.io/handbook/garbage-collection-algorithms">https://plumbr.io/handbook/garbage-collection-algorithms</a></li>
<li><a href="https://dzone.com/articles/java-memory-architecture-model-garbage-collection">https://dzone.com/articles/java-memory-architecture-model-garbage-collection</a></li>
<li><a href="https://www.journaldev.com/2856/java-jvm-memory-model-memory-management-in-java#memory-management-in-java-8211-old-generation">https://www.journaldev.com/2856/java-jvm-memory-model-memory-management-in-java#memory-management-in-java-8211-old-generation</a></li>
</ul>
</div>
<div class="note info"><p><strong>Related posts:</strong></p>
<ul>
<li><a href="/posts/4661f621/">JVM知识体系 (一) | 类的装载</a></li>
<li><a href="/posts/12448424/">JDK, JRE, JVM | 深入了解</a></li>
</ul>
</div>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Reflection</title>
    <url>/posts/d897152e/</url>
    <content><![CDATA[<p>简单了解Java反射的基本内容。</p>
<span id="more"></span>
<h3 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h3><h4 id="Class类的使用"><a href="#Class类的使用" class="headerlink" title="Class类的使用"></a>Class类的使用</h4><ul>
<li>A class named Class</li>
<li>1)在面向对象的世界里，万事万物皆对象。</li>
<li>类是对象，类是java.lang.Class类的实例对象</li>
<li>2)任何一个类都是Class的实例对象，这个实例对象有三种表示方式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rovo98.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">  		<span class="comment">//Foo的实例对象如何表示</span></span><br><span class="line">  		Foo foo1 = <span class="keyword">new</span> Foo() ;<span class="comment">// foo1就表示出来了.</span></span><br><span class="line">  		<span class="comment">//Foo这个类本身 也是一个实例对象，Class类的实例对象</span></span><br><span class="line">  		<span class="comment">// 第一种表示方式 --&gt; 任何一个类都有一个隐含的静态成员变量class</span></span><br><span class="line">  		Class c1 = Foo.class;</span><br><span class="line">  		<span class="comment">//第二种表示方式 --&gt; 已经知道该类的对象通过getClass()方法</span></span><br><span class="line">  		Class c2 = foo1.getClass() ;</span><br><span class="line">  		<span class="comment">/* c1,c2 表示了Foo类的类类型(class type)*/</span></span><br><span class="line">  		<span class="comment">// 不管c1 or c2 都代表了Foo类的类类型，一个类只可能是Class类的一个实例对象</span></span><br><span class="line">  		<span class="comment">// 第三种表达方式</span></span><br><span class="line">  		Class c3 = <span class="keyword">null</span> ;</span><br><span class="line">  		c3 = Class.forName(<span class="string">&quot;com.rovo98.Foo&quot;</span>);</span><br><span class="line">  		<span class="comment">// 我们完全可以通过类的类类型创建该类的对象实例</span></span><br><span class="line">  		Foo foo = (Foo)c1.newInstance() ;<span class="comment">//需要有无参构造方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Java动态加载类"><a href="#Java动态加载类" class="headerlink" title="Java动态加载类"></a>Java动态加载类</h4><ul>
<li>Class.forName(“类的名称”)<ul>
<li>不仅表示了类的类类型，还代表了动态加载类</li>
<li>编译时刻加载类是静态加载类、运行时刻加载类是动态加载类</li>
</ul>
</li>
<li>使用：当有多个功能模块(具体由类实现)时，使用动态加载</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态加载实例</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OfficeAble</span>  // 指定接口标准</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Word</span> <span class="keyword">implements</span> <span class="title">OfficeAble</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	System.out.println(<span class="string">&quot;Start the Word&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Office</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  		<span class="keyword">try</span>&#123;</span><br><span class="line">  			<span class="comment">//实现动态加载，运行时加载类</span></span><br><span class="line">  			Class c = Class.forName(args[<span class="number">0</span>]) ;</span><br><span class="line">  			OfficeAble oa = c.newInstance() ;</span><br><span class="line">  			oa.start() ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  			e.printStackTrace() ;</span><br><span class="line">		&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="通过反射获取方法信息"><a href="#通过反射获取方法信息" class="headerlink" title="通过反射获取方法信息"></a>通过反射获取方法信息</h4><ul>
<li>getMethods()  获取所有public 方法，包括父类继承而来的</li>
<li>getDeclaredMethods() 获取所有自定义的方法，不包含访问权限</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rovo98.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">  	 </span><br><span class="line">  	 Class c1 = <span class="keyword">int</span>.class; <span class="comment">// int 的类类型</span></span><br><span class="line">  	 Class c2 = String.class; <span class="comment">//String的类类型</span></span><br><span class="line">  	 Class c3 = <span class="keyword">double</span>.class ;</span><br><span class="line">  	 Class c4 = Double.class ;</span><br><span class="line">  	 Class c5 = <span class="keyword">void</span>.class ;</span><br><span class="line">  	 System.out.println(c1.getName()) ;</span><br><span class="line">  	 System.out.println(c3.getSimpleName()) ;<span class="comment">//打印不包含包名的类信息</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rovo98.feflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassUtil</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *打印类的信息，包括类的成员变量，成员方法</span></span><br><span class="line"><span class="comment">  *<span class="doctag">@param</span> obj 该对象所属类的信息</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printClassMessage</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//要获取类的信息 首先要获取类的类类型</span></span><br><span class="line">  	Class c = obj.getClass() ;<span class="comment">//传递的是哪个子类的对象 c就是该子类的类类型</span></span><br><span class="line">  	<span class="comment">// 获取类名称</span></span><br><span class="line">  	System.out.println(<span class="string">&quot;类的名称：&quot;</span>+c.getName()) ;</span><br><span class="line">  	<span class="comment">/*</span></span><br><span class="line"><span class="comment">  	*Method类 ，方法对象</span></span><br><span class="line"><span class="comment">  	*一个成员方法就是一个Method对象</span></span><br><span class="line"><span class="comment">  	*getMethods()方法获取的是所有public的函数，包括父类继承而来的</span></span><br><span class="line"><span class="comment">  	*getDeclaredMethods()获取的是所有该类自己声明的方法，不包含访问权限</span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">  	Method[] ms = c.getMethods() ;<span class="comment">//c.getDeclaredMethods()</span></span><br><span class="line">  	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ms.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 得到方法的返回值类型的类类型</span></span><br><span class="line">        Class returnType = ms[i].getReturnType() ;</span><br><span class="line">        System.out.print(returnType.getName()+<span class="string">&quot; &quot;</span>) ;</span><br><span class="line">        <span class="comment">//得到方法的名称</span></span><br><span class="line">        System.out.print(ms[i].getName()+<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        <span class="comment">//获取参数类型 --&gt; 得到的是参数列表的类型的类类型</span></span><br><span class="line">        <span class="keyword">for</span> (Class class1 : paramTypes) &#123;</span><br><span class="line">  			System.out.print(class1.getName()+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">	 &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="成员变量和构造方法信息的获取"><a href="#成员变量和构造方法信息的获取" class="headerlink" title="成员变量和构造方法信息的获取"></a>成员变量和构造方法信息的获取</h4><ul>
<li>getField()方法获取的是所有的public的成员变量的信息</li>
<li>getDeclaredField()获取的是该类自己声明的成员变量的信息</li>
<li>getConstructors获取所有的public的构造方法</li>
<li>getDeclaredConstructors得到所有的构造方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printClassFieldMessage</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">*成员变量也是对象</span></span><br><span class="line"><span class="comment">*java.lang.reflect.Field</span></span><br><span class="line"><span class="comment">*Field类封装了关于成员变量的操作</span></span><br><span class="line"><span class="comment">*getField()方法获取的是所有的public的成员变量的信息</span></span><br><span class="line"><span class="comment">*getDeclaredField()获取的是该类自己声明的成员变量的信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//Field[] fs = c.getDeclaredFields();</span></span><br><span class="line">Filed[] fs = c.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (Field field:fs) &#123;</span><br><span class="line">  <span class="comment">//得到成员变量的类型的类类型</span></span><br><span class="line">  Class fieldType = field.getType();</span><br><span class="line">  String typeName = fieldType.getName();</span><br><span class="line">  <span class="comment">//得到成员变量的名称</span></span><br><span class="line">  String fieldName = field.getName();</span><br><span class="line">  System.out.println(typeName+<span class="string">&quot; &quot;</span>+fieldName) ;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*打印对象的构造函数的信息</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printConMessage</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">  Class c = obj.getClass();</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  *构造方法也是对象</span></span><br><span class="line"><span class="comment">  *java.lang.Constructor中封装了构造方法的信息</span></span><br><span class="line"><span class="comment">  *getConstructors获取所有的public的构造方法</span></span><br><span class="line"><span class="comment">  *getDeclaredConstructors得到所有的构造方法</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">//Constructor[] cs = c.getConstructors();</span></span><br><span class="line">  Construtor() cs = c.getDeclaredConstructors();</span><br><span class="line">  <span class="keyword">for</span> (Constructor constructor : cs) &#123;</span><br><span class="line">    <span class="comment">//打印构造方法信息</span></span><br><span class="line">    System.out.print(constructor.getName()+<span class="string">&quot;(&quot;</span>);</span><br><span class="line">    Class[] paramTypes = constructor.getParameterTypes();</span><br><span class="line">    <span class="keyword">for</span> (Class class1 : paramTypes) &#123;</span><br><span class="line">       System.out.print(class1.getName+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="java方法反射的基本操作"><a href="#java方法反射的基本操作" class="headerlink" title="java方法反射的基本操作"></a>java方法反射的基本操作</h3><h4 id="方法的反射"><a href="#方法的反射" class="headerlink" title="方法的反射"></a>方法的反射</h4><ul>
<li>1)如何获取某个方法<br>方法的名称和方法的参数列表才能唯一决定某个方法</li>
<li>2)方法反射的操作<br>method.invoke(对象,参数列表)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rovo98.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodDemo1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//要获取print(int, int)方法</span></span><br><span class="line">    <span class="comment">//1.要先获取类的类类类型</span></span><br><span class="line">    <span class="comment">//2.获取类的信息</span></span><br><span class="line">    A a1 = <span class="keyword">new</span> A() ;</span><br><span class="line">    Class c = a1.getClass() ;</span><br><span class="line">    <span class="comment">// 3.获取方法 名称和参数列表决定</span></span><br><span class="line">    <span class="comment">//getMethod获取的是public的方法</span></span><br><span class="line">    <span class="comment">//getDeclaredMethod自己的声明的方法</span></span><br><span class="line">    <span class="comment">//c.getMethod(name,parameterTypes);</span></span><br><span class="line">    <span class="comment">//Method m = c.getMethod(&quot;print&quot;,new Class[]&#123;int.class,int.class&#125;);</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 获取print(int,int)方法</span></span><br><span class="line">      Method m = c.getMethod(<span class="string">&quot;print&quot;</span>,<span class="keyword">int</span>.class,<span class="keyword">int</span>.class);</span><br><span class="line">      <span class="comment">//方法的反射操作</span></span><br><span class="line">      <span class="comment">//使用m对象来进行方法调用 和a1对象调用一样</span></span><br><span class="line">      <span class="comment">//方法如果没有返回值返回null,有则返回具体返回值</span></span><br><span class="line">      <span class="comment">//本来是a1.print(10,20);</span></span><br><span class="line">      Object o = m.invoke(a1,<span class="keyword">new</span> Object[]&#123;<span class="number">10</span>,<span class="number">20</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> vodi <span class="title">print</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    System.out.println(a + b) ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    System.out.println(a.toUpperCase()+<span class="string">&quot;,&quot;</span>+b.tolowerCase()) ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="通过反射了解集合泛型的本质"><a href="#通过反射了解集合泛型的本质" class="headerlink" title="通过反射了解集合泛型的本质"></a>通过反射了解集合泛型的本质</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rovo98.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodDemo4</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    ArrayList list = <span class="keyword">new</span> ArrayList() ;</span><br><span class="line">    ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    list1.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="comment">//list1.add(20);  错误的</span></span><br><span class="line">    </span><br><span class="line">    Class c1 = list.getClass() ;</span><br><span class="line">    Class c2 = list1.getClass() ;</span><br><span class="line">    System.out.println(c1 == c2) ;</span><br><span class="line">    <span class="comment">//反射的操作都是编译之后的操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *c1 == c2 结果返回true说明编译之后集合的泛型是去泛型化的</span></span><br><span class="line"><span class="comment">    *java中集合的泛型，是防止错误输入的，只在编译阶段有效</span></span><br><span class="line"><span class="comment">    *验证：可以通过方法的反射操作，绕过编译</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       Method m = c1.getMethod(<span class="string">&quot;add&quot;</span>,Object.class) ;</span><br><span class="line">       <span class="comment">// 绕过编译操作，绕过了泛型</span></span><br><span class="line">       Object o = c1.invoke(list1,<span class="number">20</span>) ;</span><br><span class="line">       System.out.println(list1.size()) ;</span><br><span class="line">       <span class="comment">// list1.size --&gt; 2</span></span><br><span class="line">       <span class="comment">// list1 -- &gt; [&quot;hello&quot;,20]</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>basic</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM知识体系 (一) | 类的装载</title>
    <url>/posts/4661f621/</url>
    <content><![CDATA[<p><img data-src="/images/java/basic/class-loading-subsystem.png" alt="class-loading-subsystem"></p>
<p>了解Java中<strong>类的结构</strong>(class file struture, 这里指<code>.class</code>文件的结构)、<strong>类的加载机制</strong>、<strong>类的加载过程</strong>、<strong>类加载器的应用</strong>。</p>
<span id="more"></span>
<h2 id="一、类的结构"><a href="#一、类的结构" class="headerlink" title="一、类的结构"></a>一、类的结构</h2><p>我们知道除了<code>java</code>以外，还有许多的编程语言(如：Groovy/Kotlin/Scala等)同样也是编译成<code>.class</code>字节码文件，然后由JVM执行的。可以看出JVM只关心<code>.class</code>文件，所以我们有必要了解一下这个<strong>class</strong>文件中到底包含什么东西。</p>
<p>JVM规范严格定义了<strong>class</strong>文件的格式，有严格数据结构，下面是<code>.class</code>文件的结构:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic;</span><br><span class="line">    u2             minor_version;</span><br><span class="line">    u2             major_version;</span><br><span class="line">    u2             constant_pool_count;</span><br><span class="line">    cp_info        constant_pool[constant_pool_count-1];</span><br><span class="line">    u2             access_flags;</span><br><span class="line">    u2             this_class;</span><br><span class="line">    u2             super_class;</span><br><span class="line">    u2             interfaces_count;</span><br><span class="line">    u2             interfaces[interfaces_count];</span><br><span class="line">    u2             fields_count;</span><br><span class="line">    field_info     fields[fields_count];</span><br><span class="line">    u2             methods_count;</span><br><span class="line">    method_info    methods[methods_count];</span><br><span class="line">    u2             attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-类文件的格式-The-class-file-format"><a href="#1-类文件的格式-The-class-file-format" class="headerlink" title="1. 类文件的格式(The class file format)"></a>1. 类文件的格式(The class file format)</h3><ul>
<li>每个类文件包含一个类或者接口的定义，虽然类或者接口不需要在文件中真正包含外部表示(因为类是由类加载器生成的)，但是我们通常<strong>类或接口的任何有效表示称为类文件格式</strong>；</li>
<li><strong>一个类文件由8位(bit)的字节流组成</strong>。所有16位，32位和64位字节分别通过读取两个，四个和八个连续8位字节构成。多字节数据项始终以大端顺序(big-endian)存储(即高字节位首先出现)。在Java SE平台中，接口<code>java.io.DataInput</code>和<code>java.io.DataOutput</code>以及<code>java.io.DataInputStream</code>和<code>java.io.DataOutputStream</code>等支持这种格式；</li>
<li>JVM规范中定义了一组表示类文件数据的数据类型:<code>u1</code>, <code>u2</code>, <code>u4</code>分别表示无符号的一个，两个和四个字节的数量。在Java SE平台中，可以通过诸如<code>readUnsignedByte</code>, <code>readUnsignedShort</code>和<code>java.io.DataInput</code>接口的<code>readInt</code>之类的方法来读取这些类型的数据;</li>
<li>规范中使用类似<strong>C</strong>语言结构符号编写的伪结构来表示类文件格式。为了避免与类的字段和类实例等混淆，将描述类文件结构的内容称为<strong>项(item)</strong>，多个连续的项按顺序存储在类文件中，无需填充和对齐；</li>
<li>一个<strong>表(Tables)</strong>包含一个或多个项(<em>item</em>)，用于表示多个类文件结构。<strong>尽管使用类似C语言的数组语法来引用表项，但表是不同大小结构的流这一事实，意味着无法将表索引直接转换为表中的字节偏移量</strong>。</li>
</ul>
<h3 id="2-项含义简单说明"><a href="#2-项含义简单说明" class="headerlink" title="2. 项含义简单说明"></a>2. 项含义简单说明</h3><ul>
<li>1、<strong>magic</strong></li>
</ul>
<p><code>magic</code>项提供标识类文件格式的<em>magic number</em>, 这是一个预先定义好的值，是JVM用来识别<code>.class</code>类文件是否由合法的编译器产生。 预先定义的值是16进制格式，例如: <code>0xCAFEBABE</code></p>
<p>我们可以做以下测试来进行简单的验证:</p>
<ul>
<li>首先编写一个简单的<code>Sample.java</code>源文件:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Magic Number&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用<code>javac</code>将其编译成<code>Sample.class</code>文件，打开并随意删除或修改一个或多个字符，然后保存<br><img data-src="jvm-1-sample-class.png" alt="sample-class-file"></li>
<li><p><code>java sample</code>查看结果<br><img data-src="jvm-1-incompatible-magic-value.png" alt=""></p>
</li>
<li><p>2、<strong>minor_version 和 major_version</strong><br>它们合在一起表示<code>.class</code>类文件的版本。JVM使用这个版本信息来识别当前的类文件是由哪个版本的编译产生的。规范用<code>M.m</code>的格式来表示版本，<code>M</code>表示主版本(<code>major_version</code>)，而<code>m</code>表示次版本(<code>minor_version</code>)。</p>
</li>
</ul>
<div class="note warning"><p><strong>[Notice]</strong>: 低版本的编译器生成的<code>.class</code>类文件可以被高版本的JVM执行，但是高版本的编译器生成的<code>.class</code>类文件无法被较低版本的JVM执行。</p>
<p>会报错: <code>UnsupportedClassVersionError: ***</code></p>
</div>
<div class="note primary"><p>JDK 1.0.2版本中的Oracle Java 虚拟机支持包含45.0 ~ 45.3版本的类文件格式。</p>
<p>JDK发布1.1.*支持的类文件格式版本，范围为45.0 ~ 45.65535。 对于$k \gt 2$, JDK版本1.k 支持45.0 ~ 44 + k.0 范围内的类文件格式版本。</p>
<p>例如: JDK 1.8.0 版本支持的类文件格式版本范围为: 45.0 ~ 52.0</p>
</div>
<ul>
<li>3、<strong>constant_pool_count</strong></li>
</ul>
<p><code>constant_pool_count</code>项的值等于<code>constant_pool</code>表(<em>Table</em>)中的项(<em>item</em>)数加1。它表示常量池中存在的常量数(当编译Java文件时，对变量和方法的所有引用都存储在常量池作为符号引用-<em>Symbolic reference</em>)。</p>
<ul>
<li>4、<strong>constant_pool[]</strong></li>
</ul>
<p><code>constant_pool[]</code>是一个结构表(<em>Table</em>), 表示各种字符串常量，类和接口名称，字段名称以及在类文件结构及其子结构中引用的其他常量。每个常量池条目(<em>entry</em>)的格式由第一个”标记(<em>tag</em>)”字节表示。</p>
<ul>
<li>5、<strong>access_flags</strong></li>
</ul>
<p><code>access_flags</code>项提供关于类文件中声明的修饰符(<em>modifier</em>)的信息。<code>access_flags</code>的值用于表示对该类或接口属性的访问权限。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Flag Name</th>
<th style="text-align:center">Value</th>
<th style="text-align:center">Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ACC_PUBLIC</td>
<td style="text-align:center">0x0001</td>
<td style="text-align:center">声明<code>public</code>，可以从包的外部进行访问</td>
</tr>
<tr>
<td style="text-align:center">ACC_FINAL</td>
<td style="text-align:center">0x0010</td>
<td style="text-align:center">声明<code>final</code>, 不允许子类继承</td>
</tr>
<tr>
<td style="text-align:center">ACC_SUPER</td>
<td style="text-align:center">0x0020</td>
<td style="text-align:center">在调用<code>invokespecial</code>指令时特别处理超类的方法</td>
</tr>
<tr>
<td style="text-align:center">ACC_INTERFACE</td>
<td style="text-align:center">0x0200</td>
<td style="text-align:center">标明是一个接口，而不是一个类</td>
</tr>
<tr>
<td style="text-align:center">ACC_ABSTRACT</td>
<td style="text-align:center">0x0400</td>
<td style="text-align:center">声明<code>abstract</code>，不能实例化</td>
</tr>
<tr>
<td style="text-align:center">ACC_SYNTHETIC</td>
<td style="text-align:center">0x1000</td>
<td style="text-align:center">声明<code>synthetic</code>，表示类或者接口由编译器生成，不会出现在源代码中</td>
</tr>
<tr>
<td style="text-align:center">ACC_ANNOTATION</td>
<td style="text-align:center">0x2000</td>
<td style="text-align:center">声明一个注解<code>annotation</code>类型</td>
</tr>
<tr>
<td style="text-align:center">ACC_ENUM</td>
<td style="text-align:center">0x4000</td>
<td style="text-align:center">声明一个枚举<code>enum</code>类型</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>6、<strong>this_class</strong></li>
</ul>
<p>该类项的值必须是常量池表(<code>constant_pool[]</code>)中的有效索引。索引处的常量池条目必须是一个<code>CONSTANT_Class_info</code>结构，表示此类文件定义的类或接口。简单的说，它表示类文件的完全限定名。</p>
<ul>
<li>7、<strong>super_class</strong></li>
</ul>
<p><code>super_class</code>表示当前类的直接超类的完全限定名。例如上面<code>Sample.java</code>文件。当我们编译它时，可以说<code>this_class</code>是<code>Sample</code>类，而<code>super_class</code>是<code>Object</code>类。</p>
<ul>
<li>8、<strong>interface_count</strong></li>
</ul>
<p><code>interface_count</code>表示当前类文件实现的接口数量。</p>
<ul>
<li>9、<strong>interface[]</strong></li>
</ul>
<p><code>interface[]</code>存放当前类文件实现的接口信息。</p>
<ul>
<li>10、<strong>fields_count</strong></li>
</ul>
<p><code>fields_count</code>表示当前类文件中的字段数(类或接口中声明的所有字段，包括类变量和实例变量)。</p>
<ul>
<li>11、<strong>fields[]</strong></li>
</ul>
<p><code>fields[]</code>表中的每个值必须是<code>field_info</code>结构，给出该类或接口中字段的完整描述。<code>fields</code>表仅包括由当前(<em>this</em>)类或接口声明的那些字段，不包括从超类(<em>super class</em>)或超接口(<em>super interface</em>)继承的字段的项。</p>
<ul>
<li>12、<strong>method_count</strong></li>
</ul>
<p><code>method_count</code>表示当前类文件中的方法的数量(即<code>methods[]</code>表中<code>method_info</code>项的数量)。</p>
<ul>
<li>13、<strong>methods[]</strong></li>
</ul>
<p><code>methods[]</code>表中的每个值必须是<code>method_info</code>结构，它给出了该类或接口中的方法的完整描述。<br><code>method_info</code>结构表示该类或接口中声明的所有方法，包括实例方法、类方法、实例初始化方法和任何类的或接口的初始化方法。但是<code>methods[]</code>表不包含表示从超类或超接口继承的方法的项。</p>
<ul>
<li>14、<strong>attributes_count</strong></li>
</ul>
<p>同上，<code>attributes_count</code>表示<code>attributes[]</code>表中<code>attribute_info</code>项的数量。</p>
<ul>
<li>15、<strong>attributes[]</strong></li>
</ul>
<p><code>attributes[]</code>表存放<code>attribute_info</code>结构项。提供当前类中所有属性的信息。</p>
<p><strong>类文件结构的整体布局</strong>:</p>
<p><img data-src="jvm-1-class-file-structure.png" alt="class-file-structure"></p>
<p>可以简单地将每个类的文件结构理解成一个个数据库，里面有常量池(<code>constant_pool</code>)、接口(<code>interfaces</code>)、字段(<code>fields</code>)、方法(<code>methods</code>)和属性(<code>attributes</code>)表，类似与数据库中的数据表，表与表之间存在关联，例如：常量池存放这其他表需要的所有字面量(<em>literal</em>)。</p>
<div class="note primary"><p>以上内容大多参照<em>The Java@ Virtual Machine Specification Java SE 8 Edition</em></p>
<p>详细的内容，可以仔细阅读Hotspot JVM规范说明书给出的Class文件格式说明。<br><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.1">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.1</a></p>
</div>
<div class="note primary"><p><strong>[参考链接]:</strong><br><a href="https://www.geeksforgeeks.org/java-class-file/">https://www.geeksforgeeks.org/java-class-file/</a></p>
</div>
<h2 id="二、加载机制"><a href="#二、加载机制" class="headerlink" title="二、加载机制"></a>二、加载机制</h2><h3 id="1-类的入口"><a href="#1-类的入口" class="headerlink" title="1. 类的入口"></a>1. 类的入口</h3><p>我们知道编程语言在计算机体系结构中的按功能的分层是属于上面三层的（汇编语言、高级语言、应用语言），在向低一级别虚拟机语言转换时，使用的是<strong>翻译(Translation)</strong>的方式，即将高一级别机器上的程序转换为低一级别机器上的一段等效程序，然后再执行。</p>
<p>Java、C等大多是用这种方式，例如我们回顾一下我们是如何运行一个C程序的:</p>
<ul>
<li>(1). 编写<code>helloworld.c</code>源文件:<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>(2). 使用<code>gcc/g++</code>编译器将它编译成机器指令集, 然后读取到内存直接在计算机的CPU上执行。从操作系统的层面上，就是一个进程的启动到结束的生命周期。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc helloworld.c -o helloworld <span class="comment"># 默认输出 a.out</span></span><br><span class="line">$ ./helloworld</span><br><span class="line"></span><br><span class="line">hello, world!</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>下面我们再看Java的程序是如何运行的。</p>
<p><strong>简单的来说，编写Java程序源代码, 然后使用</strong><code>javac</code><strong>编译器将源代码编译成</strong><code>.class</code><strong>类文件，经过JVM的类加载子系统，将必要的数据装入内存区，然后由执行引擎执行（此过程是解释执行的，加上JIT及时编译）</strong>。</p>
<ul>
<li>(1)先有源码:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>(2) 编译执行:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ javac HelloWorld.java</span><br><span class="line">$ java HelloWorld</span><br><span class="line"></span><br><span class="line">hello, world!</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>对比C语言在命令行直接运行编译后的<code>helloworld</code>二进制文件，Java则是在命令执行<code>.class</code>类文件，<strong>从命令的区别，我们知道操作启动的其实是</strong><code>java</code><strong>进程, 而</strong><code>HelloWorld.class</code>类文件只是作为命令行参数，在操作系统看来<code>java</code>也是一个普通的进程而已，这个进程就是JVM的执行形态。</p>
<p>我们都是Java的入口方法是<code>public static void main(String[] args)</code>, 缺一不可，下面我们通过一个简单的例子来验证为什么？</p>
<ul>
<li>(1) 去掉<code>public</code>修饰:<br><img data-src="jvm-1-public-error.png" alt=""><br>说明JVM在调用<code>main</code>方法时是在外部调用的(JVM调用<code>main</code>方法是底层的JNI方法调用)，为了确保能够调用<code>main</code>，入口方法需声明为<code>public</code>。</li>
<li>(2) 去掉<code>static</code>修饰:<br><img data-src="jvm-1-static-error.png" alt=""><br>JVM调用<code>main</code>方法时不会创建类的实例，因此将<code>main</code>方法修饰为<code>static</code>。</li>
<li>(3) 修改方法的返回来类型为<code>int</code>:<br><img data-src="jvm-1-return-type-error.png" alt=""><br><code>void</code>类型JVM调用<code>main</code>方法后无需关心调用者的使用情况，执行完成就停止，简化JVM的设计。</li>
<li>(4) 修改<code>main</code>为<code>main1</code>:<br><img data-src="jvm-1-main1-error.png" alt=""><br><code>main</code>方法的命名其实是约定俗成的，毕竟也是<em>c-family</em>语言，与C语言相同。</li>
</ul>
<p>上面说了这么多，其实我们一般只关心下面这两点:</p>
<ul>
<li><code>HelloWorld</code>是如何被JVM使用的;</li>
<li><code>HelloWorld</code>类里面的<code>main</code>方法是如何被执行的.</li>
</ul>
<p>下面我们详细了解一下JVM是如何使用<code>HelloWorld</code>这个类文件的。</p>
<p>我们知道JVM的实现是由C/C++实现的(我们可以从下载的JDK中的<code>src</code>源代码中看到), JVM在跟<code>.class</code>打交道时需要用到JNI(<em>Java Native Interface</em>), 当我们在命令行执行java时，由C/C++实现的java应用程序通过JNI找到了<code>HelloWorld</code>中符合规范的<code>main</code>，然后开始调用。</p>
<ul>
<li>源代码:<br><img data-src="jvm-1-jdk8-launcher-source-codes.png" alt=""></li>
<li><code>int JNICALL javaMain(void *args)</code>方法:<br><img data-src="jvm-1-launcher-source-code-javaMain.png" alt=""></li>
</ul>
<h3 id="2-类加载器"><a href="#2-类加载器" class="headerlink" title="2. 类加载器"></a>2. 类加载器</h3><p>JVM在执行类的入口之前，首先必须找到类文件，然后将类文件装入JVM实例中，也就是JVM进程维护的内存区域(Runtime Data Area或Memory Area)中。我们都知道有一个叫做<strong>类加载器(<em>ClassLoader</em>)</strong>的工具负责把类加载到JVM实例中，抛开细节从操作系统层面观察，那么就是JVM实例在运行过程中通过IO从硬盘或者网络读取<code>.class</code>类文件，然后在JVM管辖的内存区域存放对应的文件。</p>
<p>我们对于类加载器的实现还不是很清楚，但是从功能需求上了解到，无非就是读取文件到内存，看起来是一个很简单的操作。</p>
<p>如果类加载器的实现是用C/C++实现的，那么大概可能是如下代码实现的:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">( <span class="keyword">char</span> *buf, <span class="keyword">int</span> n, FILE *fp )</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>如果是JAVA实现的话(上面已经提到过我们可以用<code>java.io.InputStream</code>等接口来读取类文件中的数据), 那么也是很简单的:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;temporary/code/java/HelloWorld.class&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p>从操作系统层面看，如果只是加载，以上的代码就足以把类文件加载到JVM内存中。但是缺乏良好的管理，还必须设计一套规则来管理存放到内存中的类文件, <strong>而这一套规则就是所谓的类的加载机制</strong>。</p>
<p>在启动JVM的时候会把JRE默认的一些类加载到内存，这部分的类加载使用的是系统提供的内置类加载器<code>Bootstrap</code>和<code>Extensions</code>类加载器，但是内置的类加载器只能加载指定路径下的jar包(类文件集合)。JRE只是提供了底层所需的类，更多的业务需要我们从外部加载类来支持，所以我们需要指定新的类加载规则，以方便加载我们所需的外部路径的类文件。</p>
<h4 id="2-1-系统默认加载器"><a href="#2-1-系统默认加载器" class="headerlink" title="2.1. 系统默认加载器"></a>2.1. 系统默认加载器</h4><h5 id="2-1-1-Bootstrap-class-loader"><a href="#2-1-1-Bootstrap-class-loader" class="headerlink" title="2.1.1 Bootstrap class loader"></a>2.1.1 Bootstrap class loader</h5><blockquote>
<p>作用: 启动类加载器， 加载JDK核心类<br>实现: C/C++实现<br>类加载路径: <code>/jre/lib</code>目录下的jar包和类文件</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.Launcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> rovo98</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoostrapClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        URL[] urls = Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">            System.out.println(url.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ javac BoostrapClassLoaderTest.java</span><br><span class="line">$ java BoostrapClassLoaderTest</span><br><span class="line"></span><br><span class="line">file:/opt/jdk1.8.0_181/jre/lib/resources.jar</span><br><span class="line">file:/opt/jdk1.8.0_181/jre/lib/rt.jar</span><br><span class="line">file:/opt/jdk1.8.0_181/jre/lib/sunrsasign.jar</span><br><span class="line">file:/opt/jdk1.8.0_181/jre/lib/jsse.jar</span><br><span class="line">file:/opt/jdk1.8.0_181/jre/lib/jce.jar</span><br><span class="line">file:/opt/jdk1.8.0_181/jre/lib/charsets.jar</span><br><span class="line">file:/opt/jdk1.8.0_181/jre/lib/jfr.jar</span><br><span class="line">file:/opt/jdk1.8.0_181/jre/classes</span><br></pre></td></tr></table></figure>
<h5 id="2-1-2-Extensions-class-loader"><a href="#2-1-2-Extensions-class-loader" class="headerlink" title="2.1.2.Extensions class loader"></a>2.1.2.Extensions class loader</h5><blockquote>
<p>作用: 扩展类加载器，加载JAVA扩展类库<br>实现: Java实现<br>类加载器: <code>sun.misc.Launcher$ExtClassLoader</code><br>类加载路径: <code>/jre/lib/ext</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>));</span><br><span class="line"></span><br><span class="line">/opt/jdk1<span class="number">.8</span><span class="number">.0_181</span>/jre/lib/ext:/usr/java/packages/lib/ext</span><br></pre></td></tr></table></figure>
<p>实现原理：扩展类加载器<code>ExtClassLoader</code>本质上是<code>URLClassLoader</code>。</p>
<p>参考<code>jdk8</code>中的<code>sun.misc.Launcher.java</code>源码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Launcher构造方法部分代码，获取类加载器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Launcher.ExtClassLoader var1; <span class="comment">// ExtClassLoader 类加载器</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取Extensions 类加载器</span></span><br><span class="line">        var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">&quot;Could not create extension class loader&quot;</span>, var10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">&quot;Could not create application class loader&quot;</span>, var9);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ExtClassLoader 实现</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Launcher.ExtClassLoader instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 获取Extensions类加载器实例(instance)</span></span><br><span class="line">    <span class="comment">// 可以看到是用了ClassLevelLock(类级别锁，在该类以及类的所有实例中，</span></span><br><span class="line">    <span class="comment">// 在同一时间内只有一个线程能够这一临界区Critical Section)实现实例的</span></span><br><span class="line">    <span class="comment">// 单例模式(Singleton Pattern)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Launcher.<span class="function">ExtClassLoader <span class="title">getExtClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Class var0 = Launcher.ExtClassLoader.class;</span><br><span class="line">            <span class="keyword">synchronized</span>(Launcher.ExtClassLoader.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 3. 创建Extensions类加载器</span></span><br><span class="line">                    instance = createExtClassLoader();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 创建Extensions类加载器的具体实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Launcher.<span class="function">ExtClassLoader <span class="title">createExtClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Launcher.ExtClassLoader)AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Launcher.ExtClassLoader&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Launcher.<span class="function">ExtClassLoader <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    <span class="comment">// 5. 获取Extensions类加载器加载目标类的目录</span></span><br><span class="line">                    File[] var1 = Launcher.ExtClassLoader.getExtDirs();</span><br><span class="line">                    <span class="keyword">int</span> var2 = var1.length;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">                        MetaIndex.registerDirectory(var1[var3]);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 7 构造Extensions类加载器</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Launcher.ExtClassLoader(var1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PrivilegedActionException var1) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (IOException)var1.getException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addExtURL</span><span class="params">(URL var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.addURL(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. Extensions类加载器构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExtClassLoader</span><span class="params">(File[] var1)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(getExtURLs(var1), (ClassLoader)<span class="keyword">null</span>, Launcher.factory);</span><br><span class="line">        SharedSecrets.getJavaNetAccess().getURLClassPath(<span class="keyword">this</span>).initLookupCache(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. Extensions类加载器加载目录路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> File[] getExtDirs() &#123;</span><br><span class="line">        <span class="comment">// 即 /jre/lib/ext 目录</span></span><br><span class="line">        String var0 = System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>);</span><br><span class="line">        File[] var1;</span><br><span class="line">        <span class="keyword">if</span> (var0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            StringTokenizer var2 = <span class="keyword">new</span> StringTokenizer(var0, File.pathSeparator);</span><br><span class="line">            <span class="keyword">int</span> var3 = var2.countTokens();</span><br><span class="line">            var1 = <span class="keyword">new</span> File[var3];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var3; ++var4) &#123;</span><br><span class="line">                var1[var4] = <span class="keyword">new</span> File(var2.nextToken());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            var1 = <span class="keyword">new</span> File[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// var1(File[]):</span></span><br><span class="line">        <span class="comment">// /opt/jdk1.8.0_181/jre/lib/ext</span></span><br><span class="line">        <span class="comment">// /usr/java/packages/lib/ext</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> var1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> URL[] getExtURLs(File[] var0) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Vector var1 = <span class="keyword">new</span> Vector();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var2 = <span class="number">0</span>; var2 &lt; var0.length; ++var2) &#123;</span><br><span class="line">            <span class="comment">// File 对象的list()方法会返回一个当前目录下的所有文件</span></span><br><span class="line">            <span class="comment">// 这里会返回类加载目录下的所有jar包等</span></span><br><span class="line">            String[] var3 = var0[var2].list();</span><br><span class="line">            <span class="keyword">if</span> (var3 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var3.length; ++var4) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!var3[var4].equals(<span class="string">&quot;meta-index&quot;</span>)) &#123;</span><br><span class="line">                        File var5 = <span class="keyword">new</span> File(var0[var2], var3[var4]);</span><br><span class="line">                        var1.add(Launcher.getFileURL(var5));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        URL[] var6 = <span class="keyword">new</span> URL[var1.size()];</span><br><span class="line">        var1.copyInto(var6);</span><br><span class="line">        <span class="keyword">return</span> var6;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">        var1 = System.mapLibraryName(var1);</span><br><span class="line">        URL[] var2 = <span class="keyword">super</span>.getURLs();</span><br><span class="line">        File var3 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var2.length; ++var4) &#123;</span><br><span class="line">            URI var5;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                var5 = var2[var4].toURI();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (URISyntaxException var9) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            File var6 = Paths.get(var5).toFile().getParentFile();</span><br><span class="line">            <span class="keyword">if</span> (var6 != <span class="keyword">null</span> &amp;&amp; !var6.equals(var3)) &#123;</span><br><span class="line">                String var7 = VM.getSavedProperty(<span class="string">&quot;os.arch&quot;</span>);</span><br><span class="line">                File var8;</span><br><span class="line">                <span class="keyword">if</span> (var7 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    var8 = <span class="keyword">new</span> File(<span class="keyword">new</span> File(var6, var7), var1);</span><br><span class="line">                    <span class="keyword">if</span> (var8.exists()) &#123;</span><br><span class="line">                        <span class="keyword">return</span> var8.getAbsolutePath();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                var8 = <span class="keyword">new</span> File(var6, var1);</span><br><span class="line">                <span class="keyword">if</span> (var8.exists()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> var8.getAbsolutePath();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            var3 = var6;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AccessControlContext <span class="title">getContext</span><span class="params">(File[] var0)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        PathPermissions var1 = <span class="keyword">new</span> PathPermissions(var0);</span><br><span class="line">        ProtectionDomain var2 = <span class="keyword">new</span> ProtectionDomain(<span class="keyword">new</span> CodeSource(var1.getCodeBase(), (Certificate[])<span class="keyword">null</span>), var1);</span><br><span class="line">        AccessControlContext var3 = <span class="keyword">new</span> AccessControlContext(<span class="keyword">new</span> ProtectionDomain[]&#123;var2&#125;);</span><br><span class="line">        <span class="keyword">return</span> var3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ClassLoader.registerAsParallelCapable();</span><br><span class="line">        instance = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-1-3-System-class-loader"><a href="#2-1-3-System-class-loader" class="headerlink" title="2.1.3.System class loader"></a>2.1.3.System class loader</h5><blockquote>
<p>作用: 系统类加载器，加载应用指定环境变量(classpath)路径下的类<br>类加载器: <code>sun.misc.Launcher$AppClassLoader</code><br>实现原理: <code>AppClassLoader</code>本质上也是<code>URLClassLoader</code></p>
</blockquote>
<p>参考<code>jdk8</code>中的<code>sun.misc.Launcher.java</code>源码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Launcher构造方法部分代码，获取类加载器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Launcher.ExtClassLoader var1;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">&quot;Could not create extension class loader&quot;</span>, var10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取系统类加载器AppClassLoader</span></span><br><span class="line">        <span class="keyword">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">&quot;Could not create application class loader&quot;</span>, var9);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AppClassLoader具体实现</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> URLClassPath ucp = SharedSecrets.getJavaNetAccess().getURLClassPath(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 与上面提到的Extensions类加载器类似，实现逻辑差不多</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getAppClassLoader</span><span class="params">(<span class="keyword">final</span> ClassLoader var0)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String var1 = System.getProperty(<span class="string">&quot;java.class.path&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> File[] var2 = var1 == <span class="keyword">null</span> ? <span class="keyword">new</span> File[<span class="number">0</span>] : Launcher.getClassPath(var1);</span><br><span class="line">        <span class="keyword">return</span> (ClassLoader)AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Launcher.AppClassLoader&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> Launcher.<span class="function">AppClassLoader <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                URL[] var1x = var1 == <span class="keyword">null</span> ? <span class="keyword">new</span> URL[<span class="number">0</span>] : Launcher.pathToURLs(var2);</span><br><span class="line">                <span class="comment">// 3. 构造AppClassLoader类加载器</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Launcher.AppClassLoader(var1x, var0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AppClassLoader构造方法</span></span><br><span class="line">    AppClassLoader(URL[] var1, ClassLoader var2) &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1, var2, Launcher.factory);</span><br><span class="line">        <span class="keyword">this</span>.ucp.initLookupCache(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String var1, <span class="keyword">boolean</span> var2) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">int</span> var3 = var1.lastIndexOf(<span class="number">46</span>);</span><br><span class="line">        <span class="keyword">if</span> (var3 != -<span class="number">1</span>) &#123;</span><br><span class="line">            SecurityManager var4 = System.getSecurityManager();</span><br><span class="line">            <span class="keyword">if</span> (var4 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                var4.checkPackageAccess(var1.substring(<span class="number">0</span>, var3));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.ucp.knownToNotExist(var1)) &#123;</span><br><span class="line">            Class var5 = <span class="keyword">this</span>.findLoadedClass(var1);</span><br><span class="line">            <span class="keyword">if</span> (var5 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (var2) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.resolveClass(var5);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> var5;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(var1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(var1, var2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> PermissionCollection <span class="title">getPermissions</span><span class="params">(CodeSource var1)</span> </span>&#123;</span><br><span class="line">        PermissionCollection var2 = <span class="keyword">super</span>.getPermissions(var1);</span><br><span class="line">        var2.add(<span class="keyword">new</span> RuntimePermission(<span class="string">&quot;exitVM&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> var2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendToClassPathForInstrumentation</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> Thread.holdsLock(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">super</span>.addURL(Launcher.getFileURL(<span class="keyword">new</span> File(var1)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AccessControlContext <span class="title">getContext</span><span class="params">(File[] var0)</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</span><br><span class="line">        PathPermissions var1 = <span class="keyword">new</span> PathPermissions(var0);</span><br><span class="line">        ProtectionDomain var2 = <span class="keyword">new</span> ProtectionDomain(<span class="keyword">new</span> CodeSource(var1.getCodeBase(), (Certificate[])<span class="keyword">null</span>), var1);</span><br><span class="line">        AccessControlContext var3 = <span class="keyword">new</span> AccessControlContext(<span class="keyword">new</span> ProtectionDomain[]&#123;var2&#125;);</span><br><span class="line">        <span class="keyword">return</span> var3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ClassLoader.registerAsParallelCapable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-自定义类加载器"><a href="#2-2-自定义类加载器" class="headerlink" title="2.2. 自定义类加载器"></a>2.2. 自定义类加载器</h4><p>JVM内置的类加载器只加载了最少需要的核心JAVA基础类和环境变量下的类，但是我们往往需要依赖第三方中间件来完成额外的业务，那么如何把它们的类加载进来就显得格外的重要。</p>
<p>幸好JVM提供了自定义的类加载器，可以很方便的完成自定义操作，最终的目的也是将我们需要的类加载到JVM内存中。</p>
<p>通过继承<code>ClassLoader</code>类并重写(<em>Override</em>)<code>findClass</code>方法和<code>loadClass</code>方法就可以达到自定义获取<code>.class</code>文件的目的。</p>
<p><code>ClassLoader</code>中的核心方法<code>loadClass</code>方法:</p>
<p><code>java.lang.ClassLoader</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Loads the class with the specified &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt;.  The</span></span><br><span class="line"><span class="comment"> * default implementation of this method searches for classes in the</span></span><br><span class="line"><span class="comment"> * following order:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;p&gt; Invoke &#123;<span class="doctag">@link</span> #findLoadedClass(String)&#125; to check if the class</span></span><br><span class="line"><span class="comment"> *   has already been loaded.  &lt;/p&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;p&gt; Invoke the &#123;<span class="doctag">@link</span> #loadClass(String) &lt;tt&gt;loadClass&lt;/tt&gt;&#125; method</span></span><br><span class="line"><span class="comment"> *   on the parent class loader.  If the parent is &lt;tt&gt;null&lt;/tt&gt; the class</span></span><br><span class="line"><span class="comment"> *   loader built-in to the virtual machine is used, instead.  &lt;/p&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;p&gt; Invoke the &#123;<span class="doctag">@link</span> #findClass(String)&#125; method to find the</span></span><br><span class="line"><span class="comment"> *   class.  &lt;/p&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; If the class was found using the above steps, and the</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;resolve&lt;/tt&gt; flag is true, this method will then invoke the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #resolveClass(Class)&#125; method on the resulting &lt;tt&gt;Class&lt;/tt&gt; object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Subclasses of &lt;tt&gt;ClassLoader&lt;/tt&gt; are encouraged to override &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #findClass(String)&#125;, rather than this method.  &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Unless overridden, this method synchronizes on the result of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #getClassLoadingLock &lt;tt&gt;getClassLoadingLock&lt;/tt&gt;&#125; method</span></span><br><span class="line"><span class="comment"> * during the entire class loading process.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  name</span></span><br><span class="line"><span class="comment"> *         The &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  resolve</span></span><br><span class="line"><span class="comment"> *         If &lt;tt&gt;true&lt;/tt&gt; then resolve the class</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The resulting &lt;tt&gt;Class&lt;/tt&gt; object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  ClassNotFoundException</span></span><br><span class="line"><span class="comment"> *          If the class could not be found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        <span class="comment">// 先判断类是否已经加载</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 判断顶层parent类加载器是否为null, 不为空使用它进行加载</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// parent 为 null, 使用系统内置类加载器</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="comment">// 仍找不到，执行findClass方法继续查找</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;  <span class="comment">// 找到类，进行解析</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回类类型对象</span></span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个自定义类加载的简单例子: <code>UserDefinedClassLoaderExample.java</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> basical.test.userDefinedClassLoaderTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> rovo98</span></span><br><span class="line"><span class="comment"> * date: 2019.04.06 23:42</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDefinedClassLoaderExample</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Driver the program to test the methods</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args command-line arguments.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 定义要加载类的完全限定名</span></span><br><span class="line">            String className = <span class="string">&quot;basical.test.userDefinedClassLoaderTest.UserDefinedClassLoaderExample$Demo&quot;</span>;</span><br><span class="line">            Class&lt;?&gt; class1 = Demo.class; <span class="comment">// 用系统默认类加载器加载(AppClassLoader)</span></span><br><span class="line">            <span class="comment">// 用我们自定义的类加载器加载</span></span><br><span class="line">            Class&lt;?&gt; class2 = <span class="keyword">new</span> UserDefinedClassLoader(<span class="string">&quot;/home/rovo98/rovo98-dev-resources/ideaProjects/JavaDataStructure/out/production/DataStructureAndAlgorithmWithJavaImplement&quot;</span>)</span><br><span class="line">                    .loadClass(className);</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------------------Class Name--------------------------------------&quot;</span>);</span><br><span class="line">            System.out.println(class1.getName());</span><br><span class="line">            System.out.println(class2.getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------------------ClassLoader Name-------------------------------&quot;</span>);</span><br><span class="line">            System.out.println(class1.getClassLoader());</span><br><span class="line">            System.out.println(class2.getClassLoader());</span><br><span class="line">            Demo.example = <span class="number">1</span>; <span class="comment">// 修改的是系统默认类加载器加载进去的类</span></span><br><span class="line">            System.out.println(<span class="string">&quot;---------------------------Field Value------------------------------------&quot;</span>);</span><br><span class="line">            System.out.println(class1.getDeclaredField(<span class="string">&quot;example&quot;</span>).get(<span class="keyword">null</span>));</span><br><span class="line">            System.out.println(class2.getDeclaredField(<span class="string">&quot;example&quot;</span>).get(<span class="keyword">null</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span>(ClassNotFoundException | NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A demo class to be loaded to test the &#123;<span class="doctag">@code</span> UserDefinedClassLoader&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> example = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * UserDefined class loader.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDefinedClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * default constructor</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> classPath the class path of the specify class to be loaded.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UserDefinedClassLoader</span><span class="params">(String classPath)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.classPath = classPath;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">if</span> (!name.contains(<span class="string">&quot;java.lang&quot;</span>)) &#123; <span class="comment">// 排除加载系统的核心类</span></span><br><span class="line">                <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data = loadByte(name);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Loading binary class file into the memory</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> name the name of the class file to be loaded.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> binary data of the class file to be loaded.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;ResultOfMethodCallIgnored&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] loadByte(String name) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            name = name.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">            String dir = classPath + <span class="string">&quot;/&quot;</span> + name + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">            FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(dir);</span><br><span class="line">            <span class="keyword">int</span> len = fileInputStream.available();</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">            fileInputStream.read(data);</span><br><span class="line">            fileInputStream.close();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Console output:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---------------------------Class Name--------------------------------------</span><br><span class="line">basical.test.userDefinedClassLoaderTest.UserDefinedClassLoaderExample$Demo</span><br><span class="line">basical.test.userDefinedClassLoaderTest.UserDefinedClassLoaderExample$Demo</span><br><span class="line">---------------------------ClassLoader Name-------------------------------</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">basical.test.userDefinedClassLoaderTest.UserDefinedClassLoaderExample$UserDefinedClassLoader@6d6f6e28</span><br><span class="line">---------------------------Field Value------------------------------------</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><br>从执行结果可以看到，加载到内存中的两个类的包名+全称限定名是相同的, 而对应的类加载器却是不同的，输出的被加载类的值也是不同的。</p>
<h3 id="3-加载机制"><a href="#3-加载机制" class="headerlink" title="3. 加载机制"></a>3. 加载机制</h3><p>类加载机制是规定类加载器如何加载<code>.class</code>类文件到JVM内存区域中以及如何管理的规则。</p>
<h4 id="3-1-双亲委派机制"><a href="#3-1-双亲委派机制" class="headerlink" title="3.1 双亲委派机制"></a>3.1 双亲委派机制</h4><blockquote>
<p>Parent-Delegation Principle or Delegation-Hierarchy principle</p>
</blockquote>
<p>定义：某个特定的类加载器在接到加载类的请求后，首先将请求委托给它的上一级父类加载器，依次递归，知道最顶层<code>Bootstrap</code>类加载器，如果能够加载，则成功返回，否则，将类的加载请求依次往下一级别的类加载器传递，递归，此过程中，如果类找到则成功加载，否则到最后将抛出<code>ClassNotFound</code>异常。</p>
<div class="note info"><p>简单的来说，双亲委派原则对于当前类加载器，首先会将加载类的请求(<em>classloading request</em>)委托给它的父类加载器，只有它父类加载器无法加载请求的类时，它才会去响应类加载请求并尝试加载类。</p>
</div>
<p>实现：参考<code>java.lang.ClassLoader.java</code>中的<code>loadClass</code>方法。</p>
<div class="note warning"><p>从Java SE JVM 规范文档中了解到，<code>java.lang.ClassLoader</code>及其子类中的构造函数允许我们在实例化新的类加载器时指定父级类加载器。如果未明确父级，则默认使用JVM的默认类加载器作为父级加载器。</p>
<p><code>ClassLoader</code>中的<code>loadClass</code>主要做三件事情(从上面给的源码我们也可以看到):</p>
<ul>
<li>1.如果已经类加载直接返回该类；</li>
<li>2.否则，将加载类的请求委托给父级类加载器；</li>
<li>3.如果父级类加载器未找到该类，则调用<code>findClass</code>方法来加载。</li>
</ul>
<p>如果父级类加载器找不到类，则<code>ClassLoader</code>的<code>findClass</code>方法将在当前类加载器中搜索该类。在应用程序中实例化类加载器子类，我们可能会覆盖(<code>Overriding</code>)此方法。</p>
<p><code>java.net.URLClassLoader</code>类作为基本类加载器的扩展和其他jar文件，覆盖<code>java.lang.ClassLoader</code>的<code>findClass</code>方法，可以搜索一个或多个指定的<code>URL</code>以获取类和资源。</p>
</div>
<ul>
<li><strong>visibility principle</strong><blockquote>
<p>Visibility principle allows child class loader to see all the classes loaded by parent ClassLoader, but parent class loader can not see classes loaded by child.</p>
</blockquote>
</li>
</ul>
<p>可见性原则: 父类加载器加载的所有类对于其子类加载器都是是可见的，但是自类加载器的加载的类对于父类加载器是不可见的。</p>
<p>简单验证：假设我们随便写一个类，然后显式地(explicitly)用这个类的类加载器(<code>AppClassLoader</code>)的父类加载器(<code>ExtClassLoader</code>)来加载同一个类，然后验证它们时候是同一个类。</p>
<blockquote>
<p>ps: 如果子类加载器加载的类对于其父类加载是可见的，那么应该是同一个类。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rovo98.miscExamples.classLoading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> rovo98</span></span><br><span class="line"><span class="comment"> * date: 2019.04.08 22:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisibilityPrincipleTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Driver the program to test the visibility principle in class loading.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args command-line arguments.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassLoader classLoader = VisibilityPrincipleTest.class.getClassLoader();</span><br><span class="line">            <span class="comment">// print out the class loader of this class.</span></span><br><span class="line">            System.out.println(<span class="string">&quot;VisibilityPrincipleTest&#x27;s class loader is &quot;</span> + classLoader);</span><br><span class="line">            ClassLoader parentClassLoader = classLoader.getParent();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// loading this class using its parent class loader</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.rovo98.miscExamples.classLoading.VisibilityPrincipleTest&quot;</span>,</span><br><span class="line">                    <span class="keyword">true</span>, parentClassLoader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            Logger.getLogger(VisibilityPrincipleTest.class.getName()).log(Level.SEVERE, <span class="keyword">null</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VisibilityPrincipleTest&#x27;s class loader is sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">java.lang.ClassNotFoundException: com.rovo98.miscExamples.classLoading.VisibilityPrincipleTest</span><br><span class="line">	at java.net.URLClassLoader.findClass(URLClassLoader.java:381)</span><br><span class="line">	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class="line">	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">	at java.lang.Class.forName0(Native Method)</span><br><span class="line">	at java.lang.Class.forName(Class.java:348)</span><br><span class="line">	at com.rovo98.miscExamples.classLoading.VisibilityPrincipleTest.main(VisibilityPrincipleTest.java:24)</span><br><span class="line">Apr 08, 2019 10:42:41 PM com.rovo98.miscExamples.classLoading.VisibilityPrincipleTest main</span><br><span class="line">SEVERE: null</span><br><span class="line">java.lang.ClassNotFoundException: com.rovo98.miscExamples.classLoading.VisibilityPrincipleTest</span><br><span class="line">	at java.net.URLClassLoader.findClass(URLClassLoader.java:381)</span><br><span class="line">	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class="line">	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">	at java.lang.Class.forName0(Native Method)</span><br><span class="line">	at java.lang.Class.forName(Class.java:348)</span><br><span class="line">	at com.rovo98.miscExamples.classLoading.VisibilityPrincipleTest.main(VisibilityPrincipleTest.java:24)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>uniqueness principle</strong><blockquote>
<p>Uniqueness principle allows to load a class exactly once, which i sbasically achieved by delegation and ensures that child ClassLoader doesn’t reload the class already loaded by parent.</p>
</blockquote>
</li>
</ul>
<p>唯一性原则，一个类只加载一次，双亲委派原则已经实现了这一原则。</p>
<p><img data-src="jvmclassloader.jpg" alt=""></p>
<p>双亲委派机制比较好理解，目的是为了<strong>不重复加载已经加载的类, 提高效率</strong>, 还有就是<strong>强制从最顶层的类加载器开始搜索类文件，确保核心基础类优先加载</strong>。</p>
<p>下面介绍<strong>破坏双亲委派机制</strong>, 了解为什幺要破坏看似很好的双亲委派机制。</p>
<h4 id="3-2-破坏双亲委派机制"><a href="#3-2-破坏双亲委派机制" class="headerlink" title="3.2 破坏双亲委派机制"></a>3.2 破坏双亲委派机制</h4><h5 id="3-2-1-唯一标识"><a href="#3-2-1-唯一标识" class="headerlink" title="3.2.1. 唯一标识"></a>3.2.1. 唯一标识</h5><p>对于任意的一个类，都需要由<strong>加载它的类加载器</strong>和这个<strong>类本身</strong>来一同确定其在Java虚拟机中<strong>唯一性</strong>。</p>
<p>验证例子: <code>DifferentClassLoaderTest.java</code></p>
<p>判断一个类是否相同，通常用<code>equals()</code>方法，<code>isInstance()</code>方法和<code>isAssignableFrom()</code>方法来判断，对于同一类，如果没用采用相同的类加载器来加载，那么即使是同一个类，JVM也是判断它为不同类的(唯一标识不同)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> basical.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> rovo98</span></span><br><span class="line"><span class="comment"> * date: 2019.04.07 17:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DifferentClassLoaderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Driver the program to test</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args command-line arguments.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if ClassNotFoundException throws</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// a user defined classloader</span></span><br><span class="line">        ClassLoader classLoader = <span class="keyword">new</span> ClassLoader() &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;ResultOfMethodCallIgnored&quot;)</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                String fileName = name.substring(name.lastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">                InputStream stream = getClass().getResourceAsStream(fileName);</span><br><span class="line">                <span class="keyword">if</span> (stream == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[stream.available()];</span><br><span class="line">                    <span class="comment">// 将流写入字节数组b中</span></span><br><span class="line">                    stream.read(b);</span><br><span class="line">                    <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Object obj = classLoader.loadClass(<span class="string">&quot;basical.test.DifferentClassLoaderTest&quot;</span>).newInstance();</span><br><span class="line">        System.out.println(obj.getClass());</span><br><span class="line">        System.out.println(obj <span class="keyword">instanceof</span> DifferentClassLoaderTest);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class basical.test.DifferentClassLoaderTest</span><br><span class="line">false</span><br></pre></td></tr></table></figure></p>
<p>如果在通过实例化的使用，直接转化成<code>DifferentClassLoaderTest</code>对象:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = (DifferentClassLoaderTest) classLoader.loadClass(<span class="string">&quot;basical.test.DifferentClassLoaderTest&quot;</span>).newInstance();</span><br></pre></td></tr></table></figure>
<p>就会报<code>java.lang.ClassCastException</code>, 因为两者不属于同一类加载器加载，所以不能转化。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ClassCastException: basical.test.DifferentClassLoaderTest cannot be cast to basical.test.DifferentClassLoaderTest</span><br><span class="line">	at basical.test.DifferentClassLoaderTest.main(DifferentClassLoaderTest.java:40)</span><br></pre></td></tr></table></figure></p>
<h5 id="3-2-2-为什么需要破坏双亲委派机制"><a href="#3-2-2-为什么需要破坏双亲委派机制" class="headerlink" title="3.2.2. 为什么需要破坏双亲委派机制"></a>3.2.2. 为什么需要破坏双亲委派机制</h5><p>在某些时候父类加载器需要委托子类加载器去加载<code>.class</code>文件。受到加载范围的限制，父类加载器无法加载到需要的文件，以<code>Driver</code>接口为例，由于<code>Driver</code>接口定义在JDK中，而其实现由各个数据库的服务商来提供，比如MySQL的就写了<code>MySQL Connector</code>，那么问题来了，<code>DriverManager</code>（也由JDK提供）要加载各个实现<code>Driver</code>接口的实现类，然后进行管理，但是<code>DriverManager</code>由<code>Bootstrap</code>类加载器加载，只能记载<code>JAVA_HOME</code>的<code>lib</code>目录下的文件，而其实实现是由服务商提供的，由系统类加载器加载，这个时候就需要<code>Bootstrap</code>类加载器来委托子类加载器来加载<code>Driver</code>实现，从而破坏了双亲委派，这仅仅是破坏双亲委派机制的一个简单例子。</p>
<h5 id="3-2-3-破坏双亲委派机制的实现"><a href="#3-2-3-破坏双亲委派机制的实现" class="headerlink" title="3.2.3. 破坏双亲委派机制的实现"></a>3.2.3. 破坏双亲委派机制的实现</h5><p>既然我们已经知道了什么是双亲委派机制(<em>Delegation-Hierarchy Principle or Parent-Delegation principle</em>)， 那么实现破坏双亲委派机制要做的就是打破双亲委派机制指定的规则。</p>
<p>具体实现大概就是自定义类加载，通过复写<code>loadClass</code>和<code>findClass</code>来实现。这里就不再展开探讨。</p>
<div class="note primary"><p>参考连接:</p>
<ul>
<li><a href="https://www.geeksforgeeks.org/jvm-works-jvm-architecture/">https://www.geeksforgeeks.org/jvm-works-jvm-architecture/</a></li>
<li><a href="http://www.cnblogs.com/joemsu/p/9310226.html">http://www.cnblogs.com/joemsu/p/9310226.html</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/ext/basics/load.html">https://docs.oracle.com/javase/tutorial/ext/basics/load.html</a></li>
<li><a href="https://dzone.com/articles/demystify-java-class-loading">https://dzone.com/articles/demystify-java-class-loading</a></li>
</ul>
</div>
<h3 id="4-加载过程"><a href="#4-加载过程" class="headerlink" title="4. 加载过程"></a>4. 加载过程</h3><p>通过上面的介绍，我们已经大致了解了类加载器的工作原理。下面主要了解的是JVM加载类的过程。</p>
<p>即JVM类的加载子系统到底做了什么？</p>
<p>简单的来说，类的加载分为三个阶段: <em>loading</em>(<strong>加载</strong>)、<em>linking</em>(<strong>链接</strong>)、<em>intiailising</em>(<strong>初始化</strong>)。</p>
<p><img data-src="jvm-1-class-loading-phases.gif" alt=""></p>
<h4 id="4-1-加载-loading"><a href="#4-1-加载-loading" class="headerlink" title="4.1. 加载 - loading"></a>4.1. 加载 - loading</h4><p>这一阶段就是把<code>.class</code>类文件以二进制数据的形式加载到JVM的内存区中的方法区(Method Area, JVM内存区部分内容会讲到)中。由类加载器来完成，我们简单了解一下什么时候会触发JVM去加载外部的<code>.class</code>类文件:</p>
<ul>
<li>显式的字节码指令集(<code>new/getstatic/putstatic/invokestatic</code>): 对应的场景就是创建对象或者调用到类文件的静态变量/静态方法/静态代码块;</li>
<li>反射: 通过对象反射获取类对象时;</li>
<li>继承: 创建子类触发父类加载;</li>
<li>入口: 包含<code>main</code>方法的类首先被加载。</li>
</ul>
<p>需要知道的是，JVM只定了类加载器的规范，但是却不明确的规定类加载器的目标文件，也就是说，JVM把具体加载类的逻辑交给用户来处理，我们可以从硬盘、网络、中间文件等来加载<code>.class</code>文件，只要加载进去内存的二进制数据符合JVM规定的格式，都是合法的。</p>
<h4 id="4-2-链接-linking"><a href="#4-2-链接-linking" class="headerlink" title="4.2. 链接 - linking"></a>4.2. 链接 - linking</h4><p>类加载到JVM的内存区中后，在<strong>链接</strong> 阶段要经过<strong>验证(verifing)</strong>、<strong>准备(preparation)</strong>、<strong>解析(Resolving)</strong>三个阶段的处理。</p>
<ul>
<li><strong>验证(Bytecode verification)</strong>: 主要包含对类文件对应内存二进制数据的格式、语义关联、语法逻辑和符号引用(Symbolic Reference)的验证， 如果验证不通过则抛出<code>VerifyError</code>错误。但是该阶段是不强制性执行的，我们可以通过指定JVM的参数<code>-Xverify:none</code>来关闭，提高性能(在确保字节码数据无需再验证的情况下);</li>
<li><strong>准备(Class preparation)</strong>: 当我们通过验证阶段后，内存的方法区存放的是被“紧密压缩”的数据段，在这个阶段会对静态(<em>static</em>)变量进行内存分配，扩展内存段的空间，但是<strong>还未初始化数据，即还是</strong><code>0</code><strong>或</strong><code>null</code>;</li>
<li><strong>解析(Resolving)</strong>: 把方法区中的所有符号引用(<strong>Symbolic Reference</strong>)全部替换成直接引用(<strong>Direct Reference</strong>)， 经过解析阶段后，类在方法区中占用的空间将膨胀变大。</li>
</ul>
<h4 id="4-3-初始化-initializing"><a href="#4-3-初始化-initializing" class="headerlink" title="4.3. 初始化 - initializing"></a>4.3. 初始化 - initializing</h4><p>类加载过程的最后一个阶段，为所有的静态变量赋初值，并执行静态代码块(<em>static block</em>)</p>
<p><strong>misc</strong>:</p>
<p>类的使用对应这类加载的触发的条件，就是说的类的使用就是触发类加载的条件，不过对类的使用需要的初始化操作过后。</p>
<p>最后是类的卸载，我们都知道JVM有专门的垃圾回收机制来处理。以上就是类的生命周期了。</p>
<div class="note primary"><p>参考链接:</p>
<ul>
<li><a href="http://www.techjava.de/topics/2008/01/java-class-loading/">http://www.techjava.de/topics/2008/01/java-class-loading/</a></li>
</ul>
<p>我之前写过的相关文章:</p>
<ul>
<li><a href="/posts/12448424/">JDK, JRE, JVM | 深入了解</a></li>
</ul>
</div>
<h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><p>通过前文，我们已经基本了解了类加载器的工作原理以及类的生命周期。</p>
<p>下面我们需要了解的是该如何利用类加载器的特点，最大限度地发挥它的作用。</p>
<h3 id="1-热部署"><a href="#1-热部署" class="headerlink" title="1. 热部署"></a>1. 热部署</h3><p>说到热部署，我们第一时间可能想到的是在生产机器上更新代码后，无需重启应用容器就能更新服务，这样的好处是服务无需中断可以持续运行，那么与之对应的<strong>冷部署</strong>就是需要重启容器实例的。</p>
<ul>
<li><strong>热部署(Hot Deployment)</strong>: 热部署是应用容器自动更新应用的一种能力。</li>
</ul>
<p>首先热部署应用是容器拥有的一种能力，这种能力是容器本身设计出来的，跟具体的IDE开发工具无关。而且热部署无需重启服务器，应用可以保持用户态不受影响。</p>
<div class="note danger"><p>有一种看似很像热部署的情况我们需要注意： 在使用IDE开发时也不需要重启服务，修改代码后即时生效，这看起来和热部署的服务无需重启一样，但是它背后的运行机制却是截然不同的。它应用的是JVM的本身附带的<strong>热替换(Hot Swap)</strong>能力。热部署和热替换是两个完全不同的概念。</p>
<p>由于在开发的时候，它们经常一起使用，所以非常容易把他们搞混。</p>
</div>
<h4 id="1-1-原理"><a href="#1-1-原理" class="headerlink" title="1.1. 原理"></a>1.1. 原理</h4><p>从热部署的定义来看，我们知道它其实应用容器的一种能力，要达到的目的是<strong>在服务没有重启的情况下更新应用，也就是把新的代码编译后产生的新类文件替换掉内存中的旧类文件</strong>。</p>
<p>结合前文已经介绍过的类加载器的特性，热部署的过程大概要分为两个步骤进行:</p>
<ul>
<li>由于同一类加载器只能加载一次类文件(同一类文件, 因为有缓存), 在没有把新类文件加载进内存之前，我们不能把旧的类文件卸载，所以我们需要通过一个心得类加载器来加载。(<strong>此时，内存存在两个新旧的类文件, 它们的类名路径相同但类加载器不同，即类的唯一标识不同</strong>)</li>
<li>最后一步，我们要做的就是如何使用新的类文件，并卸载旧的类文件及其对象。</li>
</ul>
<p>完成上面两个步骤，就可以达到新代码热部署的效果。</p>
<h4 id="1-2-实现"><a href="#1-2-实现" class="headerlink" title="1.2. 实现"></a>1.2. 实现</h4><p>下面通过一系列简单的例子来一步步实现热部署。</p>
<ul>
<li><strong>实现自定义类加载</strong></li>
</ul>
<p>使用不同的类加载器可以把同一个类文件加载到JVM的方法区中，但是注意它们本质还是不同的”类(一个类由它的全称限定名加上它的类加载器类来标识)”</p>
<ul>
<li><strong>替换自定义类加载器</strong></li>
</ul>
<p>既然一个类可以通过不同的类加载器多次的加载到JVM的方法区中，那么一个类经过修改编译后再加载进去，从应用的角度来看，这就做到了应用更新，那么如何在线程运行不中断的情况下更新类呢？</p>
<p>下面给出一个简单的例子，<code>ClassReloading</code>启动<code>main</code>方法通过死循环来不断创建类加载器，同时不断地加载类而且执行类的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rovo98.miscExamples.hotDeployment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> rovo98</span></span><br><span class="line"><span class="comment"> * date: 2019.04.09 15:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassReloading</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Driver the program to test the class reloading</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args command-line arguments.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;InfiniteLoopStatement&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InterruptedException, InstantiationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">// Using infinite loop to make the thread keep running.</span></span><br><span class="line">            String className = <span class="string">&quot;com.rovo98.miscExamples.hotDeployment.ClassReloading$User&quot;</span>;</span><br><span class="line">            Class&lt;?&gt; target = <span class="keyword">new</span> MyClassLoader().loadClass(className);</span><br><span class="line">            <span class="comment">// Invokes the method of the loaded class using Reflection</span></span><br><span class="line">            System.out.println(count + <span class="string">&quot; round: loading target successfully, ready to invoke the method!&quot;</span>);</span><br><span class="line">            target.getDeclaredMethod(<span class="string">&quot;execute&quot;</span>).invoke(target.newInstance());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If we use system class loader, it will be &#x27;AppClassLoader&#x27;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Sleep to avoid the case happen that it will occurs &#x27;ClassNotFoundException&#x27; error</span></span><br><span class="line">            <span class="comment">// if the target class had been removed.</span></span><br><span class="line">            <span class="comment">// so make the thread stop to avoid this case happen.</span></span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The class to be tested for loading.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ask();</span><br><span class="line"><span class="comment">//            say();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;What is your name?&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;My name is rovo98!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// a user defined classloader</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;ResultOfMethodCallIgnored&quot;)</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            String fileName = name.substring(name.lastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">            InputStream stream = getClass().getResourceAsStream(fileName);</span><br><span class="line">            <span class="keyword">if</span> (stream == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name); <span class="comment">// load the class using system default class loaders</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[stream.available()];</span><br><span class="line">                <span class="comment">// write the stream into the byte array b</span></span><br><span class="line">                stream.read(b);</span><br><span class="line">                <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ClassReloading</code>线程运行起来，然后通过修改代码来查看结果，这里可以简单通过交替注释<code>User</code>类中的<code>ask()</code>和<code>say()</code>方法来测试。</p>
<p><strong>Output</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 round: loading target successfully, ready to invoke the method!</span><br><span class="line">What is your name?</span><br><span class="line">2 round: loading target successfully, ready to invoke the method!</span><br><span class="line">What is your name?</span><br><span class="line">3 round: loading target successfully, ready to invoke the method!</span><br><span class="line">My name is rovo98!</span><br><span class="line">4 round: loading target successfully, ready to invoke the method!</span><br><span class="line">What is your name?</span><br><span class="line">5 round: loading target successfully, ready to invoke the method!</span><br><span class="line">What is your name?</span><br><span class="line">6 round: loading target successfully, ready to invoke the method!</span><br><span class="line">My name is rovo98!</span><br><span class="line">7 round: loading target successfully, ready to invoke the method!</span><br><span class="line">My name is rovo98!</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>每次循环调用都新创建一个自定义的类加载器，然后通过反射创建对象调用方法，在修改代码编译后，新的类就会通过反射被创建，并执行新的代码业务，而主线程一直没有停过(死循环)。</p>
<p>到了这里，我们已经简单实现了热部署了，即实现了手动无中断部署，但是存在很明显的缺点，我们需要手动编译代码(当然在IDE中我们可以通过简单的设置, 使得类文件修改后随着保存操作而自动编译, 但这也是属于”手动编译”), 而且内存中会不断新增的类加载器和对象，如果速度过快而且过于频繁更新，就非常容易造成堆溢出(<code>OutOfMemoryError</code>), 下面的一个例子，我们将通过增加一些规则来保证旧的类和对象能够被垃圾收集器(GC, Garbage Collector)自动回收。</p>
<ul>
<li><strong>回收自定义类加载器</strong></li>
</ul>
<p>通常情况下，类加载器会持有该加载器加载过的所有类的引用, 所以如果类是经系统默认类加载器加载的话，那就很难被回收，除非符合根节点不可达原则(GC 算法内容，见下面给出的简单说明)才会被回收。</p>
<div class="note warning"><p>GC算法， 首先GC的垃圾回收算法使用的不是<strong>引用计数(Reference counting)原理</strong>, 因为会出现”循环引用“ -&gt; 如： 如果存在不可达对象(dead object)<code>A</code>和<code>B</code>, 它们互相指向对方，那么垃圾回收器将永远无法回收它们。</p>
<p>为此GC引入以下算法:</p>
<ul>
<li><strong>1.</strong><code>mark</code>标记， 即标记现有的可达对象(alive object), 选择一个对象(方法，线程局部变量等)作为<code>GC root</code>，然后从这个根开始遍历图，直到所有的结点遍历完，遍历过的结点标记为alive.<blockquote>
<p>为了确保这一步骤能够顺利进行，JVM需要挂起正在执行的线程，因为对象如果一直发生变化的话，图的遍历是无法成功遍历的。这一现象，我们一般称为<code>Stop the world pause</code></p>
</blockquote>
</li>
</ul>
<p><img data-src="jvm-1-gc-mark.png" alt=""></p>
<ul>
<li><strong>2.</strong><code>sweep</code>清除阶段：即清除不可达对象, 有直接对堆内存上的对象直接清除然后不管的，有清除之后，进行压缩的，有将堆内存分成两个分区，每次只使用一个分区，当<code>mark</code>操作结束后，将<strong>alive objects</strong>复制到另一个分区，然后清除当前分区，使用另一个分区，交替进行。 分别对应下面是三种情况。</li>
<li><code>mark-sweep</code><br><img data-src="jvm-1-gc-mark-sweep.png" alt=""></li>
<li><code>mark-sweep-compact</code><br><img data-src="jvm-1-gc-mark-sweep-compact.png" alt=""></li>
<li><code>mark-copy</code><br><img data-src="jvm-1-gc-mark-copy.png" alt=""></li>
</ul>
<p>当然，实际上JVM使用的GC算法还有更多，垃圾收集器也很多种，例如对堆内存分代(generations, young generation, old generation, permanent generation), 不同的生代使用不同的策略。</p>
<p>😅额。。。差点跑偏了，这里就不再做过多的解释了。</p>
</div>
<p>下面继续给出一个简单的例子，我们知道上文的<code>ClassReloading</code>只是不断创建心得类加载器类加载新类，从而更新类的方法。下面的例子，通过模拟WEB应用，更新整个应用的上下文<code>Context</code>。其实代码本质上和上面的是一样的，只不过我们通过加载<code>Model</code>层、<code>DAO</code>层和<code>Service</code>层来模拟WEB应用。</p>
<div class="note warning"><p>为了方便测试，所有的类均写在同一个类文件中。</p>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rovo98.miscExamples.hotDeployment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> rovo98</span></span><br><span class="line"><span class="comment"> * date: 2019.04.09 16:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextReloading</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Driver the program to test the &#123;<span class="doctag">@code</span> ContextReloading&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args command-line arguments.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;InfiniteLoopStatement&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException,</span></span><br><span class="line"><span class="function">         InstantiationException, IllegalAccessException, InvocationTargetException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            count++;</span><br><span class="line">           Object context = newContext();</span><br><span class="line">            System.out.println(count + <span class="string">&quot; round: context loaded successfully, ready to invoke the methods!&quot;</span>);</span><br><span class="line">           invokeContext(context);</span><br><span class="line"></span><br><span class="line">           Thread.sleep(<span class="number">8000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. Create the Context</span></span><br><span class="line"><span class="comment">     * 2. Context object is used as a GC root</span></span><br><span class="line"><span class="comment">     * 3. Before returning the context object, we call the init() method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a Context Object.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newContext</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException,</span></span><br><span class="line"><span class="function">         InvocationTargetException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        String className = <span class="string">&quot;com.rovo98.miscExamples.hotDeployment.ContextReloading$Context&quot;</span>;</span><br><span class="line">        Class&lt;?&gt; contextClass = <span class="keyword">new</span> MyClassLoader().loadClass(className);</span><br><span class="line">        Object context = contextClass.newInstance();</span><br><span class="line">        contextClass.getDeclaredMethod(<span class="string">&quot;init&quot;</span>).invoke(context);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Simply invokes the method of the context class</span></span><br><span class="line"><span class="comment">    since the method&#x27;s rules will be update during the runtime</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeContext</span><span class="params">(Object context)</span> <span class="keyword">throws</span> NoSuchMethodException,</span></span><br><span class="line"><span class="function">         InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        context.getClass().getDeclaredMethod(<span class="string">&quot;showUser&quot;</span>).invoke(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> UserService userService = <span class="keyword">new</span> UserService();</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           System.out.println(userService.getUserMessage());</span><br><span class="line">           System.out.println(<span class="string">&quot;method invoked&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// initialize the object</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//            System.out.println(&quot;init successfully&quot;);</span></span><br><span class="line">           UserDao userDao = <span class="keyword">new</span> UserDao();</span><br><span class="line">           userDao.setUser(<span class="keyword">new</span> User());</span><br><span class="line">           userService.setUserDao(userDao);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// simple user service object</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">getUserMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> userDao.getUserName();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// simple user DAO object</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> User user;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> user.getName();</span><br><span class="line"><span class="comment">//            return user.getAlias();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.user = user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A simple model class</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name = <span class="string">&quot;rovo98&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> String alias = <span class="string">&quot;testUser&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getAlias</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> alias;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAlias</span><span class="params">(String alias)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.alias = alias;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a user defined class loader.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;ResultOfMethodCallIgnored&quot;)</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            String fileName = name.substring(name.lastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">            InputStream stream = getClass().getResourceAsStream(fileName);</span><br><span class="line">            <span class="keyword">if</span> (stream == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[stream.available()];</span><br><span class="line">                stream.read(b);</span><br><span class="line">                <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 round: context loaded successfully, ready to invoke the methods!</span><br><span class="line">rovo98</span><br><span class="line">2 round: context loaded successfully, ready to invoke the methods!</span><br><span class="line">rovo98</span><br><span class="line">3 round: context loaded successfully, ready to invoke the methods!</span><br><span class="line">rovo98</span><br><span class="line">4 round: context loaded successfully, ready to invoke the methods!</span><br><span class="line">testUser</span><br><span class="line">5 round: context loaded successfully, ready to invoke the methods!</span><br><span class="line">testUser</span><br><span class="line">6 round: context loaded successfully, ready to invoke the methods!</span><br><span class="line">testUser</span><br><span class="line">init successfully</span><br><span class="line">7 round: context loaded successfully, ready to invoke the methods!</span><br><span class="line">testUser</span><br><span class="line">init successfully</span><br><span class="line">8 round: context loaded successfully, ready to invoke the methods!</span><br><span class="line">testUser</span><br><span class="line">init successfully</span><br><span class="line">9 round: context loaded successfully, ready to invoke the methods!</span><br><span class="line">testUser</span><br><span class="line">init successfully</span><br><span class="line">10 round: context loaded successfully, ready to invoke the methods!</span><br><span class="line">testUser</span><br><span class="line">11 round: context loaded successfully, ready to invoke the methods!</span><br><span class="line">rovo98</span><br><span class="line">method invoked</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>输出结果和上一个例子类似，可以自己运行然后修改业务逻辑。不同与上一个例子，它解决了旧类的移除问题，因为<code>context</code>对象是作为GC root的，<code>context</code>又由我们自定义的类加载器加载, 由于<code>User/Dao/Service</code>的类都依赖于<code>context</code>，所以它们也是由自定义的类加载器加载的。</p>
<p>根据GC roots 原理，在创建新的自定义类加载后，旧的类加载器已经没有了任何引用链可达，符合GC回收规则，将会被GC收集器回收释放内存(注意不是马上回收)。</p>
<blockquote>
<p>运行程序，启动线程，用jvisualvm工具查看，并手动执行GC来验证</p>
</blockquote>
<ul>
<li>线程启动并运行一小会后(可以看到线程加载的类数量在持续增加):<br><img data-src="jvm-1-classreloading-vmdiagram-1.png" alt=""></li>
<li>手动执行GC来回收垃圾(从图中可以看到执行一次GC后卸载了56个类，而<code>1615</code>个类的加载刚刚就是一个类运行所需的基本的类(核心基础类等)):<br><img data-src="jvm-1-classreloading-vmdiagram-2.png" alt=""></li>
</ul>
<p>至此已经完成了热部署的流程，但是我们如果仔细看的话，这个热部署的实现的策略会把整个<code>context</code>对象也替换成新的, 那么用户的状态也将无法保留。而实际情况是我们只需要动态更新某些模块即可，而不是全局。这个也比较好处理，就是从业务上将需要热部署的交给自定义的类加载器加载，而持久化资源交给系统默认的类加载器去完成加载。</p>
<ul>
<li><strong>自动加载类加载器</strong></li>
</ul>
<p>其实涉及到代码涉及优雅问题，基本上我们就需要拿出设计模式(<strong>Design Pattern</strong>) 来对号入座的解决问题，毕竟这是前人经过千万实践锤炼出来的软件构建内功心法。</p>
<p>针对于我们热部署的场景，如果想把热部署细节封装起来，那代理模式无疑是最符合要求的，把类加载器的更替、回收，隔离等细节都放在代理对象里面来完成，而对于用户是透明的，对于终端用户而言，给他们的感觉就是纯粹的热部署了。</p>
<p>至于如何实现自动热部署，方式也相对比较简单吧，监听我们需要部署的目录，如果文件的时间和大小发生改变，即修改过后，则判断应用更新需求，触发类加载器的创建和旧对象的回收，此时也可以引入观察者模式来实现。</p>
<p>至于实现，我们参考现有的别人已经实现的热部署工具:</p>
<ul>
<li><a href="http://akhikhl.github.io/gretty-doc/Hot-deployment.html">Gretty</a></li>
<li><a href="https://dcevm.github.io/">DECVM</a><br>等等。。</li>
</ul>
<p>或者使用现成的热部署工具。<br>参考这篇文章即可:</p>
<ul>
<li><a href="https://dzone.com/articles/hot-swap-java-bytecode-on-runtime">https://dzone.com/articles/hot-swap-java-bytecode-on-runtime</a></li>
</ul>
<p>其中有收费的商用工具JRabel, 免费开源的DECVM等。</p>
<div class="note primary"><p>参考链接:</p>
<ul>
<li><a href="https://stackoverflow.com/questions/35249234/how-hot-deployment-works-internally">https://stackoverflow.com/questions/35249234/how-hot-deployment-works-internally</a></li>
<li><a href="https://iq.opengenus.org/memory-management-in-java-mark-sweep-compact-copy/">https://iq.opengenus.org/memory-management-in-java-mark-sweep-compact-copy/</a></li>
<li><a href="https://plumbr.io/handbook/garbage-collection-algorithms">https://plumbr.io/handbook/garbage-collection-algorithms</a></li>
<li><a href="https://developer.jboss.org/wiki/CurrentStateOfHotDeploymentInJava">https://developer.jboss.org/wiki/CurrentStateOfHotDeploymentInJava</a></li>
<li><a href="https://www.future-processing.pl/blog/better-java-hot-code-replace-at-no-cost/">https://www.future-processing.pl/blog/better-java-hot-code-replace-at-no-cost/</a></li>
</ul>
</div>
<h3 id="2-类隔离"><a href="#2-类隔离" class="headerlink" title="2. 类隔离"></a>2. 类隔离</h3><h4 id="2-1-背景介绍"><a href="#2-1-背景介绍" class="headerlink" title="2.1. 背景介绍"></a>2.1. 背景介绍</h4><p>通常我们的应用依赖不同的第三方类库会出现个不同版本的类库，如果只是使用系统内置的类加载器的话, 那么一个类库只能加载唯一的一个版本，下那个家在其他版本的时候，会从加载缓存里面发现类已经存在而停止加载。但是不同的业务往往又需要不同版本的类库，这是就会出现<code>ClassNotFoundException</code>。一般是在运行时才会出现异常，因为在编译的时候我们通常都使用<a href="https://maven.apache.org/">MAVEN</a>等编译工具把冲突的版本给排除掉了。</p>
<p>另外一种情况是WEB容器的内核依赖的第三方类库需要跟应用依赖的类库隔离开来, 避免依稀而安全隐患，不然如果共用的话，应用升级依赖版本会导致WEB容器不稳定。</p>
<p>基于以上的介绍，我们已经基本知道了什么是<strong>类隔离(class isolation)</strong>以及它大概需要解决的问题。</p>
<h4 id="2-2-原理"><a href="#2-2-原理" class="headerlink" title="2.2. 原理"></a>2.2. 原理</h4><p>类隔离的原理其实也很简单，前文我们介绍过<strong>类的唯一标识</strong>(内存中定位一个类大概是这样的<code>&lt;类加载器, 类全称限定名&gt;</code>, 即一个类的标识有加载它的类加载器和它的全称限定名组成)。用不同的类加载器加载的相同的类(全称限定名一样，但是版本不一样), 在JVM看来，有通过这种方式加载进去的具有相同全称限定名的类是完全不同的。<strong>但是在业务视角上来看，我们可以把它们看作是相同的类。</strong></p>
<p>验证唯一标识的例子可以看上文讨论加载机制时提到的唯一标识。下面再提供一个简单的例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rovo98.miscExamples.classLoading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> rovo98</span></span><br><span class="line"><span class="comment"> * date: 2019.04.10 16:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DifferentClassLoaders</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Driver the program to test loading the same class using different classloader</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args command-line arguments.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException,</span></span><br><span class="line"><span class="function">         IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">       Class&lt;?&gt; clazz1 = Cat.class;</span><br><span class="line">       String className = <span class="string">&quot;com.rovo98.miscExamples.classLoading.DifferentClassLoaders$Cat&quot;</span>;</span><br><span class="line">       Class&lt;?&gt; clazz2 = <span class="keyword">new</span> MyClassLoader().loadClass(className);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Compare their class name(seems to be the same): &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;clazz1: &quot;</span> + clazz1.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;clazz2: &quot;</span> + clazz2.getName());</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Compare their class loader: &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;clazz1&#x27;s classloader: &quot;</span> + clazz1.getClassLoader());</span><br><span class="line">        System.out.println(<span class="string">&quot;clazz2&#x27;s classloader: &quot;</span> + clazz2.getClassLoader());</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;The static field value: &quot;</span> + Cat.age);</span><br><span class="line">        Cat.age = <span class="number">3</span>; <span class="comment">// change the static field of the class Cat</span></span><br><span class="line">        System.out.println(<span class="string">&quot;And to see the difference: &quot;</span>);</span><br><span class="line">        Field f1 = clazz1.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        f1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Field f2 = clazz2.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        f2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;clazz1&#x27;s static field: &quot;</span> + f1.getInt(clazz1.newInstance()) + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;clazz2&#x27;s static field: &quot;</span> + f2.getInt(clazz2.newInstance()) + <span class="string">&quot;.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A simple for testing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;ResultOfMethodCallIgnored&quot;)</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            String fileName = name.substring(name.lastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">            InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">            <span class="keyword">if</span> (is == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name); <span class="comment">// loading the class using system default classloader if MyClassLoader</span></span><br><span class="line">                                              <span class="comment">// can not the specify class.</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">                is.read(b);</span><br><span class="line">                <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong>:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Compare their class name(seems to be the same): </span><br><span class="line">clazz1: com.rovo98.miscExamples.classLoading.DifferentClassLoaders$Cat</span><br><span class="line">clazz2: com.rovo98.miscExamples.classLoading.DifferentClassLoaders$Cat</span><br><span class="line"></span><br><span class="line">Compare their class loader: </span><br><span class="line">clazz1&#x27;s classloader: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">clazz2&#x27;s classloader: com.rovo98.miscExamples.classLoading.DifferentClassLoaders$MyClassLoader@7f31245a</span><br><span class="line"></span><br><span class="line">The static field value: 2</span><br><span class="line">And to see the difference: </span><br><span class="line">clazz1&#x27;s static field: 3.</span><br><span class="line">clazz2&#x27;s static field: 2.</span><br></pre></td></tr></table></figure></p>
<h4 id="2-3-实现"><a href="#2-3-实现" class="headerlink" title="2.3. 实现"></a>2.3. 实现</h4><p>虽然类隔离的原理很简单，但是实现一个高性能可扩展的高可用的隔离容器却不是简单的。就比如我们都知道Spring容器本质就是一个生产和管理<code>Bean</code>的集合对象，但是它包含了大量优秀的设计模式和复杂的框架实现。</p>
<p>上文提到的类隔离应用场景是在内存运行时才发现问题的，需要通过<strong>内存隔离</strong>来处理。而在这里，我们只先了解一下更为通用和简单的冲突解决方法。</p>
<ul>
<li><strong>冲突排除</strong></li>
</ul>
<p>冲突总是发生在编译时期，那么基本<a href="https://maven.apache.org/">Maven</a>工具可以帮我们完成大部分的工作，Maven的工作模式就是将我们第三方类库的所有依赖都依次检索，最终排除掉产生冲突jar包的版本。</p>
<ul>
<li><strong>冲突匹配</strong></li>
</ul>
<p>当我们无法通过简单的排除来解决问题的时候，另外一个方法就是重新装配第三方类库，例如通过<a href="https://github.com/shevek/jarjar">jarjar</a>开源工具类处理。它可以通过字节码技术将我们依赖的第三方类库重命名，同时修改代码里面对第三方类库引用的路径。这样如果出现同名第三方类库的话，通过该”硬编码“的方式修改其中一个类库，从而消除了冲突。</p>
<ul>
<li><strong>冲突隔离</strong></li>
</ul>
<p>上面的两种方式在小型系统中比较合适，也比较敏捷高效。但是对于分布式大型系统的话，通过硬编码方式来解决冲突就难以完成了。办法是通过隔离容器，从逻辑上区分类库的作用域，从而对内存的类进行隔离。</p>
<div class="note primary"><p>misc: </p>
<ul>
<li><a href="https://www.jcp.org/en/jsr/detail?id=121">应用程序隔离规范 JSR 121 - https://www.jcp.org/en/jsr/detail?id=121</a></li>
<li><a href="https://www.flux.utah.edu/janos/jsr121-internal-review/java/lang/isolate/package-summary.html">An implementation of JSR 121 - https://www.flux.utah.edu/janos/jsr121-internal-review/java/lang/isolate/package-summary.html</a></li>
</ul>
<p>相关开源项目:</p>
<ul>
<li><a href="https://github.com/chrisgleissner/jisolate">https://github.com/chrisgleissner/jisolate</a></li>
</ul>
<p>参考链接:</p>
<ul>
<li><a href="https://www.toptal.com/java/java-wizardry-101-a-guide-to-java-class-reloading">https://www.toptal.com/java/java-wizardry-101-a-guide-to-java-class-reloading</a></li>
<li><a href="https://stackoverflow.com/questions/3726635/using-classloader-for-isolating-two-static-classes">https://stackoverflow.com/questions/3726635/using-classloader-for-isolating-two-static-classes</a></li>
</ul>
</div>
<p>有关于JVM中类加载的内容就先简单了解到这里了，后续再根据自己的需求深入学习吧!👆</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架概览</title>
    <url>/posts/6a98b274/</url>
    <content><![CDATA[<p>集合（Collection），顾名思义，是一组对象。当需要处理任何的一组对象的时候，我们不可避免地要与集合打交道。集合也存在于几乎所有编程语言中，因此 Java 也不例外，为了开发人员能够更高效地处理集合数据，Java 提供了一个集合框架 （Collections framework），它由一系列接口以及实现类组成，提供了不同类型的集合：<strong>List, Set, Map, Queue, Deque</strong> 等。</p>
<p>这些随时可用的集合类可以帮助解决许多非常常见的问题，帮助处理一组同构和异构对象。其中集合涉及的常见操作有添加（add），删除（delete），排序（sorting），搜索（searching）以及一些操作集合的较复杂的算法。Java 的集合框架为这些操作提供了透明化的支持。</p>
<span id="more"></span>
<h2 id="1-Java-集合框架结构"><a href="#1-Java-集合框架结构" class="headerlink" title="1. Java 集合框架结构"></a>1. Java 集合框架结构</h2><p>为了更好地了解 Java 集合框架整体结构，我们首先需要对该框架所提供的核心接口有一定了解。因为框架中我们可能使用到的具体实现类（concrete classes）都是基于这些接口的。通过生成集合框架的类图，我们可以看到，该框架的主要核心接口是 <code>Collection</code> 和 <code>Map</code>。不同于数组，所有的集合均是根据实际元素数量来动态调整集合大小的。<code>Collection</code> 用于存储一组对象，而 <code>Map</code> 用于存储一组强关联的对象对，其中每一个对由 <code>key</code> 和 <code>value</code> 组成，即它是一种符号表（symbol table）。</p>
<div align="center" style="display: flex; flex-direction:column;">
    <img data-src='basic-collections.png'/>
    <span style="padding-top:1em;">图 1.1 Collection 接口层次结构</span>
</div>

<p>图 1.1 展示了 <code>Collection</code> 接口的层次结构，该结构清晰地展示集合框架根接口 <code>Collection</code> 接口与其他接口（父接口和子接口）以及实现类的继承或实现关系。而 <code>Interface</code> 是 Java 类的模板，定义了具体实现类应该具备的行为。因此，我们可以通过了解各个接口来对该结构有初步的整体了解。</p>
<p>首先，<code>Collection</code> 接口继承了 <code>Iterable</code> 接口，使其可以作为 <code>forEach</code> 循环语句的执行对象。根据集合是否可包含重复对象，是否有序，<code>Collection</code> 由 <code>List</code>，<code>Queue</code> 和 <code>Set</code> 更具体化。其中，<code>Set</code> 不可以包含重复对象，且不保证元素返回按照预期任何顺序。<code>List</code> 包含一系列对象，不同于 <code>Set</code>，它能够包含重复对象且维持对象添加的顺序。<code>Queue</code> 是维持 FIFO（first-in-first-out, 先进先出）关系的一组对象，同样可以包含重复对象。</p>
<h3 id="1-1-Collection-接口"><a href="#1-1-Collection-接口" class="headerlink" title="1.1 Collection 接口"></a>1.1 Collection 接口</h3><p>Java 平台没有提供 <code>Collection</code> 接口的任何直接实现。该接口主要定义了操作集合中对象的基本方法，如告诉你集合中是否存在元素或存在多少元素的方法（<code>isEmpty</code>, <code>size</code>），检查给定元素是否存在于集合中的方法（<code>contains</code>），添加或删除一个元素的方法（<code>add</code>, <code>remove</code>），提供该集合元素的迭代器（iterator）（<code>iterator</code>）。</p>
<p>此外，<code>Collection</code> 还有作用于整体集合本身和集合之间的操作——<code>containsAll</code>，<code>addAll</code>，<code>removeAll</code>， <code>retainAll</code>，<code>clear</code>。<code>toArray</code> 方法主要是应对某些依赖数组类型作为输入的老旧 APIs。自 java 1.8 开始，该接口引入了 <code>stream</code> 和 <code>parallelStream</code> 方法来为 Stream 流提供支持，并结合 Lambda 和 <strong>Functional Interface</strong> 再添加了一个 <code>removeIf</code> 方法。</p>
<h4 id="1-1-1-Iterator-接口"><a href="#1-1-1-Iterator-接口" class="headerlink" title="1.1.1 Iterator 接口"></a>1.1.1 Iterator 接口</h4><p>我们已经知道 <code>Collection</code> 继承了 <code>Iterable</code> 接口，需要实现 <code>iterator</code> 方法返回一个迭代遍历集合元素的迭代器对象。Java 集合框架中的枚举（Enumeration）操作由迭代器代替。迭代器允许我们在遍历集合元素时仍能删除集合中的元素。集合类中 <code>Iterator</code> 使用迭代器设计模式实现。</p>
<h4 id="1-1-2-List-接口"><a href="#1-1-2-List-接口" class="headerlink" title="1.1.2 List 接口"></a>1.1.2 List 接口</h4><p>列表（Lists）表示一组有序元素。通过 Lists，我们用元素在集合中的索引位置来访问该元素，取决于具体类是否实现 <code>RandomAccess</code> 接口，一般地，实现该接口则表示集合的底层实现使用数组，使用<code>for-loop</code> 时，利用 <code>get()</code> 要比用 <code>iterator</code> 方法更快。</p>
<p>相比于 <code>Collection</code>，它增加了访问元素的方法（<code>get</code>, <code>indexOf</code>, <code>lastIndexOf</code>），替换某个位置元素的 <code>set</code> 方法，还增加了 <code>listIterator</code> 和 <code>subList</code> 方法，此外，自 java 1.8 起，又结合 Lambda 和函数式接口，添加了 <code>replaceAll</code>，可以将集合中的每一个元素替换成应用某一一元运算之后的结果，如 <code>list.replaceAll(x -&gt; x++);</code> 等。</p>
<p>我们常用的 <code>List</code> 接口具体实现类有——<code>ArrayList</code>, <code>CopyOnWriteArrayList</code>, <code>LinkedList</code>, <code>Vector</code>, <code>Stack</code>。</p>
<h4 id="1-1-3-ListIterator-接口"><a href="#1-1-3-ListIterator-接口" class="headerlink" title="1.1.3 ListIterator 接口"></a>1.1.3 ListIterator 接口</h4><p><code>ListIterator</code> 接口继承了 <code>Iterator</code> 接口，不同的是，它允许开发人员以任一方向（向前或向后）来遍历列表中的元素，同样支持在遍历列表时对列表进行修改，并支持获取下一个待访问元素的索引。相比于 <code>Iterator</code> 接口，它增加了 <code>hasPrevious</code> 和 <code>previous</code> 方法来判断并获取前一个元素。</p>
<p>需要提出的是，在 Java 集合框架中，该接口主要由 <code>List</code> 接口继承。</p>
<h4 id="1-1-4-Set-接口"><a href="#1-1-4-Set-接口" class="headerlink" title="1.1.4 Set 接口"></a>1.1.4 Set 接口</h4><p>Sets 表示一组不重复的对象。它无法保证返回元素按照任何预期顺序，但也有一些 <code>Set</code> 的实现以自然顺序存储元素并维持该顺序。<code>Set</code> 接口不支持随机访问，因此我需要通过迭代器或 <code>forEach</code> 方法来遍历集合中的元素。</p>
<p>常用的 <code>Set</code> 接口具体实现类有——<code>HashSet</code>, <code>TreeSet</code>, <code>EnumSet</code>, <code>LinkedHashSet</code>, <code>ConcurrentSkipListSet</code>, <code>CopyOnWriteArraySet</code>。</p>
<h4 id="1-1-5-SortedSet-和-NavigatableSet-接口"><a href="#1-1-5-SortedSet-和-NavigatableSet-接口" class="headerlink" title="1.1.5 SortedSet 和 NavigatableSet 接口"></a>1.1.5 SortedSet 和 NavigatableSet 接口</h4><p>从图1.1 的层次结构图可以看出，这些接口是为 <code>Set</code> 添加扩展。<code>SortedSet</code> 保证了 Set 中的元素是已排序的，而 <code>NavigatablSet</code> 接口确保了我们可以在已排序的 Set 中进行导航，提供可以检索比给定元素值大的下一个或上一个元素。当前主要是 <code>TreeSet</code> 实现了这两个接口。</p>
<h4 id="1-1-6-Queue-接口"><a href="#1-1-6-Queue-接口" class="headerlink" title="1.1.6 Queue 接口"></a>1.1.6 Queue 接口</h4><p><code>Queue</code> 表示一种经典的数据结构——队列。除了拥有基本的集合操作以外，<code>Queue</code> 增加了队列的一些专属操作，进队、出队等。队列中的元素通常但不一定是 FIFO 的。<code>PriorityQueue</code> 是一个例外，它通过维持一个堆来实现的，因此，它存放元素的顺序可能是一个大顶堆或者小顶堆的方式。</p>
<p>通常情况下，队列不支持阻塞的插入和检索操作。需要使用相应实现 <code>BlockingQueue</code> 接口的阻塞队列实现类。</p>
<p>常用的 <code>Queue</code> 接口具体实现类有——<code>LinkedList</code>, <code>ArrayDeque</code>, <code>PriorityQueue</code>, <code>ArrayBlockingQueue</code>, <code>ConcurrentLinkedDeque</code>, <code>ConcurrentLinkedQueue</code>, <code>DelayQueue</code>, <code>LinkedBlockingDeque</code>, <code>LinkedBlockingQueue</code>, <code>LinkedTransferQueue</code>, <code>PriorityBlockingQueue</code>, <code>SynchronousQueue</code>。</p>
<h4 id="1-1-7-Deque-接口"><a href="#1-1-7-Deque-接口" class="headerlink" title="1.1.7 Deque 接口"></a>1.1.7 Deque 接口</h4><p><code>Deque</code> 是一种支持在两端插入和移除元素的双端队列（发音为 <strong>deck</strong>）。它即可以被当作一个 <code>Queue</code> 来使用（FIFO, first-in-first-out），也可以当作一个 <code>Stack</code> 使用（LIFO, last-in-first-out）。</p>
<p>该接口代替 <code>Stack</code> 作为一个栈来使用，因为 <code>Stack</code> 继承于 <code>Vector</code> 类，它的方法均使用 <code>synchronized</code> 关键字修饰进行同步，不考虑多线程情况下，使用它性能不佳。</p>
<p>实现 <code>Deque</code> 接口的常用类——<code>ArrayDeque</code>, <code>ConcurrentLinkedDeque</code>, <code>LinkedBlockingDeque</code> 和 <code>LinkedList</code>。</p>
<h3 id="1-2-Map-接口"><a href="#1-2-Map-接口" class="headerlink" title="1.2 Map 接口"></a>1.2 Map 接口</h3><p><code>Map</code> 接口定义用于存储键-值对（key-value pairs）数据对象的集合（其中键要是不可变的，immutable）。<code>Map</code> 接口的层次结构见图 1.2。一个 Map 不能包含重复的 key，每一个 key 唯一定对应一个 value。一个 Map 的基本操作有 <code>put</code>, <code>get</code>, <code>containsKey</code>, <code>containsValue</code>, <code>size</code> 以及 <code>isEmtpy</code>。</p>
<p>Map 实际上提供了三种集合视图，我们可以把一个 Map 看作是一个由键组成的集合、一个由值组成的集合以及一个由键-值对映射组成的集合。在 Map 的具体实现类中，有的会维持元素的顺序，如 <code>TreeMap</code>，而有的则不会，如 <code>HashMap</code>。</p>
<p><code>Map</code> 接口常用的实现类有——<code>HashMap</code>, <code>EnumMap</code>, <code>HashTable</code>, <code>IdentityHashMap</code>, <code>LinkedHashMap</code>, <code>Properties</code>, <code>TreeMap</code>, <code>WeakHashMap</code>, <code>ConcurrentHashMap</code>, <code>ConcurrentSkipListMap</code>。</p>
<div align="center" style="display: flex; flex-direction:column;">
    <img data-src='maps.png'/>
    <span style="padding-top:1em;">图 1.2 Map 接口层次结构</span>
</div>

<h4 id="1-2-1-SortedMap-和-NavigatableMap-接口"><a href="#1-2-1-SortedMap-和-NavigatableMap-接口" class="headerlink" title="1.2.1 SortedMap 和 NavigatableMap 接口"></a>1.2.1 SortedMap 和 NavigatableMap 接口</h4><p>与之前的 <code>SortedSet</code> 和 <code>NavigatableSet</code> 接口类似，它们为 <code>Map</code> 接口增加了类似的行为。主要是 <code>LinkedHashMap</code> 实现了这两个接口。之所以，<code>Set</code> 和 <code>Map</code> 的实现有许多类似的地方，是因为 <code>Set</code> 具体类的实现使用 <code>Map</code> 的具体类作为支持。</p>
<h2 id="2-小节"><a href="#2-小节" class="headerlink" title="2. 小节"></a>2. 小节</h2><p>本文主要简单介绍了 Java 集合框架的结构，了解其中接口和具体实现类的关系。通过这些了解，我们可以对 Java 的集合框架有了一个初步的了解。接下来，我们还进一步地去了解常用具体实现类的一些细节，以及我们在开发时遇到实际问题时，应该优先使用那些具体类的问题。此外，还需要对 <code>java.util</code> 包下提供的两个工具类 <code>Collections</code> 和 <code>Arrays</code> 进行了解，它们分别提供了操作集合和数组的一些非常有用的方法，例如 <code>sort</code>, <code>shuffle</code>, <code>reverse</code> <code>search</code>, <code>min</code>, <code>max</code> 等。此外，<code>Collections</code> 提供了许多操纵集合的方法，能够对给定集合进行封装，比如将给定集合转换成同步集合、不可修改集合等。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Basic</tag>
        <tag>Collections</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK, JRE, JVM | 深入了解</title>
    <url>/posts/12448424/</url>
    <content><![CDATA[<p>了解<strong>JDK, JRE, JVM之间的区别</strong>，<strong>JVM</strong>是如何工作的？什么是<strong>类加载器</strong>(<em>class loaders</em>), <strong>解释器</strong>(<em>interpreter</em>)和<strong>及时编译器</strong>(<em>JIT compilers</em>)</p>
<span id="more"></span>
<h2 id="1-Java程序的执行"><a href="#1-Java程序的执行" class="headerlink" title="1. Java程序的执行"></a>1. Java程序的执行</h2><p>在开始之前，让我们快速的回顾一下一个<em>Java</em>程序是如何执行的</p>
<ol>
<li>使用一个编辑器或者IDE(<strong>integrated development enviroment</strong>, 如<em>Eclipse</em>或<em>Intellij Idea</em>)编写<em>Java</em>源代码，假设是<code>Simple.java</code>文件；</li>
<li>程序需要编译成字节码(<em>bytecode</em>)。使用<em>Java</em>编译器(<code>javac</code>)将源代码文件编译成<code>Simple.class</code>文件；</li>
<li>在任意平台(e.g.<em>Mac, Windows, Linux</em>)上的<em>JVM</em>(<strong>java virtual machine</strong>)执行<code>.class</code>文件；</li>
<li><em>JVM</em>将字节码翻译成本机机器码(<em>native machine code</em>), 能够让本机执行。</li>
</ol>
<p><img data-src="Java-Execution-Flow.png" alt="java-execution-flow"></p>
<h2 id="2-什么是JVM"><a href="#2-什么是JVM" class="headerlink" title="2. 什么是JVM ?"></a>2. 什么是JVM ?</h2><p><strong>Java virtual machine</strong>(JVM) 是用于运行字节码的虚拟机。我们通过将<em>Java</em>源代码文件编译成<code>.class</code>字节码文件，之后由<em>JVM</em>执行。这也是为什么<em>Java</em>具有<strong>WORA(Write Once Run Anywhere)</strong>特性的原因。</p>
<p>在现实世界中，<em>JVM</em>是一种规范(<em>specification</em>)，它提供一种使<em>Java</em>字节码能够执行的运行环境(<em>runtime environment</em>)。不同的供应商这个规范的不同实现，例如：这个<em>wiki</em>页面列出的就是<a href="https://en.wikipedia.org/wiki/List_of_Java_virtual_machines">JVM的不同实现</a>。</p>
<p>最流行的<em>JVM</em>实现是由<em>Oracle Corporation</em>拥有和提供的<a href="https://www.oracle.com/technetwork/java/javase/tech/index-jsp-136373.html">Hotspot</a>。</p>
<p><em>JVM</em>使用了许多的先进技术为<em>Java</em>应用程序提供最佳性能，包括先进的内存模型(<em>memory model</em>)，<strong>垃圾收集器</strong>(<em>garbage collector</em>)和<strong>自适应优化器</strong>(<em>adaptive optimizer</em>)。</p>
<p><em>JVM</em>提供两种不同的版本 - 客户端(<code>-client</code>)和服务器(<code>-server</code>)。尽管它们很类似，但是服务器版本<em>JVM</em>经过专门调整，能够最大限度地提高运行速度峰值，它适用于在服务器上长期执行的应用程序，这些应用需要的是尽可能快的运行速度，而不是快速启动或较小的运行时内存占用。开发者可以指定<code>-client</code>或者<code>-server</code>来选择想要的<em>JVM</em>。</p>
<p><em>JVM</em>之所以说是虚拟(<strong>virtual</strong>)的, 是因为它提供的机器接口(<em>machine interface</em>)不依赖于底层的操作系统以及机器的硬件架构。</p>
<h3 id="2-1-JVM-架构"><a href="#2-1-JVM-架构" class="headerlink" title="2.1 JVM 架构"></a>2.1 JVM 架构</h3><p><em>JVM</em>可以分成三个主要的子系统(<em>subsystem</em>):</p>
<ol>
<li>类加载子系统(<strong>Class Loader Subsystem</strong>)</li>
<li>运行数据区(内存区)(<strong>Runtime Data Area</strong> or <strong>Memory Area</strong>)</li>
<li>执行引擎(<strong>Execution Engine</strong>)</li>
</ol>
<p><img data-src="JVM-Architecture.png" alt="JVM-Architecture"></p>
<h4 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h4><p>类加载子系统用于加载类文件(<em>class file</em>)。它的主要功能为: <strong>加载</strong>(<strong>loading</strong>)、<strong>链接</strong>(<strong>linking</strong>)、<strong>初始化</strong>(<strong>initialization</strong>)。</p>
<h5 id="1-加载-loading"><a href="#1-加载-loading" class="headerlink" title="1.加载(loading)"></a>1.加载(<em>loading</em>)</h5><ul>
<li>为了加载类文件，<em>JVM</em>提供了三种类加载器: <strong>Bootstrap</strong>, <strong>extension</strong> 和 <strong>application</strong> 类加载器;</li>
<li>当加载一个类文件时，<em>JVM</em>需要找出该类的依赖；</li>
<li>首先，<em>bootstrap</em>类加载器会在<code>$JAVA_HOME/jre/lib</code>目录下的<code>rt.jar</code>包中查找；</li>
<li>若有类文件未找到，<em>extension</em>类加载器会在<code>$JAVA_HOME/jre/lib/ext</code>目录下的类文件；</li>
<li>若仍有类文件未找到，<em>application</em>类加载器会搜索查找<code>CLASSPATH</code>环境变量下的所有类文件和<em>jar</em>包文件；</li>
<li>通过这些类加载找到的类文件会被加载，找不到的类文件则会抛出<code>ClassNotFoundException</code>异常。</li>
</ul>
<p>Java<strong>中类加载器的加载采用了双亲委托机制</strong>(<strong>Delegation-Hierarchy principle</strong>)。</p>
<p>当一个类加载接收到加载类的请求时，首先会将加载任务委托给上一级类加载器，依次递归，直到最后的<code>Bootstrap ClassLoader</code>，若<code>Boostrap ClassLoader</code>找不到时，则会将加载请求委托给下一级的类加载器，依次递归，直到最后的<code>Application ClassLoader</code>，在此过程中，若类被找到则直接返回，找不到则最终会抛出一个<code>java.lang.ClassNotFoundException</code>的运行时异常。</p>
<p><img data-src="jvmclassloader.jpg" alt=""></p>
<p>使用这种机制的好处非常好理解，目的就是为了<strong>避免重复加载已有的类，提高效率</strong>，还有就是强制从最高一级开始逐级搜索类文件，<strong>确保核心基础类优先加载</strong>。</p>
<div class="note primary"><p>JVM触发类加载器去加载外部类的情况:</p>
<ul>
<li>显示字节码指令集(<code>new/getstatic/putstatic/invokestatic</code>): 对应的场景是创建对象或者调用到类文件的静态变量/静态方法/静态代码块；</li>
<li>反射: 通过对象反射获取类对象时；</li>
<li>继承: 创建子类触发父类加载；</li>
<li>入口: 包含<code>main</code>方法的类首先加被加载。</li>
</ul>
</div>
<h5 id="2-链接-linking"><a href="#2-链接-linking" class="headerlink" title="2. 链接(linking)"></a>2. 链接(<em>linking</em>)</h5><p>此过程分为三个阶段:</p>
<ol>
<li><strong>验证阶段</strong>(<strong>Verify</strong>): 字节码验证器(<strong>Bytecode verifier</strong>)会验证生成的字节码是否正确，验证不通过则会抛出验证；<blockquote>
<p>验证阶段对于虚拟机的类加载机制来说，是一个非常重要但不一定是必要的阶段。如果所运行的全部代码都已经被反复使用和验证过，在实施阶段就可以考虑使用<code>-Xverify:none</code>参数来关闭大部分的类验证措施，从而缩短虚拟机类加载的时间。</p>
</blockquote>
</li>
<li><strong>准备阶段</strong>(<strong>Prepare</strong>): 为类中的静态变量(<em>static variables</em>)<strong>分配内存空间</strong>, 但还未初始化，也就是<code>0</code>或者<code>null</code>；</li>
<li><strong>解析阶段</strong>(<strong>Resolve</strong>): 将方法区(<strong>Method Area</strong>)的所有符号引用(<strong>symbolic memory references</strong>)全部替换为直接引用(<strong>Direct Reference</strong>)<div class="note primary"><p><strong>符号引用</strong>(<em>Symbolic Reference</em>): 符号引用以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经在内存中。<br><strong>直接引用</strong>(<em>Direct Reference</em>): 直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用与虚拟机实现的内存布局相关，同一符号引用在不同的虚拟机上翻译出来的直接引用一般都不相同，如果有了直接引用，那引用的目标必定已经在内存中存在。</p>
</div>
</li>
</ol>
<h5 id="3-初始化-Initialization"><a href="#3-初始化-Initialization" class="headerlink" title="3. 初始化(Initialization)"></a>3. 初始化(<em>Initialization</em>)</h5><p>作为类加载过程的最后一个阶段，它为所有的静态变量赋初值，并执行静态代码块(<em>static blocks</em>)。</p>
<h4 id="JVM内存区域"><a href="#JVM内存区域" class="headerlink" title="JVM内存区域"></a>JVM内存区域</h4><p>在一个<em>Java</em>程序执行时，<em>JVM</em>为它定了许多<strong>运行时数据区</strong>(<strong>runtime data areas</strong>)。 其中一些数据区在<em>JVM</em>启动的时候创建，并在<em>JVM</em>退出的时才会销毁(<em>Destroy</em>)。其余的数据区是每个线程(<em>Thread</em>)各自都有的，在线程创建的时候创建，线程退出的时候销毁。</p>
<blockquote>
<p>在上面给出的<em>JVM</em>架构图就可以看到, 方法区(<em>Method Area</em>)、堆区(<em>Heap Area</em>)、本地方法区(Native Method Area)是随JVM启动而创建的(一个JVM只能有一个)； 栈区(Stack Area)和程序计数寄存器(PC Registers)是每个线程都有的，随线程创建而创建，销毁而销毁。</p>
</blockquote>
<ol>
<li><strong>方法区域</strong>(<em>Method Area</em>): 方法区存放类的结构数据，如运行常量池(<strong>runtime constant pool</strong>), 字段和方法数据，方法的代码，方法也包括类(<em>class</em>)、实例(<em>instance</em>)和接口初始化(<em>interface initialization</em>)的方法。<br><br>方法区在逻辑上实际是堆(<em>heap</em>)的一部分，但是不能被垃圾收集器收集，尽管垃圾收集在堆上是强制执行的。方法区的大小可以是固定的，或者可以根据需求进行扩展或缩小，且并不要求方法区的内存是连续的。<div class="note warning"><p>如果方法区的内存无法满足分配请求，<em>JVM</em>会抛出一个<code>OutOfMemoryError</code>。</p>
</div></li>
<li><strong>堆区域</strong>(<em>Heap Area</em>): 存放程序执行创建的所有对象，堆中存放的对象会有<strong>Garbage Collection</strong>来管理回收，堆的大小可以是固定，也可以动态大小的(取决系统的配置)，并且为堆分配的内存不需要是连续的。<div class="note warning"><p>如果自动存储管理系统(<strong>automatic storage management system</strong>)管理的堆内存空间无法满足分配需求，<em>JVM</em>会抛出一个<code>OutOfMemoryError</code>。<br>因为多个线程(<em>multiple threads</em>)共享方法区域和堆区域，所以数据的存储不是线程安全(<em>thread-safe</em>)的。</p>
</div></li>
<li><strong>栈区域</strong>(<em>Stack Area</em>): 每个线程均有一个独立的栈。对于每个方法的调用，都会在栈中创建一个条目(<em>entry</em>), 称为<strong>栈帧</strong>(<em>Stack Frame</em>); 所有的局部变量(local variables or thread-local variables)也会在栈内存中创建。<strong>栈区域是线程安全的，因为它不是共享资源</strong>。栈帧可以分为三种子实体(<em>subentities</em>):<ul>
<li>局部变量数组(<em>Local Variable Array</em>): 与方法相关的局部变量，它们相应的值将存放在这里；</li>
<li>操作数栈(<em>Operand stack</em>): 如果需要执行任何中间操作时，操作数栈充当执行操作的运行时工作区(<em>runtime workspace</em>)；</li>
<li>帧数据(<em>Frame data</em>): 对应方法的所有符号(<em>Symbols</em>)均存放在这里。在任何异常的情况下，捕获的块信息将保留在帧数据中。<div class="note warning"><ol>
<li>如果线程执行过程中，对栈区域的内存需求无法得到满足, JVM会抛出一个<code>StackOverflowError</code>异常；</li>
<li>若栈区域内存允许动态扩展，如果内存不足以实现扩展，或者当内存无法满足新创建线程的需求时，JVM会抛出一个<code>OutOfMemoryError</code>异常。</li>
</ol>
</div></li>
</ul>
</li>
<li><strong>程序计数器</strong>(<em>PC Registers</em>): 存放当前执行语句的物理内存地址，每个线程都有一个独立的程序计数器。</li>
<li><strong>本地方法栈</strong>(<em>Native Method stacks</em>): 存放本地方法(<em>native method</em>),信息，每个线程创建时，对应的本地方法栈也会创建。<div class="note warning"><ol>
<li>当本地方法栈无法满足一个线程执行时的需求时，JVM 会抛出一个<code>StackOverflowError</code>异常；</li>
<li>本地方法栈的大小可以是固定也可以是动态的，当扩展本地方法栈时或者为一个新的线程创建一个初始化的本地方法栈时，若内存需求无法得到满足，JVM会抛出<code>OutOfMemoryError</code>异常。</li>
</ol>
</div>
</li>
</ol>
<h4 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h4><p>存放到<strong>JVM内存区(Memory Area)或运行数据区(Runtime Data Area)</strong>中的字节码将由<strong>执行引擎</strong>(<em>Execution Engine</em>)执行。它使用两个内建的<strong>解释器</strong>(<em>inbuilt interpreter</em>)和一个<strong>及时编译器</strong>(<em>JIT compiler</em>)来将字节码转换成机器码，并执行。</p>
<p><img data-src="OS-Specific-Interpreters.png" alt=""></p>
<blockquote>
<p>不同平台有不同的解释器</p>
</blockquote>
<p>在<em>JVM</em>中，解释器和编译器都生成本地代码(<em>native code</em>),但它们生成代码的方式不同，代码优化也不同。</p>
<ol>
<li><strong>解释器</strong>(<em>Interpreter</em>):<br>JVM解释器根据预先定义好的<strong>JVM指令到机器指令的映射</strong>，将每一条字节码指令都转换成对应的本地指令(<em>native instruction</em>)。并且在没有对代码进行任何优化的情况下，直接执行。<div class="note primary"><p>解释器解释代码速度快；但是执行慢(代码未优化)，且对于重复的方法调用，每次都需要重新做解释再执行。</p>
</div></li>
<li><strong>JIT 编译器</strong>(<em>JIT compiler</em>):<br>为了提高性能，JIT 编译器会将合适的字节码序列(如上面提到的重复方法调用代码，以及其他的重复代码)编译成本地机器码，这些本地机器码可以被重复使用，以此来提高系统的性能。<br>JIT编译器由四个部分组成:<ul>
<li>中间代码生成器(<em>Intermediate Code Generator</em>): 用于生成中间代码；</li>
<li>代码优化器(<em>Code Optimizer</em>): 用于优化上面生成的中间代码；</li>
<li>目标代码生成器(<em>Target Code Generator</em>): 生成本地机器码；</li>
<li>配置器(<em>Profiler</em>): 一个特殊的部分，用于查找<em>hotspot</em>中的方法是否多次执行。</li>
</ul>
</li>
<li><strong>垃圾收集器</strong>(<em>Garbage Collector</em>): 收集和清除那些不可达对象(<em>unreferenced objects or dead objects</em>)。</li>
</ol>
<div class="note primary"><p><strong>[补充:]</strong></p>
<ol>
<li><strong>解释执行</strong>: 将高级语言编写的代码一条一条读取，解释成等价的低级语言代码并在对应的低级虚拟机上执行，在读取解释下一条代码，直到全部代码解释执行完毕。</li>
<li><strong>编译执行</strong>: 将所有的由高级语言编写的程序进行编译(转换成能够实现等价功能的低级语言程序)，并在低级虚拟机上执行。</li>
<li><strong>(JIT, Just-in-time)及时编译</strong>: 结合解释执行和编译执行的特点，它编译一部分代码，执行，再继续编译执行(不是一次性编译)。</li>
</ol>
<p>计算机体系结构中将计算机系统按功能划分层次结构:</p>
<blockquote>
<p>第6级(虚拟机) -&gt; 应用语言机器<br>第5级(虚拟机) -&gt; 高级语言机器<br>第4级(虚拟机) -&gt; 汇编语言机器<br>第3级(虚拟机) -&gt; 操作系统机器<br>第2级(物理机) -&gt; 传统机器语言机器<br>第1级(物理机) -&gt; 微程序机器</p>
<ol>
<li>翻译(<em>Translation</em>): 先用转换程序把高一级机器上的程序转换为低一级机器上的等效程序，然后再在该低级机器上运行，实现程序的功能。</li>
<li>解释(<em>Interpretation</em>): 是对于高一级机器上的程序的<strong>每一条语句或指令</strong>，都转成去执行低一级机器的<strong>一段等效程序</strong>. 执行完之后，再去高一级机器取下一条语句或指令，再进行解释执行，如此反复，知道解释执行完整个程序。<br><strong>在6级层次中，一般下面三层是用解释实现的，而上面三层是经常使用翻译的方式。</strong></li>
</ol>
</blockquote>
</div>
<h4 id="Java-Native-Interface-JNI"><a href="#Java-Native-Interface-JNI" class="headerlink" title="Java Native Interface(JNI)"></a>Java Native Interface(JNI)</h4><p>JNI处理本地方法库文件(<em>Native Method Libraries</em>)，为执行引擎提供需要的本地方法库文件。</p>
<h4 id="Native-Method-Libraries"><a href="#Native-Method-Libraries" class="headerlink" title="Native Method Libraries"></a>Native Method Libraries</h4><p>存放执行引擎需要用到的本地方法库文件的一个集合。</p>
<h2 id="3-什么是JRE"><a href="#3-什么是JRE" class="headerlink" title="3. 什么是JRE ?"></a>3. 什么是JRE ?</h2><p>JRE(<em>Java Runtime Environment</em>, Java运行环境)一个包含一些库文件(jar包)、用Java编写的用于运行程序的组件和Java虚拟机的软件包。</p>
<p>为了运行任何Java程序，我们至少需要在我们的机器上安装<em>JRE</em>。</p>
<p><em>JRE</em>绑定以下组件:</p>
<ol>
<li>Java HotSpot 客户端虚拟机需要用到的<em>DLL</em>动态链接库文件;</li>
<li>Java HotSpot 服务端虚拟机需要用的<em>DLL</em>动态链接库文件;</li>
<li>Java 运行环境用到的<strong>代码库文件</strong>(<em>Code libiraries</em>)、<strong>属性设置</strong>(<em>property settings</em>)以及<strong>资源文件</strong>(<em>resource files</em>)，例如: <code>rt.jar</code>和<code>charset.jar</code>;</li>
<li>Java 扩展文件，例如: <code>localedata.jar</code>。</li>
</ol>
<p>以及其他的安全管理用到的文件，<strong>applets</strong>使用的<em>jar</em>包等。</p>
<p>不同系统平台、64位和32位的系统拥有不同的JRE。</p>
<h2 id="4-什么是JDK"><a href="#4-什么是JDK" class="headerlink" title="4. 什么是JDK ?"></a>4. 什么是JDK ?</h2><p>JDK(<em>Java Development Kit</em>, Java 开发工具)，它包含<em>JRE</em>, 同时包含用于开发Java程序的工具。</p>
<p>下面列出的是<em>JDK</em>包含的一些重要的开发工具:</p>
<ul>
<li><strong>appletviewer</strong>: 用于运行和调试Java applet 程序，不需要Web浏览器；</li>
<li><strong>apt</strong>: 注解处理工具(<em>The annotation-processing-tool</em>)；</li>
<li><strong>extchecker</strong>: 检测jar包冲突的工具；</li>
<li><strong>javadoc</strong>: 文档生成工具，可以根据源代码编写的注释自动生成文档；</li>
<li><strong>jar</strong>: 打包工具，用于将相关的类库打包成一个jar包文件，也可以用于管理jar包；</li>
<li><strong>jarsigner</strong>: jar包签名和验证工具；</li>
<li><strong>javap</strong>: class 类文件反编译器(<em>class file disassembler</em>)；</li>
<li><strong>javaws</strong>: JNLP程序 Java Web 启动器；</li>
<li><strong>JConsole</strong>: Java 监视和管理console；</li>
<li><strong>jhat</strong>: Java 堆分析工具；</li>
<li><strong>jrunscript</strong>: Java 命令行脚本 shell；</li>
<li><strong>jstack</strong>: 用于打印Java线程栈踪迹的工具；</li>
<li><strong>keytool</strong>: 操作keystore的工具；</li>
<li><strong>policytool</strong>: 策略(policy)修改和管理工具；</li>
<li><strong>xjc</strong>: Java API 的一部分，JAXB(XML Binding API), 接受XML模式(<em>schema</em>)并生成Java类。</li>
</ul>
<p>和<em>JRE</em>一样，<em>JDK</em>也是平台独立的，需要为不同的机器下载不同的<em>JDK</em>。</p>
<h2 id="5-JDK-JRE-JVM之间的区别"><a href="#5-JDK-JRE-JVM之间的区别" class="headerlink" title="5. JDK, JRE, JVM之间的区别"></a>5. JDK, JRE, JVM之间的区别</h2><p>基于上面的讨论，我们可以简单下面一个图来展示它们的关系:</p>
<blockquote>
<p>JRE = JVM + libraries to run Java application.<br>JDK = JRE + tools to develop Java application.</p>
</blockquote>
<p><img data-src="JDK-JRE-JVM.png" alt=""></p>
<p>简单来说，Java开发人员需要在机器上安装<em>JDK</em>来开发Java程序；如果我们只需要能够运行Java程序，则只在机器上安装<em>JRE</em>即可。</p>
<p><em>References</em></p>
<ol>
<li><em>How JVM Works - JVM Architecture? GeeksforGeeks. October 2016</em>. <a href="https://www.geeksforgeeks.org/jvm-works-jvm-architecture/">https://www.geeksforgeeks.org/jvm-works-jvm-architecture/</a>.</li>
<li><em>java - What is the difference between JVM, JDK, JRE &amp; OpenJDK? Stack Overflow</em>. <a href="https://stackoverflow.com/questions/11547458/what-is-the-difference-between-jvm-jdk-jre-openjdk">https://stackoverflow.com/questions/11547458/what-is-the-difference-between-jvm-jdk-jre-openjdk</a>.</li>
<li><em>The JVM Architecture Explained - DZone Java</em>. <a href="https://dzone.com/articles/jvm-architecture-explained">https://dzone.com/articles/jvm-architecture-explained</a>.</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>JRE</tag>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 封装类内部缓存</title>
    <url>/posts/1017901c/</url>
    <content><![CDATA[<p>在 Java 中通过 <code>new</code> 关键字等其他方式在堆（heap）上创建对象是一个比较耗费资源的操作。 Java 在封装类（Wrapper classes）上使用内部缓存来使封装类的某些常用值使用更高效。</p>
<p>与 <code>String</code> 类一样，Java 中的封装类都是不可变的（immutable）。Java 中的封装类与 String 类一样同样提供了类似的缓存池机制。这其实也是一个普遍的操作，对于较昂贵的资源创建操作，使用缓存来处理在其他地方也非常常见，如数据库连接池、线程池等。</p>
<span id="more"></span>
<h2 id="Integer-内部缓存"><a href="#Integer-内部缓存" class="headerlink" title="Integer 内部缓存"></a>Integer 内部缓存</h2><p>在 <code>Integer</code> 类中存在一个内部类 <code>IntegerCache</code>，使用一个 <code>Integer[]</code> 数组来维持一组 <code>Integer</code> 实例，当我们使用以下语句时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="number">10</span>; <span class="comment">// 或者</span></span><br><span class="line">Integer i = Integer.valueOf(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p><code>i</code> 将存储一个指向已经缓存的 <code>Integer</code> 实例的引用。如果使用 <code>new Integer(10)</code>，则会在堆上创建一个新的实例，而不是使用已缓存的实例。实际上，这一机制只有在使用 <code>Integer.valueOf()</code> 才起作用，本质上使用字面量的赋值最终也是通过调用 <code>Integer.valueOf()</code> 来实现的。在 Java 执行自动装箱（autoboxing）也是类似的。</p>
<p><code>IntegerCache</code> 类非常简单，我们可以看一下（jdk 1.8）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cache to support the object identity semantics of autoboxing for values between</span></span><br><span class="line"><span class="comment"> * -128 and 127 (inclusive) as required by JLS.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The cache is initialized on first usage.  The size of the cache</span></span><br><span class="line"><span class="comment"> * may be controlled by the &#123;<span class="doctag">@code</span> -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option.</span></span><br><span class="line"><span class="comment"> * During VM initialization, java.lang.Integer.IntegerCache.high property</span></span><br><span class="line"><span class="comment"> * may be set and saved in the private system properties in the</span></span><br><span class="line"><span class="comment"> * sun.misc.VM class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Integer.valueOf()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns an &#123;<span class="doctag">@code</span> Integer&#125; instance representing the specified</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> int&#125; value.  If a new &#123;<span class="doctag">@code</span> Integer&#125; instance is not</span></span><br><span class="line"><span class="comment"> * required, this method should generally be used in preference to</span></span><br><span class="line"><span class="comment"> * the constructor &#123;<span class="doctag">@link</span> #Integer(int)&#125;, as this method is likely</span></span><br><span class="line"><span class="comment"> * to yield significantly better space and time performance by</span></span><br><span class="line"><span class="comment"> * caching frequently requested values.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This method will always cache values in the range -128 to 127,</span></span><br><span class="line"><span class="comment"> * inclusive, and may cache other values outside of this range.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  i an &#123;<span class="doctag">@code</span> int&#125; value.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an &#123;<span class="doctag">@code</span> Integer&#125; instance representing &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>  1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>IntegerCache</code> 是一个静态内部类，因此，只有我们调用 <code>Integer.valueOf()</code> 方法时，该类才会加载，然后创建缓存。以便提高资源重用率。</p>
<p>下面是使用 <code>Integer</code> 内部缓存的一个简单例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCacheDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i1 = <span class="number">100</span>;</span><br><span class="line">        Integer i2 = <span class="number">100</span>;</span><br><span class="line">        Integer i3 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(i1 == i2);</span><br><span class="line">        System.out.println(i1 == i3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Output:</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p>当程序执行第一条赋值语句时，<code>IntegerCache</code> 会被加载，并创建相应的缓存池。之后 <code>i2</code> 的赋值使用的已缓存的实例。<code>i3</code> 使用 <code>new</code> 关键字来创建实例，因此，它会在堆上创建一个新的实例对象。<code>==</code> 对于作用于对象之间，比较的是对象的地址，因此，<code>i1 == i2</code> 输出  <code>true</code>， 而 <code>i1 == i3</code> 输出 <code>false</code>。</p>
<h3 id="修改缓存大小"><a href="#修改缓存大小" class="headerlink" title="修改缓存大小"></a>修改缓存大小</h3><p>从上面的 <code>IntegerCache</code> 类的实现来看，我们可以通过需求自己更改实例缓存范围的最大值，修改方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. --XX:AutoBoxCache= 1000</span><br><span class="line">2. -Djava.lang.Integer.IntegerCache.high = 1000</span><br></pre></td></tr></table></figure>
<p>通过上面的修改后，<code>Integer</code> 的缓存范围将变成 <code>-128</code> ~ <code>1000</code>。需要注意的是，当前的实现中，并没有指定 <code>IntegerCache.low</code> 的取值。</p>
<h2 id="其他封装类"><a href="#其他封装类" class="headerlink" title="其他封装类"></a>其他封装类</h2><p>通过查看 <code>Integer</code> 类的中 <code>IntegerCache</code> 的相关实现，我们了解的 <code>Integer</code> 的实例缓存方式。更多地，其他的封装类也有提供类似的机制：</p>
<ol>
<li><code>java.lang.Boolean</code> 默认存储两个实例 —— <code>TRUE</code> 和 <code>FALSE</code>；</li>
<li><code>java.lang.Short</code> 默认缓存范围为 <code>-128 ~ 127</code>；</li>
<li><code>java.lang.Byte</code> 默认缓存范围 <code>-128 ~ 127</code>；</li>
<li><code>java.lang.Long</code> 默认缓存范围为 <code>-128 ~ 127</code>;</li>
<li><code>java.lang.Character</code> 默认缓存范围为 <code>0 ~ 127</code>；</li>
</ol>
<p>需要说明的是，除了本文提到的 <code>Integer</code> 以外，其他的封装类只能使用默认的缓存范围，无法进行更改。<code>Float</code> 和 <code>Double</code> 并没有提供这样的缓存机制。不同于这些封装类，<code>String</code> 使用的是字符串池（string pool），采用不同的实现的方式。</p>
<p><code>String</code> 会为 <code>String</code> 字面量（literals）维持一个字符串池，该字符串池初始化为空，由 <code>String</code> 类维护，当字符串调用 <code>intern</code> 方法时，会将该字符串与字符串池中串使用 <code>equals</code> 方法进行比较，若返回 <code>true</code> 则直接使用字符串池中的串，返回该串的引用。若字符串池中不存在 <code>equals</code> 的串，则创建相应的串并添加到字符串池中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a canonical representation for the string object.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * A pool of strings, initially empty, is maintained privately by the</span></span><br><span class="line"><span class="comment"> * class &#123;<span class="doctag">@code</span> String&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * When the intern method is invoked, if the pool already contains a</span></span><br><span class="line"><span class="comment"> * string equal to this &#123;<span class="doctag">@code</span> String&#125; object as determined by</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@link</span> #equals(Object)&#125; method, then the string from the pool is</span></span><br><span class="line"><span class="comment"> * returned. Otherwise, this &#123;<span class="doctag">@code</span> String&#125; object is added to the</span></span><br><span class="line"><span class="comment"> * pool and a reference to this &#123;<span class="doctag">@code</span> String&#125; object is returned.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * It follows that for any two strings &#123;<span class="doctag">@code</span> s&#125; and &#123;<span class="doctag">@code</span> t&#125;,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> s.intern() == t.intern()&#125; is &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment"> * if and only if &#123;<span class="doctag">@code</span> s.equals(t)&#125; is &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * All literal strings and string-valued constant expressions are</span></span><br><span class="line"><span class="comment"> * interned. String literals are defined in section 3.10.5 of the</span></span><br><span class="line"><span class="comment"> * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  a string that has the same contents as this string, but is</span></span><br><span class="line"><span class="comment"> *          guaranteed to be from a pool of unique strings.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>更多详细相关内容见 <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.5">String literals</a>。</p>
<blockquote>
<p>references:<br><a href="https://docs.oracle.com/javase/specs/jls/se8/html/index.html">https://docs.oracle.com/javase/specs/jls/se8/html/index.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>basic</tag>
      </tags>
  </entry>
  <entry>
    <title>Advanture 1 Leetcode - 944 - Delete Columns to Make Sorted</title>
    <url>/posts/f5b699c8/</url>
    <content><![CDATA[<blockquote>
<p>给出由 N 个小写字母串组成的数组 <code>A</code>，所有小写字母串的长度都相同。<br>现在，我们可以选择任何一组删除索引，对于每个字符串，我们将删除这些索引中的所有字符。<br>举个例子，如果字符串为 <code>&quot;abcdef&quot;</code>，且删除索引是 <code>&#123;0, 2, 3&#125;</code>，那么删除之后的最终字符串为 <code>&quot;bef&quot;</code>。<br>假设我们选择了一组删除索引 <code>D</code>，在执行删除操作之后，<code>A</code> 中剩余的每一列都是有序的。<br>形式上，第 <code>c</code> 列为 <code>[A[0][c], A[1][c], ..., A[A.length-1][c]]</code><br>返回 <code>D.length</code> 的最小可能值。<br><br /></p>
<ul>
<li><a href="https://leetcode-cn.com/problems/delete-columns-to-make-sorted/">https://leetcode-cn.com/problems/delete-columns-to-make-sorted/</a>(中文)</li>
<li><a href="https://leetcode.com/problems/delete-columns-to-make-sorted/">https://leetcode.com/problems/delete-columns-to-make-sorted/</a>(en)<br><br /><br>示例 1：<br>输入：[“cba”,”daf”,”ghi”]<br>输出：1<br>示例 2：<br>输入：[“a”,”b”]<br>输出：0<br>示例 3：<br>输入：[“zyx”,”wvu”,”tsr”]<br>输出：3<br>提示：<br>1 &lt;= A.length &lt;= 100<br>1 &lt;= A[i].length &lt;= 1000</li>
</ul>
</blockquote>
<span id="more"></span>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于这种可以快速得出解题思路的题目：</p>
<div class="note primary"><p>由于每个字符串的长度一样，所以我们只需要依次比较字符串对应的每一列，<strong>判断是否满足非降序</strong>即可得到结果。</p>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDeletionSize</span><span class="params">(String[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = A[<span class="number">0</span>].length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = A.length-<span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[j].charAt(i) &gt; A[j+<span class="number">1</span>].charAt(i)) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析(Complexity Analysis)</strong>:</p>
<ul>
<li>时间复杂度(Time complexity): $O(n)$</li>
<li>空间复杂度(Space complexity): $O(1)$</li>
</ul>
<details class="note "><summary><p>waring</p>
</summary>
<p>此题目，在<code>leetcode</code>上被归类为<code>greedy</code>，但我觉的解题思路并没怎么体现贪心算法的思想。。。</p>

</details>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-greedy-easy</tag>
      </tags>
  </entry>
  <entry>
    <title>Advantrue 1 - Leetcode 11 - Container With Most Water</title>
    <url>/posts/dac7fdaa/</url>
    <content><![CDATA[<blockquote>
<p>给定 n 个非负整数 <code>a1，a2，...，an</code>，每个数代表坐标中的一个点 <code>(i, ai)</code> 。在坐标内画 <code>n</code> 条垂直线，垂直线 <code>i</code> 的两个端点分别为 <code>(i, ai)</code> 和 <code>(i, 0)</code>。找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。<br><br /></p>
<ul>
<li><a href="https://leetcode-cn.com/problems/container-with-most-water/">https://leetcode-cn.com/problems/container-with-most-water/</a>(中文)</li>
<li><a href="https://leetcode.com/problems/container-with-most-water/">https://leetcode.com/problems/container-with-most-water/</a>(en)<br><br /><br>说明：你不能倾斜容器，且 n 的值至少为 2。<br>示例:<br>输入: [1,8,6,2,5,4,8,3,7]<br>输出: 49</li>
</ul>
</blockquote>
<span id="more"></span>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于这样的题目，很明显可以快速的使用<code>brute-force</code>方式得到解法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxArea = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; height; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = (j-i) * (height[i]&gt;height[j]?height[j]:height[i]);</span><br><span class="line">                <span class="keyword">if</span> (temp &gt; maxArea)</span><br><span class="line">                    maxArea = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析(Complexity Analysis)</strong>:</p>
<ul>
<li>时间复杂度(Time complexity): $O(n^2)$</li>
<li>空间复杂度(Space complexity): $O(1)$</li>
</ul>
<div class="note primary"><p>显然使用<code>brute-force</code>解法设计的算法是正确的，但是时间复杂度是$O(n^2)$级别，因此我们需要考虑优化。<br>代码提交状况:<br>运行时间(Runtime): 269 ms<br>beats rate: 20.1%</p>
</div>
<div class="note warning"><p>其实仔细看的话，要使围成的矩形面积最大，无非就是让长和宽尽量的大，因此我们可以使用<code>Two-pointers</code>双指针的思想:<br>使用两个指针<code>i,j</code>分别指向<code>0</code>和<code>height.length-1</code>，让一开始的<code>x</code>坐标距离最大化，然后判断它们所对应的高度谁低，<br>依据较低的高度值计算面积，再将对应索引指针增<code>1</code>(对于低索引指针)或减<code>1</code>(高索引指针)。</p>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxArea = Integer.MIN_VAlUE;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="comment">// int x = j - i;</span></span><br><span class="line">            <span class="comment">// maxArea = Math.max(maxArea,Math.min(heigth[i], height[j])*x);</span></span><br><span class="line">            <span class="comment">// if (height[i] &lt; height[j]) &#123;</span></span><br><span class="line">            <span class="comment">//     i++;</span></span><br><span class="line">            <span class="comment">// &#125; else &#123;</span></span><br><span class="line">            <span class="comment">//     j--;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// 对代码进行缩减</span></span><br><span class="line">            maxArea = Math.max(maxArea, height[j]&lt;height[i]?(j-i)*height[j--]:(j-i))*height[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析(Complexity Analysis)</strong>:</p>
<ul>
<li>时间复杂度(Time complexity): $O(n)$</li>
<li>空间复杂度(Space complexity): $O(1)$</li>
</ul>
<div class="note primary"><p>使用<strong>双指针</strong>，只需要一次遍历就能得到结果。可以见得双指针是非常有效的工具，也是数组类问题中常见的解题思路: 例如，对于已经排好序的两数之和(Two sum - sorted)问题,就可以使用双指针进行解决。</p>
<p>代码提交状况:<br>运行时间(Runtime): 6 ms<br>beat rate: 65.95%</p>
</div>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-array-medium</tag>
      </tags>
  </entry>
  <entry>
    <title>Advantrue 1 - Leetcode 189 - Rotate Array</title>
    <url>/posts/885fe7d0/</url>
    <content><![CDATA[<blockquote>
<p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。<br>链接:</p>
<ol>
<li><a href="https://leetcode-cn.com/problems/rotate-array/">https://leetcode-cn.com/problems/rotate-array/</a>(中文)</li>
<li><a href="https://leetcode.com/problems/rotate-array/">https://leetcode.com/problems/rotate-array/</a>(en)</li>
</ol>
<p>示例 1:</p>
<p>输入: [1,2,3,4,5,6,7] 和 k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]<br>示例 2:</p>
<p>输入: [-1,-100,3,99] 和 k = 2<br>输出: [3,99,-1,-100]<br>解释:<br>向右旋转 1 步: [99,-1,-100,3]<br>向右旋转 2 步: [3,99,-1,-100]<br>说明:</p>
<p>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>要求使用空间复杂度为 O(1) 的原地算法。</p>
</blockquote>
<span id="more"></span>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先考虑考虑<code>brute-force</code>暴力解法，要使数组中的元素整体右移<code>k</code>位，最直接的方式是循环<code>k</code>次，每次循环让每个元素依次跟最后一个元素进行交换<code>swap</code>即可。</p>
<blockquote>
<p>例如: input : [1, 2, 3, 4], k = 1<br>      loop1: 4, 2, 3, 1 -&gt;<br>             4, 1, 3, 2 -&gt;<br>             4, 1, 2, 3</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> last = nums[nums.length-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                nums[j] = last;</span><br><span class="line">                last = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析(Compelxity Analysis):</strong></p>
<ul>
<li>时间复杂度(Time complexity): $O(kn)$</li>
<li>空间复杂度(Space complexity): $O(1)$</li>
</ul>
<p>Submission status:</p>
<blockquote>
<p>该解法通过所有测试用例，但是执行时间为<code>109 ms</code>, 击败<code>14.9%</code>的<code>java</code>代码提交。</p>
</blockquote>
<div class="note primary"><p>解题思路二:</p>
<blockquote>
<p>利用辅助数组，先将需要移动变换的元素放在移动后的位置，再将辅助数组元素移回原数组.</p>
</blockquote>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] aux = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            aux[(i+k) % nums.length] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; aux.length; i++) &#123;</span><br><span class="line">            nums[i] = aux[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析(Compelxity Analysis):</strong></p>
<ul>
<li>时间复杂度(Time complexity): $O(n)$</li>
<li>空间复杂度(Space complexity): $O(n)$</li>
</ul>
<p>Submission status:</p>
<blockquote>
<p>代码提交运行时间: <code>1 ms</code> 击败<code>53.8%</code>的<code>java</code>提交代码。</p>
</blockquote>
<div class="note primary"><p>解题思路三:</p>
<p>除了上面给出的第二种方案，还有更好的解题方法，能够做到<code>O(n)</code>运行时间，以及<code>O(1)</code>的空间复杂度.</p>
</div>
<blockquote>
<p>思路: 拿题目给定的例子来说，[1,2,3,4,5,6,7], k = 3.<br>首先将数组划分成两个部分: <code>0~nums.length-k-1</code>,即<code>[1,2,3,4]和</code>nums.length-k ~ nums.length-1],即<code>[5,6,7]</code>,把两个部分进行翻转，此时数组变成<code>[4,3,2,1,7,6,5]</code>.<br>最后，将整个数组进行翻转即可得到我们想要的结果: <code>[5,6,7,1,2,3,4]</code>.</p>
</blockquote>
<div class="note warning"><p>需要注意的是，需要对<code>k</code>进行处理，当<code>k &gt; nums.length</code>情况，会出现越界情况。<br>解决方法: 使<code>k</code>进行 <strong>mod</strong> <code>nums.length</code>运算(<code>k = k % nums.length</code>).</p>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        k %= nums.length;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length-k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, nums.length-k, nums.length-<span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析(Complexity Analysis)</strong>:</p>
<ul>
<li>时间复杂度(Time complexity): $O(n)$</li>
<li>空间复杂度(Space complexity): $O(1)$</li>
</ul>
<p>Submission status:</p>
<blockquote>
<p>代码提交运行时间: <code>0 ms</code>, 击败<code>100%</code>的<code>java</code>提交代码。</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在处理数组问题时，需要非常小心，时刻注意边界，避免发生数组越界问题。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-array-easy</tag>
      </tags>
  </entry>
  <entry>
    <title>Advanture 1 - Leetcode 561 - Array Partition I</title>
    <url>/posts/270f73f9/</url>
    <content><![CDATA[<blockquote>
<p>给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。<br /><br /><br>链接:</p>
<ol>
<li><a href="https://leetcode.com/problems/array-partition-i/">https://leetcode-cn.com/problems/array-partition-i/</a>(中文)</li>
<li><a href="https://leetcode.com/problems/array-partition-i/">https://leetcode.com/problems/array-partition-i/</a>(en)</li>
</ol>
<p>示例 1:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,4,3,2]</span><br><span class="line"></span><br><span class="line">输出: 4</span><br><span class="line">解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4).</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示:</p>
<ol>
<li>n 是正整数,范围在 [1, 10000].</li>
<li>数组中的元素范围在 [-10000, 10000].</li>
</ol>
</blockquote>
<span id="more"></span>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>个人解题思路，观察给定的例子，很容易发现，对于一个给定的$2n$大小的数组，只要在组成数对时每次都从数组选择最小的连两个数来组成$n$个数对。所获得的$1到n的min(a_i,b_i)$总和最大。</p>
<p>证明: 可以使用数学归纳法进行证明。</p>
<blockquote>
<p>因此，首先考虑将数组进行排序，然后将所有奇数位置的元素加和起来就是结果.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="comment">// sort the array first if it is unsorted.</span></span><br><span class="line">        <span class="keyword">if</span> (!isSorted(nums))</span><br><span class="line">            Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i+=<span class="number">2</span>) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// simple tool for sorting a integer array.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i]&gt;arr[i+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析(Compelxity Analysis):</strong></p>
<ul>
<li>时间复杂度(Time complexity): $O(nlogn)$，主要取决所使用的排序算法</li>
<li>空间复杂度(Space complexity): $O(1)$</li>
</ul>
<p>Submission status:</p>
<blockquote>
<p>以上解法，通过所有测试用例，运行时间$32 ms$击败$28.65$%的提交(英文版leetcode)</p>
<p>可以清楚的了解到该问题还有更好的解法。<br>由于<strong>我的解题思路基于比较的排序算法，因此时间复杂度$O(nlogn)$已是最优</strong>,需要考虑另外的解题思路。</p>
</blockquote>
<p>如果不排序的情况下，得到结果。？？？ —&gt; emmm…. 没想到。。。</p>
<blockquote>
<p>额…, 解题思路不变，还是基于排序，但是应用<strong>空间换时间</strong>的思想，因此容易想到利用<strong>桶排序</strong>对给定数组进行排序(毕竟数组元素范围已经给定$-10000 ~ 10000$)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20001</span>];</span><br><span class="line">        <span class="keyword">int</span> maxElemt = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> minElemt = Integer.MAX_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            bucket[nums[i]+<span class="number">10000</span>]++;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; maxElemt)</span><br><span class="line">                maxElemt = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; minElemt)</span><br><span class="line">                minElemt = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        minElemt += <span class="number">10000</span>;  <span class="comment">// offset is 10000</span></span><br><span class="line">        maxElemt += <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isOdd = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = minElemt; i &lt;= maxElemt; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucket[i]; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isOdd)</span><br><span class="line">                        result += (i - <span class="number">10000</span>);</span><br><span class="line">                    isOdd = !isOdd;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note primary"><p>代码简单解释，由于给定数组元素的范围为$-10000$ ~ $10000$, 因此桶排序所需要的总的容量为$20000$, 对给定数组出现的元素进行偏移(偏移量为$10000$)<br><code>bucket[nums[i]+10000]++</code>，使用两个整型变量<code>minElemt</code>和<code>maxElemt</code>确定元素出现的范围, 使用<em>flag</em>变量<code>isOdd</code>判断当前处理元素是处于奇数位置还是偶数位置。</p>
</div>
<p><strong>复杂度分析(Complexity Analysis)</strong>:</p>
<ul>
<li>时间复杂度(Time complexity): $O(n)$, 就算是数组所有元素都相同的情况，也是只要遍历$n$次</li>
<li>空间复杂度(Space complexity): $O(n)$ 对于该题目来说，$n为20000$</li>
</ul>
<p><strong>Submission status</strong>:</p>
<blockquote>
<p>代码提交状况: 运行时间$7 ms$,超过$100$%的<code>java</code>代码提交。</p>
</blockquote>
<p><img data-src="leetcode-561-2.png" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>第一种解法是通用解法，可以适用于不同的给定数组元素范围，而第二种解法只适用于此题，当元素范围比较大时，所花费的空间代价高。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-array-easy</tag>
      </tags>
  </entry>
  <entry>
    <title>Advanture 1 - leetcode 1 - Two Sum</title>
    <url>/posts/917327d3/</url>
    <content><![CDATA[<p><code>leetcode</code>解题思路总结:</p>
<blockquote>
<p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</p>
<p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。<br>链接:</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/two-sum/">https://leetcode-cn.com/problems/two-sum/</a>(中文)</li>
<li><a href="https://leetcode.com/problems/two-sum/">https://leetcode.com/problems/two-sum/</a>(en)</li>
</ul>
<p>示例:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于这样的题目，最容易想到的是<code>brute-force</code>暴力解法, 直接两重循环进行迭代.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] == target-nums[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Returns null if solution not found.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析(Complexity Analysising):</strong></p>
<ul>
<li>时间复杂度(Time complexity): $O(n^2)$</li>
<li>空间复杂度(Space complexity): $O(1)$</li>
</ul>
<p>暴力解法虽然可行，但是时间复杂度为$O(n^2)$, 考虑进行优化，首先想到是可以以空间换时间:</p>
<div class="note primary"><p>如果能够把给定数组的数，用某种数据结构将每个数的数值以及对应的索引(index)保存起来，则只需要用一次遍历查找<br><code>target - nums[i]</code>是否存在于该数据结构中，且非<code>nums[i]</code>即可。</p>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> remain = target - map.get(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(remain) &amp;&amp; map.get(remain) != i)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, map.get(remain)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// returns null if solution not found.</span></span><br><span class="line">        reutrn <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析(Complexity Analysising)</strong>:</p>
<ul>
<li>时间复杂度(Time complexity): $O(n)$</li>
<li>空间复杂度(Space complexity): $O(n)$</li>
</ul>
<div class="note warning"><p>年轻的我，本以为上面的这种解法已经是最优的了，但是看完讨论区之后，才焕然大悟，它还可以进行优化:<br>仔细看的话，上面的<code>HashMap</code>算法访问了<code>nums</code>数组两遍，而接下来，从<code>leetcode</code>上学习到的优化方法就是<strong>将<code>nums</code>数组的访问从两遍降到一遍</strong>.</p>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> remain = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(remain))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;map.get(remain), i&#125;;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info"><p>由于<code>map</code>中保存的肯定是索引<code>i</code>之前的数，因此不需要判断<code>map.get(remain) != i</code>.</p>
</div>
<p><strong>复杂度分析(Complexity Analysising)</strong>:</p>
<ul>
<li>时间复杂度(Time complexity): O(n)</li>
<li>空间复杂度(Space complexity): O(n)</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于能够快速使用<code>brute-force</code>暴力解法解决的问题，考虑优化时，首先考虑能够减少循环的嵌套，其次是考虑减少数组的访问次数、元素比较次数、元素交换次数等。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-array-easy</tag>
      </tags>
  </entry>
  <entry>
    <title>RDD:Resilient Distributed Dataset</title>
    <url>/posts/aee10f22/</url>
    <content><![CDATA[<p>RDD，一个只读的弹性分布式数据集，一个由 Spark 提供的分布式内存计算抽象模型。是 Spark 构建的根基。为了深入了解 Spark 的编程模型，学习 Spark ，我们非常有必要了解什么是 RDD。</p>
<span id="more"></span>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在 Spark 出现之前，MapReduce 和 Dryad 已经被广泛地应用于大规模数据分析处理中，这两系统允许用户通过一组高级算子来编写分布式计算应用，而不需要担心分布式协作及容错问题。尽管许多框架提供了很多访问集群计算资源的抽象，但它们均缺乏能对分布式内存进行充分利用的抽象模型，这使得它们暴露出了一些问题：</p>
<ul>
<li>由于无法存放计算中间结果，这在许多跨多计算需要重复使用中间结果的应用计算中，变得非常地低效率；</li>
<li>它们只能通过将中间结果写入到一个外部外部稳定存储中，以解决中间计算结果的重复利用问题。但这样数据访问也很低效。</li>
</ul>
<p>为了高效地重复利用中间计算结果，有研究人员为一些需要数据重用的应用专门开发了一些框架，如 Pregel，是一个能将中间数据保存到内存中的迭代式图计算系统，还有 HaLoop，它则提供了迭代式的 MapReduce 接口。尽管它们在某一程度上解决了中间计算计算数据的重用问题，但这些框架都仅适用于特定的计算模式，且数据共享是隐式的，没有通用的数据重用支持。Spark RDD 的到来则打破了这一局面。</p>
<h3 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h3><h4 id="抽象模型"><a href="#抽象模型" class="headerlink" title="抽象模型"></a>抽象模型</h4><p>一个 RDD 是一个只读的，分区的数据集，且所有 RDD 仅能从某稳定的数据存储上的数据及其他 RDDs 上执行特定操作来进行创建。为与 RDD 的其他操作区分开来，这些特定操作被称为 transformations （转换算子），e.g. <code>map</code>, <code>filter</code>, <code>join</code>。需要特别指出的是，RDDs 不需要时刻保持具体化（materialized），因为 RDD 拥有足够多的信息关于它从何而来（通过其血缘 lineage）以及如何找到需要计算的数据，包括计算方式。这是 RDD 拥有的一个非常强大的属性，此外，用户还能对 RDD 的持久化和分区方式进行控制，指示 RDD 是否需要被重用，并指定其存储策略。</p>
<h4 id="编程接口"><a href="#编程接口" class="headerlink" title="编程接口"></a>编程接口</h4><p>Spark 和 DryadLINQ 及 FlumeJava 类似，同样通过集成编程语言 API 来暴露 RDDs，每个数据集 RDD 表示为一个对象，用户可以通过调用对象的方法来执行相应的转换(transformation)及动作(action)操作。</p>
<p><img data-src="driver-workers-diagram.png" /></p>
<p>为使用 Spark，用户需要编写连接 workers 的驱动程序，在该驱动程序中定义一个或多个 RDDs，并在它们之上执行 transformations 以及  actions。RDD 的一般编程模式如下：</p>
<ul>
<li>创建 RDD: 可从稳定的数据存储或现有的其他 RDDs，使用 transformation 转换算子来进行创建；</li>
<li>操作 RDD: 对于创建的 RDDs，可以继续执行 transformations 或 actions 操作；</li>
<li>其他：此外，用户还可以通过调用 <code>persist</code> 方法来指示该 RDD 在未来操作中将需要被重用。</li>
</ul>
<p>Driver 节点上 Spark 还负责跟踪 RDDs 的血缘关系（lineage）。Workers 则作为长期运行的进程，能根据操作需要，将 RDD 的分区存储到 RAM 内存中。</p>
<p><img data-src="transformations-actions-available-on-RDDs-in-spark.png" alt=""></p>
<h4 id="优点及局限性"><a href="#优点及局限性" class="headerlink" title="优点及局限性"></a>优点及局限性</h4><p>为展示 RDD 模型作为一个分布式内存抽象的优点，文章将其与分布式共享内存 (Distributed shared memory, DSM) 进行了对比，见下表。在 DSM 系统中，应用可在全部地址空间中，对任意位置进行读写。DSM 是一个非常泛化的抽象，但它的泛化性（generality）反而使得我们很难用它实现在商用集群上实现高效的容错方案。</p>
<p><img data-src="comparison-of-RDDs-and-DSM.png" alt=""></p>
<p>尽管 RDD 抽象模型有诸多优点，但也有它应付不来的应用类型。首先，RDDs 非常适合那些在一个数据集上执行同一操作的批处理应用。在这种情况下，RDDs 可以使用一个血缘图（lineage graph）高效地记住每一个 transformation，当分区丢失时，也不需要对大量的数据进行处理。</p>
<p>RDDs 不适合需要异步细粒度共享状态更新的应用，如 Web 应用或增量 Web 爬虫的存储系统。对于这些应用，使用执行传统日志更新及数据 checkpoint 的系统可能更高效，如数据库，RAMCloud, Percolator 以及 Piccolo。RDD 模型的设计目标是为批处理分析提供一种高效的编程模型。</p>
<h3 id="RDD-in-Spark"><a href="#RDD-in-Spark" class="headerlink" title="RDD in Spark"></a>RDD in Spark</h3><h4 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h4><p>RDD 抽象的表示，其面对的最大挑战是在提供丰富的 transformations 以及  actions 算子操作供用户任意组合的同时，还需要能在大量的 transformations 跟踪 RDD 的血缘（lineage）。为实现这些目标，Spark 选择了一种基于图的 RDD 表示方式，其中，每个 RDD 均使用一个通用的接口进行表示，主要包含五类信息：一组分区（a set of partitions）、一组父 RDD 的依赖（a set of dependencies）、一个基于父 RDD 计算数据集的函数（a function）、分区模式的元数据（metadata about its partitioning schema）以及数据存放位置信息（data placement）。</p>
<p><img data-src="interface-used-to-represent-RDDs-in-spark.png" alt=""></p>
<p>这些信息在 Spark 实现中的具体接口见上图。</p>
<p>另外，值得一提的是，该接口用于表示 RDDs 间依赖关系的设计是一个非常有趣的问题，它将依赖划分成了<strong>窄依赖</strong>（<em>narrow dependencies</em>）以及<strong>宽依赖</strong>（<em>wide dependencies</em>）。其中，窄依赖指一个父 RDD 的每一个分区只能被其子 RDD 的某一个分区所使用，而对于宽依赖，则多个子 RDD 分区可依赖于同一个父 RDD 分区。常见地，<code>map</code>, <code>filter</code>, <code>union</code> 都是窄依赖，而 <code>join</code> 则是宽依赖（父 RDD 没有进行 hash 分区的情况下）。将依赖进行这样划分的原因主要有两：</p>
<ol>
<li>窄依赖可以在单个集群节点上以流水线方式执行，计算所有父 RDD 的分区；</li>
<li>节点故障后，窄依赖的恢复更高效，只需重新计算丢失的父 RDD 分区，且能在不同节点上以并行的方式进行计算，而对于宽依赖，可能单个节点的故障，会导致某 RDD 的祖先 RDD 的部分分区丢失，使得必须完全重新计算。</li>
</ol>
<p><img data-src="narrow-deps-and-wide-deps-of-rdds.png" alt=""></p>
<p>一些 RDD 实现的简单描述：</p>
<p><strong>HDFS 文件</strong>： 对于这些 RDDs，<code>partitions</code> 方法返回分区，其中每一个分区对应 HDFS 文件的一个 block 块（块的 offset 信息也包含在 <code>Parttion</code> 对象中），<code>preferredLocations</code> 方法给出这些块所处的节点，而 <code>iterator</code> 方法则用于读取这些块数据。</p>
<p><strong>map</strong>: 在任意 RDD 上调用 <code>map</code> 方法，会返回一个 <code>MappedRDD</code> 对象。该对象的分区及首选位置（preferred locations）与其父 RDD 一样，但会在 <code>iterator</code> 方法中对其父 RDD 的数据执行传入给 <code>map</code> 的函数。</p>
<p><img data-src="maprdd-illustration-combined.png" alt=""></p>
<p><strong>union</strong>: 在两个 RDDs 上调用 <code>union</code> 方法，则返回一个 RDD，其分区是两个父 RDD 分区的组合，RDD 的每个分区均通过其父 RDD 的窄依赖对应分区进行计算；</p>
<p><strong>sample</strong>: 取样 <code>sample</code> 方法和 <code>map</code> 的实现类似，只不过 RDD 会为每一个分区存储一个随机数据生成种子，以决定对父 RDD 数据记录的取样；</p>
<p><strong>join</strong>: 两个 RDDs 的 <code>join</code> 可能导致两个窄依赖（如果父 RDD 都是使用相同分区器  partitioner 进行 hash/range 分区的话），也可能导致两个宽依赖，或混合的形式（即一个父 RDD 有 partitioner，一个没有）。但不管是哪种情况，输出的 RDD 都会有一个 partitioner（要么继承于父 RDD，要么使用默认的 hash partitioner）。</p>
<p>RDDs 的这一通用接口，使得 Spark 能以少于 20 行的代码实现大多数 transformations，即便是 Spark 的新用户也能在不了解调度器（scheduler）细节的情况下，实现新的 transformations。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>最初，Spark 使用 14,000 行 scala 代码实现。系统运行于 Mesos 集群资源管理器之上，能与 Hadoop， MPI 及其他应用进行资源共享。每个 Spark 应用均作为一个单独的 Mesos 应用运行，拥有自己的 Driver 及 Workers，应用间的资源共享则由 Mesos 负责进行管理。</p>
<h5 id="1-作业调度-Job-Scheduling"><a href="#1-作业调度-Job-Scheduling" class="headerlink" title="1.  作业调度 - Job Scheduling"></a>1.  作业调度 - Job Scheduling</h5><p>总体上看，Spark 的调度器实现与 Dryad 类似，不同的是，但 Spark 的实现对持久化 persist RDDs 进行了考虑，使它们存放到内存中。当用户在一个 RDD 上执行一个 action （e.g. <code>count</code>）时，调度器会检查该 RDD 的血缘图，然后构建一个 stages 的 DAG 进行执行，如下图。</p>
<p><img data-src="spark-compute-job-stages-example.png" alt=""></p>
<p>每个 stage 会包含尽可能多的窄依赖的流水线转换算子。stages 之间的边界由宽依赖所需的 shuffle 操作来进行定义。任何已计算的分区都能短路（short circuit，与很多编程语言中的逻辑运算类似）其父 RDD 的计算。对于每一个 stage，调度器会启动任务来计算确实的分区，直到目标 RDD 计算完成。调度器 scheduler 采用这样的任务分配策略，基于局部性原理，使用延迟调度（delay scheduling）：</p>
<ul>
<li>如果一个任务 task 需要处理在某一节点内存中的分区，那么调度器会将该任务发送至该节点上；</li>
<li>如果一个任务 task 处理的分区中，有其所属 RDD 给出的偏好位置（preferred locations），则调度器会将该任务发送到这些位置上。</li>
</ul>
<p>而对于宽依赖，当前 Spark 会在持有父 RDD 分区的节点上存储具体化的中间结果，以简化故障恢复，这和 MapReduce 的 map 任务输出的存储类似。</p>
<p>当任务执行失败时，只要 stage 的父 stage 仍存活，则会将该任务交由其他节点重新运行。如果任务中的某些 stages 处于不可用状态（e.g. shuffle 的 “map 端“ 输出丢失），则会重新提交任务，并以并行的方式重新执行该任务。</p>
<h5 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2. 内存管理"></a>2. 内存管理</h5><p>Spark 为 RDDs 的持久化存储提供了三种选择：</p>
<ul>
<li>以反序列化 Java 对象的形式进行内存化存储；</li>
<li>以序列化数据的形式进行内存化存储；</li>
<li>磁盘数据存储。</li>
</ul>
<p>其中，第一种方案可提供最快的性能，因为 JVM 可直接每一个 RDD 的元素。第二种方案则给用户提供了一种对内存存储更友好的数据表示方式，但相应地性能也将会有所下降。当 RDDs 太大以至于无法维持在 RAM 内存中时，第三种方案将有所帮助，但 RDDs 重新计算的开销也很大。</p>
<p>为了管理有限的可用内存，Spark 使用了 LRU (least-recently used) 策略来回收 RDDs，当一个新的 RDD 分区计算完成，但没有足够内存进行存储时，Spark 将会回收最近访问过的 RDD 的一个分区，除非该访问过的 RDD 也包含新计算完成的分区。</p>
<h5 id="3-对-Checkpoint-的支持"><a href="#3-对-Checkpoint-的支持" class="headerlink" title="3. 对 Checkpoint 的支持"></a>3. 对 Checkpoint 的支持</h5><p>出现故障时，尽管 RDD 血缘关系可用于恢复 RDDs，但当 RDDs 拥有一个长血缘关系链时，恢复时间将非常长。因此，此时把某些 RDDs checkpoint 持久化到稳定的存储系统中，将会有所帮助。</p>
<p>通常情况下，checkpointing 对于那些包含宽依赖，且拥有长血缘关系链的 RDDs 非常有用。如果不这么做的话，将很有可能需要 RDDs 依赖链重头完全计算。相反地，对于那些数据存放于稳定存储中，且包含窄依赖的 RDDs 来说，checkpointing 可能作用就不大了。</p>
<p>Spark 当前提供了一个 checkpointing 的 API （通过 <code>persist()</code> 方法），但将把什么数据进行 checkpoint 的选择决策留给了用户。然而，现也早已有关于如何执行自动 checkpoint 的研究， e.g. <a href="https://ieeexplore.ieee.org/document/7423490">ASC</a>。因为调度器是知道每个数据集的大小以及第一次计算该数据集所需时间等信息的，这使得选择一组最优 RDDs 集合进行 checkpoint，以减少整体应用的系统恢复时间，成为可能。</p>
<p>需要特别指出的是，由于 RDD 是只读的，这使得 RDD 的 checkpoint 操作，与一般的共享内存模型要简单得多。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文是在笔者阅读完 Spark RDD 其论文<sup><a href="#fn_1" id="reffn_1">1</a></sup>后，做的一些简单总结，原文还包含了更多详细内容，如有需要请阅读论文原文，如发现本文有误，请联系我，谢谢！最后，作为结尾，我用 Spark RDD 编程模型实现大数据世界中的 HelloWorld - WordCount 吧！</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WordCountApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">System</span>.err.println(<span class="string">&quot;Usage: WordCount &lt;file&gt;&quot;</span>)</span><br><span class="line">            <span class="type">System</span>.exit(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().appName(<span class="string">&quot;wordCount&quot;</span>).getOrCreate()</span><br><span class="line">        <span class="keyword">val</span> wordsRDD = spark.sparkContext.textFile(args(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">val</span> result = wordsRDD.flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">        					 .map((_, <span class="number">1</span>))</span><br><span class="line">        					 .reduceByKey(_+_)</span><br><span class="line">        result.foreach(w =&gt; println(w._1 + <span class="string">&quot; : &quot;</span> + w._2))</span><br><span class="line">        spark.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ol>
<li><a href="https://dl.acm.org/doi/10.5555/2228298.2228301">Resilient distributed datasets: a fault-tolerant abstraction for in-memory cluster computing</a></li>
<li><a href="https://spark.apache.org/research.html">https://spark.apache.org/research.html</a></li>
</ol>
<blockquote id="fn_1">
<sup>1</sup>. <a href="https://dl.acm.org/doi/10.5555/2228298.2228301">Resilient distributed datasets: a fault-tolerant abstraction for in-memory cluster computing</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
]]></content>
      <categories>
        <category>BigData</category>
        <category>Spark</category>
      </categories>
      <tags>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>快排序优化</title>
    <url>/posts/6dcc34f7/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;不同与归并排序<code>mergeSort</code>，快排序不需要使用额外的数组来辅助进行排序，但是这并不意味着快排序就属于原地排序 (<a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a>)。</p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;快排序递归时需要使用栈空间，当执行递归函数调用时，需要将当前执行函数的状态压入线程栈中，递归调用完成后再一层层返回。快排序不属于原地排序，那么有没有方法进行优化呢？</p>
</blockquote>
<span id="more"></span>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>我们知道快排序 <code>quickSort</code>的排序性能很好，特别是针对于数组来说。<strong>JDK</strong>中 <code>Arrays.sort</code> 中针对于原始类型的数组的排序也是用到了快排序(双基准快排 <code>DualPivotQuickSort</code> )。</p>
<h3 id="QuickSort-in-JDK"><a href="#QuickSort-in-JDK" class="headerlink" title="QuickSort in JDK"></a>QuickSort in JDK</h3><p>简单看一下，JDK8 中有关快速排序算法的实现。</p>
<p><code>Arrays.class</code> 的一个 <code>sort(int[])</code> 方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sorts the specified array into ascending numerical order.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</span></span><br><span class="line"><span class="comment"> * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm</span></span><br><span class="line"><span class="comment"> * offers O(n log(n)) performance on many data sets that cause other</span></span><br><span class="line"><span class="comment"> * quicksorts to degrade to quadratic performance, and is typically</span></span><br><span class="line"><span class="comment"> * faster than traditional (one-pivot) Quicksort implementations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a the array to be sorted</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DualPivotQuicksort</code> 的实现就相对复杂一点，如果感兴趣的话可以自行查看相关源代码和实现文档, 这里只对有关快排序的内容进行简单地阐述。</p>
<p><img data-src="quickSortOptimization-1.png" alt="DualPivotQuickSort"></p>
<p>从上面给到的文档内容看，我们关注以下的常量:</p>
<ul>
<li><code>QUICKSORT_THRESHOLD=286</code>: 在归并排序中用到，当数组元素数量小于286时，切换为快速排序；</li>
<li><p><code>INSERTION_SORT_THRESHOLD=47</code>: 在快速排序中用到，当数组元素数量小于47时，切换为插入排序； </p>
</li>
<li><p><code>MAX_RUN_COUNT=67</code>: 归并排序中最大运行次数；</p>
</li>
<li><code>MAX_RUN_LENGTH=33</code>: 归并排序允许的连续重复元素个数的最大值</li>
</ul>
<p>主要排序方法如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Sorting methods for seven primitive types.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sorts the specified range of the array using the given</span></span><br><span class="line"><span class="comment"> * workspace array slice if possible for merging</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a the array to be sorted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left the index of the first element, inclusive, to be sorted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right the index of the last element, inclusive, to be sorted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> work a workspace array (slice)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workBase origin of usable space in work array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workLen usable size of work array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">int</span>[] work, <span class="keyword">int</span> workBase, <span class="keyword">int</span> workLen)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Use Quicksort on small arrays</span></span><br><span class="line">    <span class="comment">// 即， array.length &lt; 286 时使用快排序</span></span><br><span class="line">    <span class="keyword">if</span> (right - left &lt; QUICKSORT_THRESHOLD) &#123;</span><br><span class="line">        sort(a, left, right, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Index run[i] is the start of i-th run</span></span><br><span class="line"><span class="comment">     * run[i] 表示第 i-th 次运行</span></span><br><span class="line"><span class="comment">     * (ascending or descending sequence).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span>[] run = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_RUN_COUNT + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; run[<span class="number">0</span>] = left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if the array is nearly sorted</span></span><br><span class="line">    <span class="comment">// 判断数组是否已经基本排好序(部分有序)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt; right; run[count] = k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[k] &lt; a[k + <span class="number">1</span>]) &#123; <span class="comment">// ascending</span></span><br><span class="line">            <span class="comment">// while 循环结束后，k会指向连续生序元素的最后一个</span></span><br><span class="line">            <span class="keyword">while</span> (++k &lt;= right &amp;&amp; a[k - <span class="number">1</span>] &lt;= a[k]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[k] &gt; a[k + <span class="number">1</span>]) &#123; <span class="comment">// descending</span></span><br><span class="line">            <span class="comment">// 同上, 类似地，k 会指向连续降序元素的最后一个</span></span><br><span class="line">            <span class="keyword">while</span> (++k &lt;= right &amp;&amp; a[k - <span class="number">1</span>] &gt;= a[k]);</span><br><span class="line">            <span class="comment">// 对这一部分进行翻转(reverse), 使其生序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> lo = run[count] - <span class="number">1</span>, hi = k; ++lo &lt; --hi; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = a[lo]; a[lo] = a[hi]; a[hi] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// equal</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m = MAX_RUN_LENGTH; ++k &lt;= right &amp;&amp; a[k - <span class="number">1</span>] == a[k]; ) &#123;</span><br><span class="line">                <span class="comment">// 数组中连续重复元素超过MAX_RUN_LENGTH(33)时</span></span><br><span class="line">                <span class="comment">// 使用快排序</span></span><br><span class="line">                <span class="keyword">if</span> (--m == <span class="number">0</span>) &#123;</span><br><span class="line">                    sort(a, left, right, <span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * The array is not highly structured,</span></span><br><span class="line"><span class="comment">         * use Quicksort instead of merge sort.</span></span><br><span class="line"><span class="comment">         * 如果数组非高度结构化，使用快排序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (++count == MAX_RUN_COUNT) &#123;</span><br><span class="line">            sort(a, left, right, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check special cases</span></span><br><span class="line">    <span class="comment">// Implementation note: variable &quot;right&quot; is increased by 1.</span></span><br><span class="line">    <span class="keyword">if</span> (run[count] == right++) &#123; <span class="comment">// The last run contains one element</span></span><br><span class="line">        run[++count] = right;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">1</span>) &#123; <span class="comment">// The array is already sorted</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine alternation base for merge</span></span><br><span class="line">    <span class="keyword">byte</span> odd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; (n &lt;&lt;= <span class="number">1</span>) &lt; count; odd ^= <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use or create temporary array b for merging</span></span><br><span class="line">    <span class="keyword">int</span>[] b;                 <span class="comment">// temp array; alternates with a</span></span><br><span class="line">    <span class="keyword">int</span> ao, bo;              <span class="comment">// array offsets from &#x27;left&#x27;</span></span><br><span class="line">    <span class="keyword">int</span> blen = right - left; <span class="comment">// space needed for b</span></span><br><span class="line">    <span class="keyword">if</span> (work == <span class="keyword">null</span> || workLen &lt; blen || workBase + blen &gt; work.length) &#123;</span><br><span class="line">        work = <span class="keyword">new</span> <span class="keyword">int</span>[blen];</span><br><span class="line">        workBase = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (odd == <span class="number">0</span>) &#123;</span><br><span class="line">        System.arraycopy(a, left, work, workBase, blen);</span><br><span class="line">        b = a;</span><br><span class="line">        bo = <span class="number">0</span>;</span><br><span class="line">        a = work;</span><br><span class="line">        ao = workBase - left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        b = work;</span><br><span class="line">        ao = <span class="number">0</span>;</span><br><span class="line">        bo = workBase - left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merging</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> last; count &gt; <span class="number">1</span>; count = last) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = (last = <span class="number">0</span>) + <span class="number">2</span>; k &lt;= count; k += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> hi = run[k], mi = run[k - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = run[k - <span class="number">2</span>], p = i, q = mi; i &lt; hi; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) &#123;</span><br><span class="line">                    b[i + bo] = a[p++ + ao];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    b[i + bo] = a[q++ + ao];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            run[++last] = hi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((count &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = right, lo = run[count - <span class="number">1</span>]; --i &gt;= lo;</span><br><span class="line">                b[i + bo] = a[i + ao]</span><br><span class="line">            );</span><br><span class="line">            run[++last] = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] t = a; a = b; b = t;</span><br><span class="line">        <span class="keyword">int</span> o = ao; ao = bo; bo = o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他相关的更详细内容可以自行移步到 JDK 源代码文档中查看。</p>
<h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>本文只讨论简单的最原始的快排序(单基准, single-pivot )实现(伪代码如下), 即</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QuickSort (if low &lt; high):</span><br><span class="line">	pi = partition(arr, low, high);</span><br><span class="line">	QuickSort(arr, low, pi - 1);</span><br><span class="line">	QuickSort(arr, pi + 1, high);</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析:</strong></p>
<ul>
<li>Time complexity: $O(n log n)$</li>
<li>Space complexity: $O(n)$ in worst case</li>
</ul>
<p>由于上述实现的代码最后是两次递归调用，因此在最坏情况下，将需要 $O(n)$ 空间的函数调用栈。</p>
<blockquote>
<p>最坏情况: 因为使用单基准元素对数组进行划分，如果每次都将数组划分为  $0$ 个元素和 $n-1$ 个元素两个部分的话，将出现最坏情况。</p>
</blockquote>
<p>例如对于选择第一个元素作为基准元素，如果给定数组是逆序的(或者反过来，选择最后一个作为基准，给定数组已排序)，则出现最坏情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">/* pi is the partiioning index */</span></span><br><span class="line">        <span class="keyword">int</span> pi = partition(arr, low, high);</span><br><span class="line">        <span class="comment">// Separately sort elements before</span></span><br><span class="line">        <span class="comment">// partition and after partition</span></span><br><span class="line">        quickSort(arr, low, pi - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, pi + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最坏情况示例:</p>
<p><img data-src="quickSortOptimization-2.png" alt="quickSort-worst-case"></p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><p>上面讨论了快排序存在的问题，接下来将针对上述问题提出解决方法。</p>
<h3 id="Method-I"><a href="#Method-I" class="headerlink" title="Method I"></a>Method I</h3><p>对于每次数组划分，使得各个部分都小于 $n/2$, 其中 $n$ 为数组长度。</p>
<p><img data-src="quickSortOptimization-3.png" alt="method-1-1"></p>
<p>这种方法并不是最好的解决方案，<strong>栈中单个项目的大小仍可能为 $O(n)$ </strong>.</p>
<p><img data-src="quickSortOptimization-4.png" alt="method-1-2"></p>
<h3 id="Method-II"><a href="#Method-II" class="headerlink" title="Method II"></a>Method II</h3><p>思想: 只对较小的划分部分调用递归函数，否则继续划分。(这种方式使用了尾递归，想了解更多可以留意本文最后给出的参考链接)</p>
<p><img data-src="quickSortOptimization-5.png" alt="method-2-1"></p>
<p><img data-src="quickSortOptimization-6.png" alt="method-2-2"></p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>下面是对上述解决方法II的实现，使用尾递归进行处理。</p>
<p>我们可以将之前的代码转换为如下，使用<code>while</code>循环以减少递归调用的次数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">// pi is partitioning index</span></span><br><span class="line">        <span class="keyword">int</span> pi = partition(arr, low, high);</span><br><span class="line">        <span class="comment">// Separately sort elements before</span></span><br><span class="line">        <span class="comment">// partition and after partition</span></span><br><span class="line">        quickSort(arr, low, pi - <span class="number">1</span>);</span><br><span class="line">        low = pi + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种实现方式，尽管减少了递归函数调用的次数，但是在最坏情况，所需的栈空间仍是$O(n)$. 因为我们仍可以将数组划分为$n-1$个元素部分和另一部分。</p>
</blockquote>
<p>进一步优化:</p>
<blockquote>
<p>以下的实现方式，在划分(<em>partition</em>)之后，只在较小的部分上执行递归函数。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java implementation</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick</span> </span>&#123;</span><br><span class="line">    <span class="function">pulbic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(arr)</span></span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* This QuickSort requires O(log n) auxiliary space in worst case.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;  high) &#123;</span><br><span class="line">            <span class="comment">// pi is partitioning index</span></span><br><span class="line">            <span class="keyword">int</span> pi = partition(arr, low, high);</span><br><span class="line">            <span class="comment">// if left part is smaller, then recur for left</span></span><br><span class="line">            <span class="comment">// part and handle right part iteratively</span></span><br><span class="line">            <span class="keyword">if</span> (pi - low &lt; high - pi) &#123;</span><br><span class="line">                quickSort(arr, low, pi - <span class="number">1</span>);</span><br><span class="line">                low = pi + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// else recur for right part</span></span><br><span class="line">                quickSort(arr, pi+<span class="number">1</span>, high);</span><br><span class="line">                high = pi - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (low &gt; high) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;invalid arguments&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i = low, j = high + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> povit = arr[low];</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[++i] &lt; povit)</span><br><span class="line">                <span class="keyword">if</span> (i == high) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">while</span> (arr[--j] &gt; povit)</span><br><span class="line">                <span class="keyword">if</span> (j == low) <span class="keyword">break</span>; <span class="comment">// reduntant</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; j) <span class="keyword">break</span>;</span><br><span class="line">            swap(arr, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; low) swap(arr, low, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">////////////// Help functions //////////////////////</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i+<span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述优化后的实现方式中，我们只在更小的部分上递归调用函数；因此在最坏情况下，当所有递归调用中的两个部分大小相同时，使用$O(log\ n)$的额外空间。</p>
<blockquote>
<p><em>References</em>:</p>
<ol>
<li><a href="https://www.geeksforgeeks.org/tail-call-elimination/">https://www.geeksforgeeks.org/tail-call-elimination/</a></li>
<li><p><a href="https://www.geeksforgeeks.org/quicksort-tail-call-optimization-reducing-worst-case-space-log-n/">https://www.geeksforgeeks.org/quicksort-tail-call-optimization-reducing-worst-case-space-log-n/</a></p>
</li>
<li><p><a href="http://www.cs.nthu.edu.tw/~wkhon/algo08-tutorials/tutorial2b.pdf">http://www.cs.nthu.edu.tw/~wkhon/algo08-tutorials/tutorial2b.pdf</a></p>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Algorithms</category>
        <category>sorting algs</category>
      </categories>
      <tags>
        <tag>sorting algs</tag>
      </tags>
  </entry>
  <entry>
    <title>基本查找算法 - basical searching algorithms</title>
    <url>/posts/d83777d2/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>基本查找算法，我们只谈<strong>静态查找</strong>的查找算法。</p>
<h3 id="线性查找-linear-search"><a href="#线性查找-linear-search" class="headerlink" title="线性查找 - linear search"></a>线性查找 - linear search</h3><p>特点： </p>
<ul>
<li>从头开始遍历数组，一个一个和<strong>key</strong>比较，查找成功则返回索引值。</li>
<li>不要求数组是<strong>有序的</strong>。</li>
<li>时间复杂度为： $O(n)$.</li>
</ul>
<h4 id="线性查找原始抽象方法实现如下"><a href="#线性查找原始抽象方法实现如下" class="headerlink" title="线性查找原始抽象方法实现如下:"></a>线性查找原始抽象方法实现如下:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">linearSearch</span><span class="params">(Comparable[] a, Comparable key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (a[i].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="跳跃查找-jump-search"><a href="#跳跃查找-jump-search" class="headerlink" title="跳跃查找 - jump search"></a>跳跃查找 - jump search</h3><p>特点：</p>
<ul>
<li>要求查找数组<strong>有序</strong>；</li>
<li>主要思想是每次跳跃固定量的元素来确定目标元素所在的区间，再使用线性查找在区间上搜索目标元素。</li>
<li>时间复杂度为： $O(\sqrt{n})$.</li>
</ul>
<p><strong>[notice] : </strong> 假设我们要在一个有n个元素的数组中搜索某个元素，最坏情况下（<strong>当目标元素为最后个元素时），这个算法要跳跃n/m步，在线性搜索时作m-1次比较。</strong>令 $f(n) = ((n/m) + m-1$.当m = $\sqrt{n}$时，f(n) 取最小值，所以通常情况下，跳跃查找所使用的固定跳跃步数为 $\sqrt{n}$. </p>
<h4 id="跳跃查找的原始抽象方法实现如下："><a href="#跳跃查找的原始抽象方法实现如下：" class="headerlink" title="跳跃查找的原始抽象方法实现如下："></a>跳跃查找的原始抽象方法实现如下：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jumpSearch</span><span class="params">(Comparable[] a, Comparable key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">int</span> block_size = Math.floor(Math.sqrt(n));</span><br><span class="line">	<span class="keyword">int</span> step = block_size;</span><br><span class="line">    <span class="comment">// 查找目标元素可能出现的区间</span></span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (a[Math.min(step, n) - <span class="number">1</span>].compareTo(key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    	prev = step;</span><br><span class="line">        step += block_size;</span><br><span class="line">        <span class="keyword">if</span> (prev &gt;= n)</span><br><span class="line">        	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用线性查找在确定的区间上查找目标元素</span></span><br><span class="line">    <span class="keyword">while</span> (a[prev].compareTo(key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    	prev++;</span><br><span class="line">        <span class="keyword">if</span> (prev == Math.min(step, n))</span><br><span class="line">        	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[prev].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">    	<span class="keyword">return</span> prev;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二分查找-binary-search"><a href="#二分查找-binary-search" class="headerlink" title="二分查找 - binary search"></a>二分查找 - binary search</h3><ul>
<li>要求数组<strong>有序</strong>。</li>
<li>将已经排好序的数组分为两个区间(interval), 把区间的中间元素与<strong>key</strong>比较, 若大于则搜索左区间，若小于则搜索右区间，等于则返回元素的索引。<strong>当区间长度为0时（key没出现在数组中)</strong>,返回-1。</li>
<li>时间复杂度为 ： $O(nlogn)$.</li>
</ul>
<h4 id="二分查找原始抽象方法实现如下"><a href="#二分查找原始抽象方法实现如下" class="headerlink" title="二分查找原始抽象方法实现如下:"></a>二分查找原始抽象方法实现如下:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(Comparable[] a, Comparable key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hi = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">    	<span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[mid].compareTo(key) &gt; <span class="number">0</span>)</span><br><span class="line">        	hi = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        	lo = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearchRecursion</span><span class="params">(Comparable[] a, Comparable key, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (lo &lt;= hi) &#123;</span><br><span class="line">    	<span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[mid].compareTo(key) &lt; <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> binarySearchRecursion(a, key, mid+<span class="number">1</span>, hi);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        	<span class="keyword">return</span> binarySearchRecursion(a, key, lo, mid-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三分查找-ternary-search"><a href="#三分查找-ternary-search" class="headerlink" title="三分查找 - ternary search"></a>三分查找 - ternary search</h3><p>特点：</p>
<ul>
<li>三分查找是二分查找的扩展；</li>
<li>时间复杂度为 ： $O(nlog_3n)$.</li>
</ul>
<p><strong>[notice]:</strong> 虽然看似三分查找的时间复杂度比二分查找的时间复杂度小，但是<strong>在最坏情况下</strong>，二分查找需要$2Log<em>2n + 1$次比较，而三分查找需要$4Log</em>{3}n + 1$次比较</p>
<h4 id="三分查找原始抽象方法实现如下："><a href="#三分查找原始抽象方法实现如下：" class="headerlink" title="三分查找原始抽象方法实现如下："></a>三分查找原始抽象方法实现如下：</h4><p>特点：</p>
<ul>
<li>类似二分查找，将查找数组划分为三个部分来进行查找；</li>
<li>时间复杂度： $Log_3n$.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归实现.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ternarySearch</span><span class="params">(Comparable[] a, Comparable key, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (lo &lt;= hi) &#123;</span><br><span class="line">    	<span class="keyword">int</span> mid1 = lo + (hi - lo) / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> mid2 = mid1 + (hi - lo) / <span class="number">3</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (a[mid1].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> mid1;</span><br><span class="line">        <span class="keyword">if</span> (a[mid2].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> mid2;</span><br><span class="line">        <span class="comment">// 目标元素只可能出现在第一部分.</span></span><br><span class="line">        <span class="keyword">if</span> (a[mid1].compareTo(key) &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> ternarySearch(a, key, lo, mid1-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 目标元素只可能出现在第三部分.</span></span><br><span class="line">        <span class="keyword">if</span> (a[mid2].compareTo(key) &lt; <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> ternarySearch(a, key, mid2+<span class="number">1</span>, hi);</span><br><span class="line">        <span class="comment">// 目标元素只可能出现在第二部分.</span></span><br><span class="line">        <span class="keyword">return</span> ternarySearch(a, key, mid1+<span class="number">1</span>, mid2-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找失败.</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指数搜索-exponential-search"><a href="#指数搜索-exponential-search" class="headerlink" title="指数搜索 - exponential search"></a>指数搜索 - exponential search</h3><p>特点：</p>
<ul>
<li>找到目标元素可能出现的区间；</li>
<li>使用二分查找在区间上查找目标元素;</li>
<li>时间复杂度： $logn$;</li>
</ul>
<p><strong>[notice]</strong>:</p>
<ol>
<li>适用于目标数组元素大小趋向于无限大的情况；</li>
<li>当目标出现在目标数组左边时，指数搜索速度比二分查找快。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exponentialSearch</span><span class="params">(Comparable[] a, Comparable key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n  = a.length;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; a[i].compareTo(key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"> 		i = i * <span class="number">2</span>;   	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> binarySearch(a, key, i/<span class="number">2</span>, Math.min(i, n-<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插值搜索-interpolation-search"><a href="#插值搜索-interpolation-search" class="headerlink" title="插值搜索 - interpolation search"></a>插值搜索 - interpolation search</h3><p>特点：</p>
<ul>
<li><p>原理： 假设查找数组的元素是均匀分布的，使用<strong>直线插值搜索</strong>，不像二分查找那样每次都是搜索区间中间元素。它能够快速的接近目标元素。</p>
</li>
<li><p>当元素均匀分布的情况，时间复杂度为: $O(log(log n))$, 最坏情况: $O(n)$.</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java program to implement interpolatoin search.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">interpolationSearch</span><span class="params">(Comparable[] a, Comparable key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hi = a.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi &amp;&amp; less(key, a[hi]) &amp;&amp; less(a[lo], key)) &#123;</span><br><span class="line">    	<span class="keyword">int</span> pos = lo + (hi - lo) * (key - a[lo]) / (a[hi] - a[lo]);</span><br><span class="line">        <span class="keyword">if</span> (a[pos].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> pos;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[pos].compareTo(key) &gt; <span class="number">0</span>)</span><br><span class="line">        	hi = pos - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            lo = pos + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NOTICE"><a href="#NOTICE" class="headerlink" title="NOTICE"></a>NOTICE</h3><p>本文中，涉及的算法详细实现和使用，请移步到github<a href="https://github.com/rovo98/ds-and-algs#searching-algorithms----go-back-to-top">查看</a>。</p>
]]></content>
      <categories>
        <category>Algorithms</category>
        <category>searching algs</category>
      </categories>
      <tags>
        <tag>basical searching algs</tag>
      </tags>
  </entry>
  <entry>
    <title>基本排序算法 - basial sorting algorithms with java implementation</title>
    <url>/posts/57d02cec/</url>
    <content><![CDATA[<blockquote>
<p>我们关注的主要对象是<strong>重新排列数组元素的算法</strong>， 其中每个元素都有一个<strong>主键</strong>。排序算法的目的就是将所有元素的主键按照某种方式排列(通常按照大小或是字母顺序)。</p>
</blockquote>
<span id="more"></span>
<p>在java中元素通常都是对象，对主键的抽象描述则是通过一种内置的机制(<code>Comparable</code>接口)来完成的。</p>
<h4 id="排序算法类模板"><a href="#排序算法类模板" class="headerlink" title="排序算法类模板"></a>排序算法类模板</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    	Comparable temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">/*排序算法，如InsertionSort、BubbleSort、</span></span><br><span class="line"><span class="comment">        SelectionSort、ShellSort等*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        	System.out.print(a[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (less(a[i], a[i-<span class="number">1</span>]) &#123;</span><br><span class="line">            	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Unit tests the &#123;<span class="doctag">@code</span> Example&#125; sorting algorithm.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@args</span> command-line arguments.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 测试代码...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这个类展示的是数组排序实现的框架。代码中实现的排序方法适用于任意实现了<code>Comparable</code>接口的数据类型</strong>。</p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>无论数组的初始状态是什么，我们都无法确保排序算法都能成功。所以谨慎起见，我们会在测试代码中添加一条语句<code>assert isSorted(a);</code>来确保排序后的数组都是有序的。</p>
<h4 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h4><p>评估算法的性能。首先，要计算各个排序算法在不同的随机输入下的基本操作的次数(包括比较和交换，或者是读写数组的次数)。</p>
<blockquote>
<p>排序成本模型 : 在研究排序算法时，我们需要计算比较和交换的数量。<br>  对于不交换元素的算法，我们会计算访问数组的次数。</p>
</blockquote>
<h4 id="额外的内存使用"><a href="#额外的内存使用" class="headerlink" title="额外的内存使用"></a>额外的内存使用</h4><p>排序算法的额外内存开销和运行时间是同等重要的。排序算法可以分为两类:</p>
<ul>
<li>除了函数调用所需的栈和固定数目的实例变量之外无需额外内存的<strong>原地排序算法</strong>。</li>
<li>需要额外内存空间来存储另一份数组副本的其他排序算法。</li>
</ul>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>上面的排序模板适用于实现了Comparable接口的数据类型。例如, java中封装数字类型的<code>Integer</code>、<code>Double</code>、以及<code>String</code>和其他许多高级数据类型。<br>而对于自己创建的数据类型，我们是要实现Comparable接口就能够保证能够使用排序算法进行排序。</p>
<p>自定义数据类型样例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Date</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> day;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> year;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Date</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> m, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123; day = d; month = m; year = y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">day</span><span class="params">()</span> 	</span>&#123; <span class="keyword">return</span> day; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">month</span><span class="params">()</span>	</span>&#123; <span class="keyword">return</span> month; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">year</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> year;  &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Date that)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (<span class="keyword">this</span>.year &gt; that.year) <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.year &lt; that.year) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.month &gt; that.month) <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.month &lt; that.month) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.day &gt; that.day) 	<span class="keyword">return</span> +<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.day &lt; that.day) 	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> month + <span class="string">&quot;/&quot;</span> + day + <span class="string">&quot;/&quot;</span> + year;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置(如果第一个元素就是最小的元素那么它就和自己交换)。 再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到整个数组排序完成。<strong>不断地选择剩余元素中的最小者</strong>。</p>
<blockquote>
<p><strong>命题 A: 对于长度为 $N$ 的数组，选择排序需要大约 $N^2/2$ 次比较和 $N$ 次交换。</strong><br>  证明： 可以通过算法的排序轨迹来证明，用一张$N X N$的表格来表示排序的轨迹，其中每个非灰色字符都表示一次比较。表格中大约有一半的元素不是  灰色的 — 即对角线和其上部分的元素。对角巷上的每个元素都对应真一次交换。通过查看代码我们可以更精确地得到，$0$ 到 $N-1$ 的任意 $i$ 都会  进行一次交换和 $N-1-i$ 次比较，因此   总共有$N$次交换以及 $(N-1)+（N-2)+…+2+1 = N(N-1)/2 ~ N^2/2$。</p>
</blockquote>
<p>算法轨迹图示（from algs4)：</p>
<p><img data-src="bs_selectionSort_1.png" alt="插入排序算法轨迹例子"></p>
<p>算法实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* 其他的方法同排序算法模板*/</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        	<span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            	<span class="keyword">if</span> (less(a[j], a[min]) &#123;</span><br><span class="line">                	min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            exch(a, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>与选择排序一样，当前索引左边的所有元素都是有序的，但他们的最终位置不确定，为了给更小的元素腾出空间，它们可能会移动。当索引到达数组的右端时，数组排序就完成了。</p>
<p>和选择排序不同的是，插入排序<strong>所需的时间取决于输入中元素的初始顺序</strong>。例如对于一个很大且其中的元素已经有序（或接近有序）的数组进行插入排序将会比对随机数组或逆序数组进行排序要快得多。</p>
<blockquote>
<p><strong>命题 B : 对于随机排列的长度为 $N$ 且主键不重复的数组, 平均情况下插入排序需要 ~ $N^2/4$次比较以及 $~N^2/4$次交换。最坏情况下需要 ~N^2  /2  次比较和 ~ $N^2/2$次交换，最好情况下需要$N-1$次比较和$0$次交换。</strong><br>  证明： 和证明命题A一样，通过一个$N X N$的算法轨迹表可以很容易就得到交换和比较的次数。最坏的情况下对角线之下所有元素都需要移动位置，最   好情况下都不需要。对于随机排列的数组，在平均情况下每个元素都可能向后移动半个数组的长度 ，因此交换总数是对角线之下的元素总数的二分之。   比较的总次数是交换的次数加上一个额外的项，该项为 $N$ 减去被插入的元素正好是已知的最小   元   素的次数。在最坏情况下（逆序数组），这一   项相对于总数可以忽略不计；在最好的情况下（数组已经有序），这一项等于$N-1$。</p>
</blockquote>
<p>插入排序算法轨迹图示（from algs4):</p>
<p><img data-src="bs_insertionSort_1.png" alt="插入排序算法轨迹图例"></p>
<p>算法实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*其他的方法同排序算法模板*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        	<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j&gt;<span class="number">0</span>&amp;&amp;less(a[j], a[j-<span class="number">1</span>]; j--) &#123;</span><br><span class="line">            	exch(a, j, j-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<p><strong>附加：</strong></p>
<p>对于插入排序，我们要考虑的更一般情况是<strong>部分有序的数组</strong>。<br><strong>倒置</strong>指的是数组中的两个顺序颠倒的元素。比如EXAMPLE中有11对倒置：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E-A  X-A  X-M  X-P  X-L	X-E</span><br><span class="line">M-L M-E  P-L  P-E L-E</span><br></pre></td></tr></table></figure><br>如果数组中倒置的数量小于数组大小的某个倍数，那么我们说这个数组是<strong>部分有序</strong>的。<br>几种典型的部分有序的数组:</p>
<ul>
<li>数组中每个元素距离它的最终位置不远；</li>
<li>一个有序数组接一个小数组；</li>
<li>数组中只有几个元素位置不正确。</li>
</ul>
<p><strong>插入排序对这样的数组很有效，而选择排序则不然。当倒置的数量很少时，插入排序比大部分的其他排序算法都要快</strong>。</p>
<blockquote>
<p><strong>命题 C: 插入排序需要的交换的操作和数组的中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一</strong>。<br>  证明： 每次交换都改变了两个顺序颠倒的元素的位置，相当于减少了一对倒置，当倒置数量为0时，排序就完成了。每次交换都对应着一次比较，且$1$   到$N  -1$之间的每个$i$都可能需要一次额外的比较(在<code>a[i]</code>没有达到数组的左端时)。</p>
</blockquote>
<p><strong>[算法改进]</strong> : 大幅提高插入排序的速度，在内循环中将较大的元素都向右移动而不是总是交换两个元素(这样访问数组的次数就能减半)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    	Comparable key = a[i];</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = i-<span class="number">1</span>; j &gt;= <span class="number">0</span>&amp;&amp;less(key, a[j]); j--) &#123;</span><br><span class="line">        	a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        a[j+<span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序是基于插入排序的快速排序算法.<br>对于规模乱序数组插入排序很慢，因为它只会交换相邻的元素，因此元素只能一点一点地从数组的一端移动到另外一端。<br>希尔排序为了加快速度简单地改进了插入排序 —— 交换不相邻的元素以对数组的<strong>局部</strong>进行排序，并最终使用插入排序将局部有序的数组排序。</p>
<p><strong>希尔排序的思想</strong>:使任意间隔为h的元素都是有序的。<br>这样的数组称为<strong>h有序数组</strong>。对于任意以1为结尾的h序列（递增序列），我们使用它都能将数组排序。</p>
<p>算法实现： —— 使用的递增序列来自 algs4.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*其他排序算法方法同模板*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">     	<span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; n/<span class="number">3</span>) h = <span class="number">3</span> * h + <span class="number">1</span>; <span class="comment">// 1， 4， 13， 40， 121， ...</span></span><br><span class="line">        <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        	<span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; n; i++) &#123;</span><br><span class="line">            	<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h&amp;&amp;less(a[j], a[j-h]); j -= h) &#123;</span><br><span class="line">                	exch(a, j, j-h);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>[递增序列的选择]</strong> : 算法的性能不仅取决于h，还取决与h之间的数学性质。目前还没有人能证明某个递增序列是”最好的”。以上算法实现使用的递增序列（使用序列 $1/2(3^k-1)$,从N/3开始递减至1.）的计算和使用都很简单且和复杂的递增序列的性能接近。</p>
<p>算法轨迹图例 — example (from algs4):</p>
<p><img data-src="bs_shellSort_1.png" alt="希尔排序算法轨迹图例"></p>
<p><strong>实际应用</strong>: 对于中等大小的数组它的运行时间是可以接受的且它的代码量小，不需要额外的内存空间。<em>所以在面临一个排序问题而没有系统排序函数可用时，可先用希尔排序，然后再考虑是否将它替换为更加复杂的排序算法</em>。</p>
<p><strong>[算法改进]</strong> : 由于希尔排序是基于插入排序，所以我们可以参照插入排序的改进，对希尔排序进行改进 — 把内循环中较大的元素右移而不是交换两个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; n/<span class="number">3</span>) h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; n; i++) &#123;</span><br><span class="line">        	Comparable key = a[i];</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = i-h; j &gt;= <span class="number">0</span>&amp;&amp;less(key, a[j]); j -= h) &#123;</span><br><span class="line">            	a[j+h] = a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            a[j+h] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="附加-——-冒泡排序"><a href="#附加-——-冒泡排序" class="headerlink" title="附加 —— 冒泡排序"></a>附加 —— 冒泡排序</h3><p>冒泡排序相对比较简单，这里直接给出它的实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bubble</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*其他排序算法方法同排序算法模板*/</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">	 	<span class="keyword">int</span> n = a.length;</span><br><span class="line">	 	<span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">	 	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n&amp;&amp;flag == <span class="keyword">true</span>; i++) &#123;</span><br><span class="line"> 			flag = <span class="keyword">false</span>;</span><br><span class="line"> 			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n-i; j++) &#123;</span><br><span class="line">  		  		<span class="keyword">if</span> (less(a[j+<span class="number">1</span>], a[j]) &#123;</span><br><span class="line">     		   		exch(a, j+<span class="number">1</span>, j);</span><br><span class="line">           			flag = <span class="keyword">true</span>;</span><br><span class="line">        		&#125;</span><br><span class="line">    		&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法分析</strong>: 对于冒泡排序，最坏情况下，算法需要进行N-1趟排序，总的数组元素比较的次数为$(N-1)+(N-2)+…+1$ ~ $N^2/2$， 总的交换次数为数组中<strong>倒置</strong>的数量。</p>
<h3 id="NOTICE"><a href="#NOTICE" class="headerlink" title="NOTICE"></a>NOTICE</h3><p>本文中，涉及的算法详细实现和使用，请移步到github<a href="https://github.com/rovo98/ds-and-algs#sorting-algorithms----go-back-to-top">查看</a>。</p>
]]></content>
      <categories>
        <category>Algorithms</category>
        <category>sorting algs</category>
      </categories>
      <tags>
        <tag>sorting algs</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序 - mergeSort</title>
    <url>/posts/1368334/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>归并排序属于<strong>分治算法(Divide and Conquer)</strong>。通过递归不断把待排序数组分成两个部分，将有序的两部分再重新归并一起来实现对数组的排序。</p>
<p><strong>[pseudo code for 2-way merge sort]</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MergeSort(arr[], aux[], lo, hi)</span><br><span class="line">If hi &gt; lo</span><br><span class="line">	1. Find the middle point to divide the array into two halves;</span><br><span class="line">		int mid = lo + (hi - lo) / 2;</span><br><span class="line">	2. Call MergeSort for first half;</span><br><span class="line">		MergeSort(arr, aux, lo, mid);</span><br><span class="line">	3. Call MergeSort for second half;</span><br><span class="line">		MergeSort(arr, aux, mid+1, hi);</span><br><span class="line">	4. Merge the two halves sorted in step 2 and 3;</span><br><span class="line">		Call merge(arr, aux, lo, mid, hi);</span><br></pre></td></tr></table></figure>
<h3 id="原地归并的抽象方法"><a href="#原地归并的抽象方法" class="headerlink" title="原地归并的抽象方法"></a>原地归并的抽象方法</h3><p>要实现上述的归并方法 — <strong>merge()</strong>很简单，创建一个数组将需要归并的<strong>原数组的两个部分</strong>中的元素放到这个数组中，然后再归并按大小顺序放回原数组。</p>
<blockquote>
<p>但是，这里我们要考虑一个问题，当我们用归并排序对一个比较大的数组进行排序时，我们需要进行很多次归并，因此在每一次归并时都创建一个新的数组来存储排序结果会带来问题。我们可以考虑只创建一个<strong>辅助数组<code>aux[]</code></strong>, 在每一个归并时，将原数组需要归并的两个部分复制到<code>aux[]</code>中，再把归并结果放回原数组。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, Comparable[] aux, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// precondition: a[lo .. mid] and a[mid+1 .. hi] is sorted.</span></span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a, lo, mid)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a, mid+<span class="number">1</span>, hi)</span></span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// copy a[lo .. hi] to aux[lo .. hi].</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">    	aux[k] = a[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">    	<span class="keyword">if</span>      (i &gt; mid)               a[k] = aux[j++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi)                a[k] = aux[i++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (less(aux[j], aux[i]))  a[k] = aux[j++];</span><br><span class="line">        <span class="keyword">else</span> 			               a[k] = aux[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// postcondition: a[lo .. hi] is sorted.</span></span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a, lo, hi)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[说明] : 该方法先将原数组两个需要归并的部分复制到aux[]中，然后<strong>从两个部分的起始位置开始取元素，一直选择两个部分中较小的元素放回原数组中，当有一部分元素取完了，则将另一部分剩余的元素全部放回原数组</strong>。</p>
<p>原地归并抽象方法轨迹： [from algs4]</p>
<p><img data-src="mergeSort_merge.png" alt="原地归并抽象方法轨迹"></p>
<h3 id="自顶向下的归并排序"><a href="#自顶向下的归并排序" class="headerlink" title="自顶向下的归并排序"></a>自顶向下的归并排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = a.length;</span><br><span class="line">    Comparable[] aux = <span class="keyword">new</span> Comparable[n];</span><br><span class="line">    sort(a, aux, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, Comparable[] aux, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// If array size is 1 then return.</span></span><br><span class="line">	<span class="keyword">if</span> (hi &lt;= lo)    <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// Find the middle point to divide array into two halves.</span></span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// Call the mergeSort for first half.</span></span><br><span class="line">    sort(a, aux, lo, mid);</span><br><span class="line">    <span class="comment">// Call the mergeSort for second half.</span></span><br><span class="line">    sort(a, aux, mid+<span class="number">1</span>, hi);</span><br><span class="line">    <span class="comment">// Merge two halves sorted.</span></span><br><span class="line">    merge(a, aux, lo, mid, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自顶向下归并结果轨迹 : [from algs4]</p>
<p><img data-src="mergeSort_ubSort_1.png" alt="自顶向下归并结果轨迹"></p>
<p>自顶向下归并排序调用轨迹 : [from algs4]</p>
<p><img data-src="mergeSort_ubSort_2.png" alt="自顶向下归并排序调用轨迹"></p>
<blockquote>
<p><strong>命题 F: 对于长度为 $N$ 的任意数组， 自顶向下归并排序需要 $1/2NlgN$ 至 $NlgN$ 次比较。</strong></p>
<p>自顶向下的所需时间表达式为 : $T(N) = 2T(N/2) + O(n)$使用解决递归式的 <code>Master method</code> 解得 $T(N) = \Theta(n log n)$</p>
</blockquote>
<p>我们可以通过下图来理解命题F, 每个节点都表示一个<code>sort()</code>方法通过<code>merge()</code>方法归并而成的子数组。<strong>这棵树正好有 $n$ 层。对于$0 ~ n-1$ 之间的任意 $k$, 自顶向下的第 $k$ 层有 $2^k$个子数组，每个数组长度为 $2^{n-k}$, 归并最多需要 $2^{n-k}$ 次比较。</strong>因此每层的比较次数为$2^k X 2^{n-k} = 2^n$, n 层总共为 $n2^n = NlgN$。</p>
<p>子数组树状图 : [from algs4]</p>
<p><img data-src="mergeSort_ubSort_3.png" alt="子数组树状图"></p>
<blockquote>
<p><strong>命题 G : 对于长度为 $N$ 的任意数组，自顶向下的归并排序最多需要访问数组 $6NlgN$ 次。</strong></p>
<p>证明： 每次归并最多需要访问数组 $6N$ 次（$2N$ 次用来复制， $2N$次用来将排好序的元素移动回去，另外最多比较$2N$次），根据<strong>命题F</strong>即可得到这个命题的结果。</p>
</blockquote>
<p><strong>[小结]</strong>: 归并排序排序算法的缺点是辅助数组所使用的额外空间和N的大小成正比。一些能够大幅度缩短归并排序的运行时间的想法：</p>
<ul>
<li>对小规模子数组进行插入排序；</li>
<li>测试数组是否已经有序；</li>
<li>不将元素复制到辅助数组中。</li>
</ul>
<h3 id="自底向上的归并排序"><a href="#自底向上的归并排序" class="headerlink" title="自底向上的归并排序"></a>自底向上的归并排序</h3><p>实现归并排序另外一种方法是<strong>先归并那些微型数组， 然后再成对归并得到的子数组，直到将整个数组归并在一起</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeBU</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = a.length;</span><br><span class="line">    Comparable[] aux = <span class="keyword">new</span> Comparable[n];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; n; sz += sz) &#123;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> lo = sz; lo &lt; n-sz; lo += sz+sz) &#123;</span><br><span class="line">        	merge(a, aux, lo, lo+sz-<span class="number">1</span>, Math.min(lo+sz+sz-<span class="number">1</span>, n-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>[注] : 自底向上的归并排序会多次遍历整个数组，根据子数组大小进行两两归并。子数组的大小 sz 的初始值为 1， 每次加倍。最后一个子数组的大小只有在数组大小是 sz 的偶数倍的时候才会等于 sz(否则它会比sz小)。</p>
<p>自底向上归并排序结果轨迹 ： [from algs4]</p>
<p><img data-src="mergeSort_buSort_1.png" alt="自底向上归并排序结果轨迹"></p>
<blockquote>
<p><strong>命题 H : 对于长度为 $N$ 的任意数组， 自底向上的归并排序需要 $1/2NlgN$ 至 $NlgN$次比较，最多访问数组 $6NlgN$ 次。</strong></p>
<p>证明 ： 处理一个数组的遍数正好是 $lgN$(即 $2^n &lt;= N &lt;2^n+1$ 中的 $n$)。每一遍会访问数组6N次。比较次数在 $N/2$ 和 $N$ 之间。</p>
</blockquote>
<p>【补充】： 当数组长度为 2 的幂时，自顶向下和自底向上的归并排序所用的比较次数和数组访问次数正好相同，只是顺序不同。其他时候，两种方法的比较和数组访问的次序会有所不同。</p>
<h3 id="NOTICE"><a href="#NOTICE" class="headerlink" title="NOTICE"></a>NOTICE</h3><p>本文中，涉及的算法详细实现和使用，请移步到github<a href="https://github.com/rovo98/ds-and-algs#sorting-algorithms----go-back-to-top">查看</a>。</p>
]]></content>
      <categories>
        <category>Algorithms</category>
        <category>sorting algs</category>
      </categories>
      <tags>
        <tag>sorting algs</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序 - quickSort</title>
    <url>/posts/d9de8e4c/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>快速排序的主要特点是：</p>
<ol>
<li>原地排序 (in-place);</li>
<li>将长度为 N 的数组排序所需的时间和NlgN成正比；</li>
<li>排序内循环比大多数排序算法都要短小，意味着无论是在理论上还是实际中都要更快。</li>
</ol>
<p>缺点：<br>    快速排序非常的脆弱，在实现时要非常小心才能避免低劣的性能。</p>
<h3 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h3><p>快速排序是一种<strong>分治</strong>排序算法，它将一个数组分成两个子数组，将两部分独立地排序。不同于归并排序，快速排序的递归调用发生在处理子数之前。</p>
<p>快速排序方法抽象实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick</span> </span>&#123;</span><br><span class="line">	<span class="comment">// quick sort java implement.</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    	sort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (hi &lt;= lo)	<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> j = partition(a, lo, hi);</span><br><span class="line">        sort(a, lo, j-<span class="number">1</span>);</span><br><span class="line">        sort(a, j+<span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">partition</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> i = lo;</span><br><span class="line">        <span class="keyword">int</span> j = hi + <span class="number">1</span>;</span><br><span class="line">        Comparable v = a[lo];</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        	<span class="keyword">while</span> (less(a[++i], v)) &#123;</span><br><span class="line">            	<span class="keyword">if</span> (lo == hi) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (less(v, a[--j])) &#123;</span><br><span class="line">            	<span class="keyword">if</span> (j == lo) <span class="keyword">break</span>; <span class="comment">// redundant since a[lo] is sentinel.</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Check if pointers cross.</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt;= i)	<span class="keyword">break</span>;</span><br><span class="line">            exch(a, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        exch(a, lo, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述切分方法示意图: [from algs4]</p>
<p><img data-src="quickSort_partition_1.png" alt="切分示意图"></p>
<p>切分轨迹图: [from algs4]</p>
<p><img data-src="quickSort_partition_2.png" alt="切分轨迹图"></p>
<blockquote>
<p><strong>命题 K</strong>： 将长度为N的无重复的数组排序，快速排序平均需要 ~ $2NlnN$ 次比较(以及$1/6$的交换)</p>
</blockquote>
<p><strong>[notice]</strong>: 尽管快速排序有很多优点，它的基本实现仍有一个潜在的缺点：</p>
<p>在切分不平衡时该算法可能及其低效。例如： 如果第一个次从最小的元素切分，第二次从第二小的元素切分，则这样每次只会移除一个元素。<br>[solution] : <strong>在快速排序之前将数组随机排序可以避免这种情况的发生</strong>。</p>
<h3 id="算法改进"><a href="#算法改进" class="headerlink" title="算法改进"></a>算法改进</h3><h4 id="1-切换到插入排序"><a href="#1-切换到插入排序" class="headerlink" title="1.切换到插入排序"></a>1.切换到插入排序</h4><p>和大多数递归排序算法一样(如归并)，改进快速排序的简单方法基于以下两点：</p>
<ul>
<li>对于小数组，快速排序比插入排序慢；</li>
<li>以为递归，快速排序的sort()方法在小数组中也会调用自己。</li>
</ul>
<p>改进 ： 将<strong>sort()方法</strong>中的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<p>改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (hi &lt;= lo + M) &#123;</span><br><span class="line">	insertion.sort(a, lo, hi);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[<strong>notice</strong>] : 这里的切换参数 M 的最佳值是和系统相关的，但是5 ~ 15 之间的任意值在大多数情况下都能令人满意。</p>
<h4 id="2-三取样切分"><a href="#2-三取样切分" class="headerlink" title="2. 三取样切分"></a>2. 三取样切分</h4><p>改进快速排序性能的第二个方法是<strong>使用子数组的一小部分的中位数来切分数组</strong>。这样的切分的效果更好，但代价是需要计算中位数。</p>
<ul>
<li>人们发现将取样设为 3 并用大小居中的元素切分效果<strong>最好</strong>； 我们还可以将取样元素放在数组末尾作为哨兵(sentinel)。</li>
</ul>
<p>三取样切分抽象实现 : <a href="https://github.com/rovo98/ds-and-algs/blob/master/ds/sorting/exercises/QuickSortImprovedTwo.java">详细查看</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortImproved</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">	sort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> staic <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">	dealPivot(a, lo, hi);</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">int</span> j = hi - <span class="number">1</span>;</span><br><span class="line">    Comparable v = a[hi - <span class="number">1</span>]; <span class="comment">// set the  pivot at hi -1 as a sentinel.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    	<span class="keyword">while</span> (less(a[++i], v)) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (i == hi-<span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">// redundant since a[hi - 1] is sentinel.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; lo &amp;&amp; less(v, a[--j])) &#123;  &#125;</span><br><span class="line">        </span><br><span class="line">       	<span class="comment">// check if pointers cross.</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt;= i) <span class="keyword">break</span>;</span><br><span class="line">        exch(a, i, j);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (i &lt; hi-<span class="number">1</span>) &#123;</span><br><span class="line">   	exch(a, i, hi - <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   sort(a, lo, i - <span class="number">1</span>);</span><br><span class="line">   sort(a, i + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 三取样并将切分元素放在数组末尾</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dealPivot</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (less(a[mid], a[lo]))</span><br><span class="line">    	exch(a, lo, mid);</span><br><span class="line">    <span class="keyword">if</span> (less(a[hi], a[lo]))</span><br><span class="line">    	exch(a, lo, hi);</span><br><span class="line">    <span class="keyword">if</span> (less(a[hi], a[mid]))</span><br><span class="line">    	exch(a, mid, hi);</span><br><span class="line">    <span class="comment">// put the pivot to hi - 1 as a sentinel.</span></span><br><span class="line">    exch(a, mid, hi - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="熵最优的排序"><a href="#熵最优的排序" class="headerlink" title="熵最优的排序"></a>熵最优的排序</h4><p>实际应用中经常会出现含有大量重复元素的数组，我们实现的快速排序性能尚可，但是<strong>还有巨大的改进空间</strong>。例如：一个元素全部重复的子数组就不需要继续排序了，但我们的快速排序还是会继续将它切分为更小的数组。</p>
<p>[solution] : <strong>一个简单想法是将数组切分为三个部分，分别为小于、等于和大于切分元素的数组元素</strong>。</p>
<p>DIjkstra 解法 ： 从左到右遍历数组一次，维护一个指针 lt 使得 a[lo .. lt-1]中的元素都小于v, 一个 gt 使得a[gt+1 .. hi]中的元素都大于v, 一个指针 i 使得a[lt .. i-1]中的元素都等于v, a[i .. gt]中的元素都未确定。</p>
<ul>
<li>a[i] 小于 v, 将a[lt]和a[i]交换，将lt 和 i加一；</li>
<li>a[i] 大于 v, 将a[gt]和a[i]交换， 将gt减一；</li>
<li>a[i] 等于 v, i++.</li>
</ul>
<p>熵最优排序抽象实现： <a href="https://github.com/rovo98/ds-and-algs/blob/master/ds/sorting/exercises/Quick3Ways.java">详细查看</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">	sort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">    Comparable v = a[lo];</span><br><span class="line">    <span class="keyword">int</span> lt = lo;</span><br><span class="line">    <span class="keyword">int</span> i = lo + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> gt = hi;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= gt) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (less(a[i], v)) 	exch(a, i++,  lt++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (less(v, a[i]))	exch(a, gt--, i);</span><br><span class="line">        <span class="keyword">else</span> 		i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// since a[lt .. i-1] is sorted.</span></span><br><span class="line">    <span class="comment">// sort the other subarrays recursively.</span></span><br><span class="line">    sort(a, lo, lt-<span class="number">1</span>);</span><br><span class="line">    sort(a, gt+<span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[notice] : <strong>三向切分的最坏情况是所有主键均不相同。</strong>对于标准的快速排序，随着数组规模的增大其运行时间会趋于平均时间，大幅偏离的情况是非常罕见的，因此可以肯定<strong>三向切分的快速排序运行时间和输入的信息量的N倍是成正比的。</strong> ———— 因为对于包含大量重复元素的数组，它将排序时间从线性对数级降到了线性级别。</p>
<h3 id="NOTICE"><a href="#NOTICE" class="headerlink" title="NOTICE"></a>NOTICE</h3><p>本文中，涉及的算法详细实现和使用，请移步到github<a href="https://github.com/rovo98/ds-and-algs#sorting-algorithms----go-back-to-top">查看</a>。</p>
]]></content>
      <categories>
        <category>Algorithms</category>
        <category>sorting algs</category>
      </categories>
      <tags>
        <tag>sorting algs</tag>
      </tags>
  </entry>
  <entry>
    <title>Union-Find -- 动态连通性问题算法</title>
    <url>/posts/b3f33dac/</url>
    <content><![CDATA[<p><code>union-find</code>算法主要用于解决动态连通性问题。</p>
<span id="more"></span>
<p>我们设计算法时面对的第一个任务就是<strong>精确地定义问题</strong>。为了说明问题，通常会设计一份<code>API</code>来封装所需的基本操作。</p>
<h2 id="UF-API"><a href="#UF-API" class="headerlink" title="UF API"></a>UF API</h2><p>根据Union Find 算法需求定义接口 - </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Method</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">UF(int n)</td>
<td style="text-align:center">以整数标识(0到n-1)初始化n个触点</td>
</tr>
<tr>
<td style="text-align:center">int find(int p)</td>
<td style="text-align:center">p所在分量的标识符</td>
</tr>
<tr>
<td style="text-align:center">void union(int p, int q)</td>
<td style="text-align:center">在p和q之间增加一条连接</td>
</tr>
<tr>
<td style="text-align:center">boolean connected(int p, int q)</td>
<td style="text-align:center">如果p和q存在于同一个分量返回true</td>
</tr>
<tr>
<td style="text-align:center">int count()</td>
<td style="text-align:center">连通分支的数量</td>
</tr>
</tbody>
</table>
</div>
<p>此时，解决动态连通性问题设计算法的问题已经被我们转化为实现这份API。</p>
<ul>
<li>定义一种数据结构表示已知的连接</li>
<li>基于此数据结构实现高效的<code>union()</code>、<code>find()</code>、<code>connected()</code>和<code>count()</code>方法</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    	parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        count = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        	parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> ...</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> ...</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="第一种实现方式-quick-find算法"><a href="#第一种实现方式-quick-find算法" class="headerlink" title="第一种实现方式: quick-find算法"></a>第一种实现方式: quick-find算法</h3><p>   这种实现方式保证当且仅当<code>parent[p] == parent[q]</code>时<code>p</code>和<code>q</code>是连通的。即在同一个连通分支的所有触点在<code>parent[]</code>中的值必须全部相同。 也意味着<code>connected(p, q)</code>只需要判断<code>parent[p] == parent[q]</code>，只有在<code>p</code>和<code>q</code>所在连通分支相同时返回<code>true</code>,否则<code>p</code>所在连通分支的所有触点对应<code>parent[]</code>中的值为一个值，而q所在连通分支的所有触点对应<code>parent[]</code>中的值为另一个值。因此我们在合并分量时需要<strong>遍历整个数组</strong>来将所有和<code>parent[p]</code>相等的元素变为<code>parent[q]</code>，或者反过来。<br>由此实现的<code>find()</code>、<code>union()</code>方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> parent[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rootP = find(p);</span><br><span class="line">    <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">    <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parent.length; i++) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (parent[i] == rootQ) parent[i] = rootP;</span><br><span class="line">    &#125;</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="quick-find-算法分析"><a href="#quick-find-算法分析" class="headerlink" title="quick-find 算法分析"></a>quick-find 算法分析</h4><blockquote>
<p><code>find()</code> 操作速度显然是很快的，因为它只需要访问<code>parent[]</code>数组一次。但quick-find算法一般无法处理大型问题，因为对于每一对输入的触点 <code>union()</code>都需要扫描整个<code>parent[]</code>数组。可以看出此算法的时间复杂度应该为：$O(n^2).$</p>
<p><strong>命题F: 在quick-find 算法中，每次<code>find()</code> 调用只需要访问数组一次，而归并两个分量的<code>union()</code>操作访问数组的次数在$(N+3)$到$(2N+1)$之间。</strong></p>
</blockquote>
<h3 id="第二种实现方式：-quick-union算法"><a href="#第二种实现方式：-quick-union算法" class="headerlink" title="第二种实现方式： quick-union算法"></a>第二种实现方式： quick-union算法</h3><p>该算法的重点是在于提高 <code>union()</code>方法的速度，它和 quick-find 都是基于相同的数据结构 —— 以触点为索引的 <code>parent[]</code> 数组，在此之上，我们用它们来定义更加复杂的结构。令每个触点所对应的 <code>parent[]</code> 元素都是同一个分量中的另一触点名称（也可能是它自己) — 这种联系称为<strong>链接</strong>。</p>
<p>在实现<code>find()</code>方法时，从给定的触点开始，由它的链接得到另一个触点，再由这个触点的链接到达第三个触点，直到随着链接到达<strong>根触点，链接指向自己的触点</strong>。<br>而对于实现<code>union()</code>方法，只需有由p和q的链接分别去找它们的根触点，然后只需要将一个跟触点链接到另一个即可。由此实现的<code>find()</code>、<code>union()</code>方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (p != parent[p]) &#123;</span><br><span class="line">    	p = parent[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rootP = find(p);</span><br><span class="line">    <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">    <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">    parent[rootP] = parent[rootQ];</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="quick-union-算法分析"><a href="#quick-union-算法分析" class="headerlink" title="quick-union 算法分析"></a>quick-union 算法分析</h4><blockquote>
<p>在quick-union 中<code>parent[]</code>数组用父链接的形式表示的一片森林。quick-union 算法明显比quick-find 算法更快，因为它不需要为每一对输入遍历整个数组。</p>
</blockquote>
<p>在最好的情况下，<code>find()</code>只需要访问一次数组就能得到一个触点所在的分量的标识符；而在最坏的情况下，需要$2N - 1$次数组访问。<br><strong>我们可以把quick-union看作是quick-find算法的改进</strong>。—— 它将<code>union()</code>操作改进为线性级别。</p>
<blockquote>
<p><em>定义： 一棵树的大小是它的节点的数量。树中的一个节点的深度是它到根节点的路径的链接数。树的高度是它的所有节点的最大深度。</em></p>
<p><strong>命题G: quick-union 算法中的 find() 方法访问数组的次数为1 加上给定触点所对应的节点的深度的两倍。<code>union()</code> 和 <code>connected()</code> 访问数组的次数为两次 <code>find()</code>操作 （如果 union() 中给定的两个触点分别存在于不同的树中则还需要加 1).</strong></p>
</blockquote>
<p><strong>由命题G我们可以知道算法在最坏的情况下的运行时间是平方级别的。</strong><br>例如：输入的整数对为$0-1、0-2、0-3$等，$N-1$ 对之后，$N$ 个触点将全部处于相同的集合之中且由quick-union算法得到的树的高度为 $N-1$, 其中0链接到2, 2链接到3，如此下去。由命题G可知，对于整数对 $0 - i$, <code>union()</code> 操作访问数组的次数为$2i + 2$ （触点0的深度为i, 触点 i 的深度为 0）。 处理 N 对整数所需的所有 <code>find()</code> 操作访问数组的总次数为 $2(1+2+…+N)~N^2$。</p>
<h3 id="第三种实现方式：-加权quick-union算法"><a href="#第三种实现方式：-加权quick-union算法" class="headerlink" title="第三种实现方式： 加权quick-union算法"></a>第三种实现方式： 加权quick-union算法</h3><p>改进quick-union算法，不再随意在<code>union()</code>中将一棵树连接到另一颗树，而是<strong>记录树的大小(节点个数)或高度并总是将较小的树连接到较大的树上</strong>。</p>
<ul>
<li>记录树的大小(节点个数)加权</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</span><br><span class="line">    <span class="keyword">private</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    	parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        count = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        	parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">while</span> (p != parent[p]) &#123;</span><br><span class="line">        	parent[p] = parent[parent[p]]; <span class="comment">// 路径压缩</span></span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 将较小的树连接到较大的树上</span></span><br><span class="line">        <span class="keyword">if</span> (rank[rootP] &gt; rank[rootQ]) &#123;</span><br><span class="line">        	parent[rootQ] = rootP;</span><br><span class="line">            rank[rootP] += rank[rootQ];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	parent[rootP] = rootQ;</span><br><span class="line">            rank[rootQ] += rank[rootP];</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>记录树的高度</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] rank;</span><br><span class="line">    <span class="keyword">private</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    	parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="keyword">byte</span>[n];</span><br><span class="line">        count = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        	parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">while</span> (p != parent[p]) &#123;</span><br><span class="line">        	parent[p] = parent[parent[p]];</span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 将高度较低的树连接到高度较高的树上</span></span><br><span class="line">        <span class="keyword">if</span> (rank[rootP] &gt; rank[rootQ]) &#123;</span><br><span class="line">        	parent[rootQ] = rootP;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootP] &lt; rank[rootQ]) &#123;</span><br><span class="line">        	parent[rootP] = rootQ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        	parent[rootQ] = rootP;</span><br><span class="line">            rank[rootP]++;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="加权quick-union-算法分析"><a href="#加权quick-union-算法分析" class="headerlink" title="加权quick-union 算法分析"></a>加权quick-union 算法分析</h4><blockquote>
<p><strong>命题H: 对于 $N$ 个触点，加权 quick-union 算法构造的森林中的任意节点的深度最多为 $lgN$。</strong></p>
<p>推论: 对于加权 quick-union 算法和 N 个触点， 在最坏的情况下 <code>find()</code>、 <code>connected()</code> 和 <code>union()</code> 的成本的增长数量级为 $log N$。</p>
</blockquote>
<p>union-find 的具体实现: <a href="https://github.com/rovo98/ds-and-algs#uf----go-back-to-top">查看</a></p>
]]></content>
      <categories>
        <category>Algorithms</category>
        <category>Union Find</category>
      </categories>
      <tags>
        <tag>union-find</tag>
      </tags>
  </entry>
  <entry>
    <title>Singleton Design pattern</title>
    <url>/posts/a10d2fff/</url>
    <content><![CDATA[<p>最近在看 『Refacting to Patterns』，结合之前看的 Test Driven-Practical TDD and Acceptance TDD for Java Developers 提到的测试驱动开发（TDD）。虽然早些时候，我已经有对一些设计模式有一定了解，但只有对创建型的设计模型有所应用，比如Singleton、Builder、Factory、AbstractFactory。而其他的行为型和结构型的设计模型，只有在阅读一些源代码的时候偶尔才有看到，如 Java 集合框架中使用的 Iterator 模式，然而自己却很少使用。</p>
<p>为了更好地执行 TDD 过程中的重构，以及看懂优秀项目的源代码，我觉得我有必要开始重新更深入地学习设计模式。</p>
<p>单例模式，即 Gof （Gangs of Four）设计模式中创建型（Creational）设计模式之一。用于限制类的实例化，它只允许当前 JVM 执行上下文中只能拥有限制类的一个实例。从定义来看，似乎它的实现应该比较简单，但是在实际实现时，它有许多需要注意的点。在 Java 中，光它实现方式现已有许多种。因此，本文将介绍单例模式的实现方法，简单分析每一种方法的优缺点，最后，再说明应用单例模式时可能遇到的问题以及相应解决办法。</p>
<span id="more"></span>
<h2 id="1-单例模式实现方式"><a href="#1-单例模式实现方式" class="headerlink" title="1. 单例模式实现方式"></a>1. 单例模式实现方式</h2><h3 id="1-1-饿汉式"><a href="#1-1-饿汉式" class="headerlink" title="1.1 饿汉式"></a>1.1 饿汉式</h3><p>在饿汉式的实现中，单例类的实例在类加载的时候创建，即类初始化对静态成员变量初始化时，创建该类的实例。这是最简单的实现方式，但却存在明显的缺点，它不管应用程序是否需要该类的实例，就创建相应的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EagerSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EagerSingleton INSTANCE = <span class="keyword">new</span> EagerSingleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this class can not be instanced.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EagerSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EagerSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果该类的实例不是一个大对象时，若我们容忍应用程序在运行时，该对象的实例存在但不使用，则该实现方式将是最佳方案。</p>
<h3 id="1-2-静态代码块"><a href="#1-2-静态代码块" class="headerlink" title="1.2 静态代码块"></a>1.2 静态代码块</h3><p>与饿汉式实现相似，同样地，类加载时，在初始化（initialization）阶段除了对静态成员变量进行初始化外，还会执行静态代码块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticBlockSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StaticBlockSingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticBlockSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> StaticBlockSingleton();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Exception occured in creating singleton instance!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticBlockSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式和饿汉式存在相同的问题，它不管应用程序是否需要该类的实例，在类加载时，相应的实例就会被创建。</p>
<h3 id="1-3-懒汉式"><a href="#1-3-懒汉式" class="headerlink" title="1.3 懒汉式"></a>1.3 懒汉式</h3><p>不同于饿汉式，懒汉式实现方式将实例的创建延迟到 <code>getInstance</code> 方法调用时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，在实例被真正需要才创建是一种非常好的策略，当创建该类的实例是一个较昂贵的操作时，它比饿汉式表现更好。上面的代码可以在单线程环境下正常执行，但在多线程环境下，单例模式将被破坏，可能会有多个线程同时进入 <code>if</code> 代码块，导致多个实例被创建出来。为此，我们可能还需要线程安全的实现方式。</p>
<h3 id="1-4-线程安全式"><a href="#1-4-线程安全式" class="headerlink" title="1.4 线程安全式"></a>1.4 线程安全式</h3><h4 id="1-4-1-synchronized"><a href="#1-4-1-synchronized" class="headerlink" title="1.4.1 synchronized"></a>1.4.1 synchronized</h4><p>实现线程安全的最简单方式是，在懒汉式实现的基础上，对 <code>getInstance</code> 方法使用 <code>synchronized</code> 关键字进行修饰即可。这样可以确保某一时间只有一个线程可以执行该方法，其他的线程需要等待该执行线程释放该类的锁对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SynchronizedSingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SynchronizedSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SynchronizedSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SynchronizedSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-4-2-double-checking"><a href="#1-4-2-double-checking" class="headerlink" title="1.4.2 double-checking"></a>1.4.2 double-checking</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckingSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DoubleCheckingSingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheckingSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckingSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckingSingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> DoubleCheckingSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双重检查机制——在使用 <code>synchronized</code> 关键字同步创建单例的代码块的时候，需要在同步的代码块再次使用 <code>if</code> 来判断实例是否已经创建。因为可能存在多个线程进入第一个 <code>if</code> 块，然后阻塞等待，如果没有在 <code>synchronized</code> 块中多设置一个 <code>if</code> 来判断实例是否创建，此时将破坏单例模型的原则。</p>
<div class="note warning"><p>注意上面的两个实现都应该使用 <code>volatile</code> 关键字来修饰单例成员（避免其他线程在实例创建之前引用该变量，而在之后运行时出现 <code>NPE</code> 异常）。</p>
</div>
<h3 id="1-5-静态内部类——Bill-Pugh-Singleton"><a href="#1-5-静态内部类——Bill-Pugh-Singleton" class="headerlink" title="1.5 静态内部类——Bill Pugh Singleton"></a>1.5 静态内部类——Bill Pugh Singleton</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillPughSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonHolder &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BillPughSingleton INSTANCE = <span class="keyword">new</span> BillPughSingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BillPughSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BillPughSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该实现方式主要利用 Java 的加载和初始化过程，loading -&gt; Linking -&gt; Initialization。其中初始化阶段主要是初始化静态成员变量并执行静态代码块。因此，<code>BillPughSingleton</code> 只有在执行 <code>getInstance()</code> 方法时，才会将 <code>SingletonHolder</code> 加载到方法区中（method area），再对其静态成员变量进行初始化。</p>
<h3 id="1-6-枚举-Enum-Singleton"><a href="#1-6-枚举-Enum-Singleton" class="headerlink" title="1.6 枚举-Enum Singleton"></a>1.6 枚举-Enum Singleton</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Enum EnumSingleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据 Java 对 <code>Enum</code> 的实现文档，<code>Enum</code> 隐式地保证了线程安全以及单例。因此，使用枚举来实现单例模式也是一个不错的选择。</p>
<h2 id="2-序列化问题"><a href="#2-序列化问题" class="headerlink" title="2. 序列化问题"></a>2. 序列化问题</h2><p>虽然上面我们已经了解了许多单例模式的实现方式，但在实际使用的时候，我们有可能会遇到一些问题。例如：在序列化和反序列化时就有可能打破单例模式。我们看下面一个例子。</p>
<p><code>DemoSingleton.java</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">public</span> DemoSingleton implements Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> DemoSingleton INSTANCE = <span class="keyword">new</span> DemoSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DemoSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// this class will not be instanced</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DemoSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// protected Object readResolve() &#123;</span></span><br><span class="line">   <span class="comment">//     return SingletonHolder.INSTANCE;</span></span><br><span class="line">   <span class="comment">// &#125;</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setI</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>SerialzableProblem.java</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialzableProblem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> DemoSingleton instanceOne = DemoSingleton.getInstance();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// serialized to a file.</span></span><br><span class="line">            ObjectOutput out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;filename.ser&quot;</span>));</span><br><span class="line">            out.writeObject(instanceOne);</span><br><span class="line">            out.close();</span><br><span class="line"></span><br><span class="line">            instanceOne.setI(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// serialized to a file</span></span><br><span class="line">            ObjectInput in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;filename.ser&quot;</span>));</span><br><span class="line">            DemoSingleton instanceTwo =  (DemoSingleton) in.readObject();</span><br><span class="line">            in.close();</span><br><span class="line"></span><br><span class="line">            System.out.println(instanceOne.getI());</span><br><span class="line">            System.out.println(instanceTwo.getI());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Output:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">20</span><br><span class="line">10</span><br></pre></td></tr></table></figure></p>
<p>这意味着，JVM 环境中出现了 <code>DemoSingleton</code> 的多个实例。这种情况下，单例模式被打破。我们需要在 <code>DemoSingleton</code> 类中添加 <code>readResolve</code> 方法来解决找一个问题。</p>
<p>类在反序列化的时候会调用 <code>readResolve</code>，此时返回该类的唯一单例。</p>
<h2 id="3-最佳实践"><a href="#3-最佳实践" class="headerlink" title="3. 最佳实践"></a>3. 最佳实践</h2><p>最佳实践的代码模板，能解决线程安全问题和序列化反序列化可能破坏单例模式的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillPughSingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BillPughSingleton INSTANCE = <span class="keyword">new</span> BillPughSingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this class will not be instanced.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BillPughSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BillPughSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-用-Java-的反射来破坏单例模式"><a href="#4-用-Java-的反射来破坏单例模式" class="headerlink" title="4. 用 Java 的反射来破坏单例模式"></a>4. 用 Java 的反射来破坏单例模式</h2><p>通过使用反射（Reflection）可以破坏上面的所有单例模式实现方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectSingletonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BillPughSingleton instanceOne = BillPughSingleton.getInstance();</span><br><span class="line">        BillPughSingleton instanceTwo = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor[] constructors = BillPughSingleton.class.getDeclaredConstructors();</span><br><span class="line">            <span class="keyword">for</span> (Constrctor constructor : constructors) &#123;</span><br><span class="line">                <span class="comment">// Destroy the singleton pattern</span></span><br><span class="line">                constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                instanceTwo = (BillPughSingleton) constructor.newInstance();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(instanceOne.hashCode());</span><br><span class="line">        System.out.println(instanceTwo.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>References</p>
<ol>
<li><a href="https://howtodoinjava.com/design-patterns/creational/singleton-design-pattern-in-java/">https://howtodoinjava.com/design-patterns/creational/singleton-design-pattern-in-java/</a></li>
<li><a href="https://www.journaldev.com/1377/java-singleton-design-pattern-best-practices-examples">https://www.journaldev.com/1377/java-singleton-design-pattern-best-practices-examples</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>design-pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 项目构建提速</title>
    <url>/posts/4d39110c/</url>
    <content><![CDATA[<p>Maven 作为 Java 项目的一个常用构建工具，它很容易上手使用，但若不对其进行深入了解，则往往会在我们后续使用过程中留下一些隐患。<br>在日常开发环境中，我们很容易遇到较大代码规模的项目，涉及多种不同语言及技术，此时，在使用 Maven 作为主构建工具进行本地项目编译及构建时，则有可能会遇到项目构建速度慢的问题。为提升开发体验，本文将讨论 Maven 项目构建速度优化相关技巧。</p>
<span id="more"></span>
<h2 id="影响构建速度的因素"><a href="#影响构建速度的因素" class="headerlink" title="影响构建速度的因素"></a>影响构建速度的因素</h2><p>在 Maven 项目中，影响项目构建速度的因素有很多，常见的有以下几个因素：</p>
<h3 id="1、没有充分利用-CPU-等资源"><a href="#1、没有充分利用-CPU-等资源" class="headerlink" title="1、没有充分利用 CPU 等资源"></a>1、没有充分利用 CPU 等资源</h3><p>正常情况下，Maven 构建项目模块是按顺序执行的，然而，在大多项目中我们其实并不需要按序构建模块。理论上来说，Maven 可以通过依赖图来分析项目，并尽可能地并行构建项目模块。</p>
<h3 id="2、项目构建时包含许多无效的阶段和步骤"><a href="#2、项目构建时包含许多无效的阶段和步骤" class="headerlink" title="2、项目构建时包含许多无效的阶段和步骤"></a>2、项目构建时包含许多无效的阶段和步骤</h3><p>Maven 项目的构建由特定生命周期（Lifecycle）进行描述，一个生命周期一般包含多个阶段（phase），而一个阶段还可包含多个步骤（steps）。当执行某特定 phase 时，这过程中包含了一些隐性开销，为执行某一生命周期的特定阶段，Maven 需要先执行完该阶段之前的所有阶段。<br>如，对于 Maven 提供的默认生命周期（default，不与任何插件相关联），它包含的所有阶段如下：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">phases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">phase</span>&gt;</span>validate<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">phase</span>&gt;</span>initialize<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">phase</span>&gt;</span>generate-sources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">phase</span>&gt;</span>process-sources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">phase</span>&gt;</span>generate-resources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">phase</span>&gt;</span>process-resources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">phase</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">phase</span>&gt;</span>process-classes<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">phase</span>&gt;</span>generate-test-sources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">phase</span>&gt;</span>process-test-sources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">phase</span>&gt;</span>generate-test-resources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">phase</span>&gt;</span>process-test-resources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">phase</span>&gt;</span>test-compile<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">phase</span>&gt;</span>process-test-classes<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">phase</span>&gt;</span>test<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">phase</span>&gt;</span>prepare-package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">phase</span>&gt;</span>pre-integration-test<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">phase</span>&gt;</span>integration-test<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">phase</span>&gt;</span>post-integration-test<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">phase</span>&gt;</span>verify<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">phase</span>&gt;</span>install<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">phase</span>&gt;</span>deploy<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">phases</span>&gt;</span></span><br></pre></td></tr></table></figure><br>因此，当我们执行 <code>mvn install</code> 命令时，Maven 需要先执行 <code>install</code> 阶段之前的所有阶段后，才能执行该 <code>install</code> 阶段。</p>
<h3 id="3、网络访问影响"><a href="#3、网络访问影响" class="headerlink" title="3、网络访问影响"></a>3、网络访问影响</h3><p>和其他大部分构建系统一样，如 npm、gradle、sbt等，项目在构建时，往往需要连网去下载项目的依赖以及传递依赖。而当我们明确本地仓库缓存已经存在项目构建需要的所有依赖及传递依赖时，可选择让 maven 以离线方式运行。</p>
<h3 id="4、Maven-进程的启动速度"><a href="#4、Maven-进程的启动速度" class="headerlink" title="4、Maven 进程的启动速度"></a>4、Maven 进程的启动速度</h3><p>Maven 作为一个构建工具，也是一个运行在 JVM 上的 Java 程序，因此，它也可以通过对 JVM 进行优化配置，从而提升 Maven 的启动速度。</p>
<h2 id="提升构建速度的技巧"><a href="#提升构建速度的技巧" class="headerlink" title="提升构建速度的技巧"></a>提升构建速度的技巧</h2><p>针对上述提到的影响 Maven 项目构建速度的因素，可以使用以下技巧进行处理。</p>
<h3 id="1、Maven-并行构建"><a href="#1、Maven-并行构建" class="headerlink" title="1、Maven 并行构建"></a>1、Maven 并行构建</h3><p>为能在项目构建时充分的利用 CPU 资源， 我们可指定 maven 构建项目时使用的线程数。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn -T num <span class="comment"># 指定 maven 构建项目时使用的具体线程数</span></span><br><span class="line">mvn -T numC <span class="comment"># 指定 maven 构建项目时使用的线程数，每个 CPU num 个线程</span></span><br></pre></td></tr></table></figure><br>虽然项目尽管可能不容易进行并行构建，但值得尝试，因为它可以大大地提升项目构建的速度。设置<strong>每个 CPU 核使用一个线程是一个比较好的默认配置</strong>。</p>
<h3 id="2、跳过测试或并行执行测试"><a href="#2、跳过测试或并行执行测试" class="headerlink" title="2、跳过测试或并行执行测试"></a>2、跳过测试或并行执行测试</h3><p>从构建层面上来讲，测试可能是影响项目构建速度的最大因素。因此，我们通常会在构建工件时选择跳过测试，大多数插件可通过指定 <code>-DskipTests=true</code> 来跳过测试，但一般情况下，我们不推荐使用这种非常规的工程实践方案，仅在明确需要跳过测试时使用，很明显，这可以大大地提高项目构建的速度。<br>一般我们讨论的并行技术作用于模块级别，例如，当项目使用插件（如 surefire 等）来运行测试时，我们可以配置它在模块内进行并行执行。需要注意的是，使用并行技术来执行测试虽然可以大大提高项目构建的速度，但这一过程有可能导致一些副作用，但实际实践中，我们应该尽可能地尝试并行运行测试，在遇到错误时再进行相应处理即可。</p>
<h3 id="3、只构建必要的模块"><a href="#3、只构建必要的模块" class="headerlink" title="3、只构建必要的模块"></a>3、只构建必要的模块</h3><p>大多数人在构建项目时，可能会直接使用以下默认命令:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn clean install</span><br></pre></td></tr></table></figure><br>但正如上文提到的，但在执行 install 时，需要先之前该阶段前的所有阶段，当 Maven 执行 clean 时，会将所有生成的 artifacts 及临时文件等（除VCS管理的文件外）都清理掉。clean 在遇到奇怪的缓存或bug时很有用。</p>
<p>然而，每次项目修改后，都执行一次 clean，然后再 install 的速度并不理想，大多数情况下，我们应该是增量地构建项目，即仅构建变化的部分。举个例子，假设我们有一个多模块的项目，其中一些通用的核心模块几乎是不变的，则可以通过以下命令来只构建变动的模块：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn install -pl <span class="variable">$moduleName</span> -am</span><br></pre></td></tr></table></figure><br>首先，可以看到，因为项目很少需要清理，该命令移除了 <code>clean</code> 阶段，其他的 mvn 命令选项如下：</p>
<ul>
<li><code>-pl</code>，<code>--projects</code> : 由逗号分隔的项目列表，项目可由 <code>[groupId]:artifactId</code> 或相对目录表示。指定 Maven 需构建的模块，而不是构建整个项目。</li>
<li><code>-am</code>, <code>--also-make</code> : 当项目列表指定后，同时构建列表中项目的依赖项目。</li>
<li><code>-amd</code>, <code>--also-make-dependents</code>: 当项目列表指定后，同时构建依赖于列表项目的项目。</li>
</ul>
<p>结合以上选项使用 maven 命令可以大大地提高项目构建的速度及灵活度，这种情况下，只有工作的项目模块及相应的修改的依赖才会被构建，而其他大量的构建工作，由于文件仍是新的或不是目标模块的一部分，则无需重新构建，可以跳过。</p>
<h3 id="4、离线或限制网络访问"><a href="#4、离线或限制网络访问" class="headerlink" title="4、离线或限制网络访问"></a>4、离线或限制网络访问</h3><p>网络下载也是影响构建速度的一个重要因素，当然，在国内环境中，我们一般都配置 maven 库的镜像来下载依赖，可有效的提高依赖下载的网络速度，这一部分内容不是本文的关注点，读者可自行检索了解。</p>
<p>离线或限制网络访问均可以提升 Maven 项目构建的速度，但我们可能需要对它们的使用场景作一下限制：<br>对于离线构建，<code>mvn</code> 命令增加 <code>-o</code> 或 <code>--offline</code> 选项，需要明确项目所需的所有依赖及传递依赖均已缓存至本地仓库；<br>当网络质量不佳且需要联网构建时，则可在 <code>MAVEN_OPTS</code> 变量中增加 <code>-DdependendencyLocationsEnabled=false</code> 设置来尽可能地减少项目构建时进行的网络传输。</p>
<h3 id="5、提升-Maven-Java-进程的启动速度"><a href="#5、提升-Maven-Java-进程的启动速度" class="headerlink" title="5、提升 Maven Java 进程的启动速度"></a>5、提升 Maven Java 进程的启动速度</h3><p>Maven 作为一个 Java 应用程序，就意味着我们可以通过对 JVM 进行调优以提高 Maven 进程启动速度。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-XX:+TieredCompilation -XX:TieredStopAtLevel=1</span><br></pre></td></tr></table></figure><br>通过上述配置，可使 JVM 只执行基本的 jIT 编译，而不尝试去获取更多精确配置信息优化代码的执行。</p>
<blockquote>
<p>为提高 Maven 的构建速度，Maven 官方参考 Gradle 和 Takari 的技术，开发了 <a href="https://github.com/apache/maven-mvnd">maven-mvnd</a>。mvnd 会启动一个长时运行的守护进程来负责项目构建，并采用 GraalVM 开发 mvnd 的客户端，与传的 mvn 相比，启动速度更快且需要的内存更少。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要简单地讨论了影响 maven 项目构建速度的一些因素及一些提高 maven 构建速度的技巧。更多关于 maven 的理论知识及内容，可以前往 maven 官网查看，另外 <code>mvn</code> 命令行选项可以参考 <a href="http://maven.apache.org/ref/3.6.3/maven-embedder/cli.html。">http://maven.apache.org/ref/3.6.3/maven-embedder/cli.html。</a></p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><a href="https://www.jrebel.com/blog/how-to-speed-up-your-maven-build">https://www.jrebel.com/blog/how-to-speed-up-your-maven-build</a></li>
<li><a href="https://forgettingtocode.com/2019/01/23/readme-slow-maven-builds/">https://forgettingtocode.com/2019/01/23/readme-slow-maven-builds/</a></li>
<li><a href="https://mincong.io/2018/11/01/speed-up-the-maven-build/">https://mincong.io/2018/11/01/speed-up-the-maven-build/</a></li>
<li><a href="http://maven.apache.org/ref/3.6.3/maven-embedder/cli.html">http://maven.apache.org/ref/3.6.3/maven-embedder/cli.html</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>build-tools</tag>
      </tags>
  </entry>
</search>
