---
title: 正则表达式基本使用
author: rovo98
categories:
  - Python爬虫
tags:
  - regex基础
  - 学习笔记
abbrlink: f85f3c07
date: 2017-03-15 13:12:38
---

regular expression regex  RE

简介

正则表达式是用来**简洁**表达一组字符串的表达式。

> 正则表达式——一行胜千言

- 通用的字符串表达框架
- 简洁表达一组字符串的表达式
- 针对字符串表达“简洁”和“特征”思想的工具
- 判断某一字符串的特征归属

<!-- more -->

### 正则表达式在文本处理中十分常用

- 表达文本类型的特征(病毒、入侵等)
- 同时查找或替换一组字符串
- 匹配字符串的全部或部分
-  **正则表达式主要应用在字符串的匹配中**

### 正则表达式的使用

- 编译：将符合正则表达式语法的字符串转换成正则表达式特征。—— re.compile(regex)

### 正则表达式的语法

#### 正则表达式常用的操作符

|  操作符  |        说明        |              实例              |
| :---: | :--------------: | :--------------------------: |
|   .   |     表示任何单个字符     |                              |
|  [ ]  | 字符集，对单个字符给出取值范围  | [abc]表示a、b、c, [a-z]表示a到z单个字符 |
| \[^ ] | 非字符集，对单个字符给出排除范围 |     \[^abc]表示非a或b或c的单个字符      |
|   *   |  前一个字符0次或无限次扩展   |   abc*表示ab、abc、abcc、abcc等    |
|   +   |  前一个字符1次或无限次扩展   |    abc+表示abc、abcc、abccc等     |
|   ?   |   前一个字符0次或1次扩展   |         abc?表示ab、abc         |
|  &#124;   |    左右表达式任意一个     |      abc &#124; def表示abc、def       |

|  操作符  |         说明          |               实例                |
| :---: | :-----------------: | :-----------------------------: |
|  {m}  |      扩展前一个字符m次      |          ab{2}c表示abbc           |
| {m,n} |     扩展前一个字符m至n次     |       ab{1,2}c表示abc、abbc        |
|   ^   |       匹配字符串开头       |       ^abc表示abc且在一个字符串的开头       |
|   $   |       匹配字符串结尾       |       abc$表示abc且在一个字符串的结尾       |
|  ( )  |  分组标记，内部只能使用 &#124; 操作符   | (abc)表示abc ，(abc&#124;def)表示abc、def |
|  \d   |     数字，等价于[0-9]     ||
|  \w   | 单词字符，等价于[A-Za-z0-9] ||

#### 经典正则表达式实例

|       ^[A-Za-z]+$        |  由26个字母组成的字符串   |
| :----------------------: | :-------------: |
|      ^[A-za-z0-9]+$      | 由26个字母及数字组成的字符串 |
|         ^-?\d+$          |    整数形式的字符串     |
|  ^[0-9]\*\[1-9][0-9]*$   |    正整数形式的字符串    |
|        [1-9]\d{5}        |  中国境内的邮政编码，6 位  |
|     [\u4e00-\u9fa5]      |     匹配中文字符      |
| \d{3}-\d{8} &#124; \d{4}-\d{7} |      国内电话       |

IP地址:

- 不精确的写法：
  - \d+.\d+.\d+.\d+  —— 以四个点进行分隔作为特点
  - \d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}
- 精确写法：
  0-99 : [0-9]?\d		100-199 : 1\d{2}
  200-249 : 2[0-4]\d   250-255 : 25[0-5]
  (([0-9]?\d|1\d{2}|2[0-4]\d|25[0-5]).){3}([0-9]?\d|1\d{2}|2[0-4]\d|25[0-5])


### Re库的基本使用

#### Re库介绍

Re库是Python的标准库，主要用于字符串匹配。

```python
import re
```

#### 正则表达式的表示类型

- raw string 类型(原生字符串类型) —— 不包含转义字符
  re 库采用raw string 类型表示正则表达式，表示为：r'text'
- string类型， 更繁琐  —— 需要双重转义

#### Re库的主要功能函数

|       函数       |                说明                |
| :------------: | :------------------------------: |
|  re.search()   | 在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象 |
|   re.match()   |   在一个字符串开始位置起匹配正则表达式，返回match对象   |
|  re.findall()  |      搜索字符串，以列表类型返回全部能匹配的子串       |
|   re.spilt()   |   将一个字符串按照正则表达式匹配结果进行分割，返回列表类型   |
| re.fiinditer() | 搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match |
|    re.sub()    | 在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串  |

##### re.search(pattern, string,flags=0)

- 在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象
  - pattern:  正则表达式的字符串或者原生字符串 表示
  - string : 待匹配字符串
  - flags : 正则表达式使用时的控制标记


|        常用标记        |                 说明                 |
| :----------------: | :--------------------------------: |
| re.I re.IGNORECASE |     忽略正则表达式的大小写，[A-Z]能够匹配小写字符      |
| re.M RE.MULTILINE  |    正则表达式中的^操作符能够将给定字符串的每行当作匹配开始    |
|  re.S   RE.DOTALL  | 正则表达式中的.操作符能够匹配所有字符，默认匹配除换行符外的所有字符 |

##### re.match(partern, string, flags=0)

- 从一个字符串的开始位置起匹配正则表达式，返回match对象

##### re.findall(pattern, string , flags=0)

- 搜索字符串，以列表类型返回全部能匹配的子串。
  - pattern ： 正则表达式的字符串或原生字符串表示
  - string ： 待匹配字符串
  - flags: 正则表达式使用时的控制标记

##### re.split(pattern, string, maxsplit=0, flags=0)

- 将一个字符串按照正则表达式匹配结果进行分割，返回列表类型。
  - maxsplit: 最大分割数

##### re.finditer(patern, string, flags=0)

- 搜索字符串，返回一个匹配结果的迭代类型，每一个迭代元素是match对象。

##### re.sub(pattern, repl, string, count=0, flags=0)

- 在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串。
  - repl: 替换匹配字符串的字符串
  - count： 替换的最大次数

##### Re库的另一种等价用法

```python
rst = re.search(r'[1-9]\d{5}', 'BIT100081')
#函数式用法： 一次性操作


#面向对象用法：编译后的多次操作
pat = re.compile(r'[1-9]\d{5}')
rst = pat.search('BIT100081')
```

##### regex  = re.compile(pattern, flags=0)

- 将正则表达式的字符串形式编译成正则表达式对象

#### Re库的match对象

##### Match对象的属性

|   属性    |           说明           |
| :-----: | :--------------------: |
| .string |         待匹配文本          |
|   .re   | 匹配时使用的pattern对象()正则表达式 |
|  .pos   |     正则表达式搜索文本的开始位置     |
| .endpos |     正则表达式搜索文本的结束位置     |

##### Match对象的方法

|    方法     |             说明              |
| :-------: | :-------------------------: |
| .group(0) |          获得匹配后的字符串          |
| .start()  |      匹配字符串在原始字符串的开始位置       |
|  .end()   |      匹配字符串在原始字符串的结束位置       |
|  .span()  | 返回(.start(),.end()) -- 元组类型 |

#### Re库的贪婪匹配和最小匹配

- Re库默认采用贪婪匹配

##### 最小匹配操作符

|  操作符   |          说明          |
| :----: | :------------------: |
|   *?   |  前一个字符0次或无限次扩展，最小匹配  |
|   +?   |  前一个字符1次或无限次扩展，最小匹配  |
|   ??   |  前一个字符0次或1次扩展，最小匹配   |
| {m,n}? | 扩展前一个字符m至n次(含n)，最小匹配 |

### 高效的正则表达式技巧总结

#### 误匹配

 指**正则表达式**所匹配的内容范围超过了所需要范围，有些文本命名不符合要求，但是被所写的正则表达式“击中”了。例如：如果使用\d{11}去匹配11位手机号，\d{11}不单单能匹配正确的手机号，它还会匹配98824839344这样明显不是手机号的**字符串**。我们把这样的匹配称为**误匹配**。

#### 漏匹配

 指正则表达式所匹配的内容所规定的范围太狭窄，有些文本确实是所需要的，但是所写的正则表达式没有将这种情况囊括在内。例如：使用\d{18}来匹配身份证号码，就会漏掉结尾是字母X的情况。
  写出一条**正则表达式**，既可能出现**误匹配**(条件写得太宽松，范围大于目标文本)，也可能出现**漏匹配**(只描述了目标文本中多种情况的部分)，还可能既有**误匹配**又有**漏匹配**。例如：使用\w+\.com来匹配.com结尾的域名，既会误匹配abc\_.com(合法域名不包含\_,\w包含了这种情况),又会漏掉ab-c.com这样的域名(合法域名可以包含中划线，\w不包含中划线).

#### 应对方法

##### 掌握语法细节

 正则表达式在各种语言中，其语法大致相同，细节各有千秋。明确所使用语言的正则的语法的细节，是写出正确、高效**正则表达式**的基础。例如，perl中与\w等效的匹配范围是[a-zA-Z0-9\_];perl正则表达式不支持肯定逆序视中使用可变的重复(variable repetition inside lookbehind,例如( ?<=.* )abc), 但是.Net语法是支持这一特性的；又如，JavaScript连逆序环视(lookbehind,如(?<=ab)c)都不支持，而Perl和Python是支持的。<<精通正则表达式>>第三章<<正则表达式的特性和流派概览>>明确地列出了个大派系的正则表达式的异同。

##### 先粗后精，先减后加

 使用正则表达式语法对于目标文本进行描述和界定，可以像画素描一样，先大致勾勒出框架，在逐步在局部实现细节。仍举刚才的手机例子：先界定\d{11},总不会错；再细化为1[358]\d{9},就向前迈了一大步。先消除 **漏匹配**(刚开始先尽可能多的匹配，做加法)，然后再一点点去除**误匹配**(做减法)。


